;==================================
; Script Name: Warrior's Assistant
; Author: Felix
; Version: 7.96
; Client Tested with: 6.0.13
; EUO version tested with: 1.5.148
; Shard FS: UODreams
; Public Release: 22/05/2009
; Purpose: helps warriors to live longer
;==================================

;---------SETUP-------------------

; set %TankMode #true ; to activate
; set %TankMode #false ; to deactivate
;it's just for fun. your pg will say lots of phrases, whan u cast some spells and some phrases every 20 secs.
set %TankMode #false

;just for fun of rome total war fans
;set %RTWMode #true
;set %RTWMode #false
set %RTWMode #false

;%activateRTWModeifromansaround #true ; to activate %RTWMode if somebody says "for the glory of rome"
;%activateRTWModeifromansaround #false ; nothing
;set %AutoLogoutIfDead #true ; to logout automaticaly if u died (in case of non-etheral pet)
;set %AutoLogoutIfDead #false ; just to pause script untill u r ressed
set %activateRTWModeifromansaround #false

set %AutoLogoutIfDead #true

;set %UseBendages #true ; to use bendages for healing
;set %UseBendages #false ; not to use bendages
set %UseBendages #false

; Hits to maximum hits for starting bendages; if u have 100 hp and want to start healing
;whan hp <= 95, so place 5 here
set %BendageHP 5

;set %InstantCurseWeapon #true ; to keep affect of curse weapon always whan war mode is on
;set %InstantCurseWeapon #false ; not to keep affect of curse weapon always
set %InstantCurseWeapon #false

;set %ImAfraidOfBloodOath #true ; to to turn off war-mode whan u r blood oathed
; if u want it to work u need to place file ScanBuffBar.txt in your easyuo directory
; this script is here http://www.easyuo.com/forum/viewtopic.php?t=26234
; i recomend to look for latest version
; also your baffbar should be orientaed with blue gem in right/down corner
;set %ImAfraidOfBloodOath #false ; not to react on blood oathed
set %ImAfraidOfBloodOath #false

;how often (in ms) to scan bafbar for bloodoath.
;notice: too often scanning may cause lag
set %BloodOathScanDelay 400

; whan your r hp goes less whan this value, script will just inform u about it. also about poison and mortal
set %informhp 95

;set %usecurseweapon #true ; if u use curse weapon
;set %usecurseweapon #false ; if u don't cast curse weapon
set %usecurseweapon #true

; whan your hp goes down this value, script will auto-cast confidence (if u use it),
; close wounds (if u use it). it also will try to hide (once or untill u turn hiding off)
set %crithp 90

; whan your hp goes down this value, script will auto-cast curse-weapon (if u use it),
set %cursehp 70

; set %autoclosewounds #true ; if u want close wounds to be casted, whan your hp goes < %crithp
; set %autoclosewounds #false ; if u dont want close wounds to be casted automaticaly.
set %autoclosewounds #true

;set %autoturnonhiding #true ; script will turn-on auto-hiding (untill u turn off it manualy by hotkey),
; whan your hp goes down %crithp
;set %autoturnonhiding #false ; script will not auto turn-on auto-hiding.
set %autoturnonhiding #false

;set %autoconfidence #true ; script will auto-cast confidence every 4 sec whan your hp goes down %crithp
;set %autoconfidence #false ; script will not auto-cast confidence
set %autoconfidence #false

;set %autocure #true ; if u want to auto-cast cleanse by fire, whan u r poisoned and hp < %curehp
;set %autocure #false ; if u don't need auto-casting  cleanse by fire
set %autocure #false

; it's needed only if u use auto-casting cleanse by fire. script will cast it whan u r poisoned and
; hp less whan this value. if r poisoned but hp is more whan it, script will not cast it.
set %curehp 85

; duration of curse weapon in miliseconds. 6000 for spirit speak 20. 12000 for 40. and so on + 6000 for every 20 ss
set %curseduration 6000

;Buttons
;for buttons there are ushually 2 values here. keyboard button (like 1, q, etc) and modifier (like alt and shift)
;so if set %UseTrap c and set %UseTrapMod alt. the action will be done whan u press C+Alt
;if u dont need a modifier at all leave space there like this: "set %UseTrapMod ". don't delete all the string.
;spells will be re-casted immidiatly after disturbing if u hold button.


; one button to cast close wounds (if u don't have full hp), clense by fire (if u r already poisoned),

set %HealBut q

; button to summon nature's fury. it will be summoned exactly near your enemy. or near u if previous summoning was blocked
;same key with alt - summon fury to direction where pg looks or at back direction if forward is blocked
;same key with shift - summon fury east or west.
set %FuryBut e

; button to cast remove curse on your self
set %RemCurseBut 1

;button to move to enemy or to turn on auto-following. the action of this key depends on 2 variables: %autofollow,%followDist
set %MoveKey 3

;set %autofollow #true ; if u want your pg to follow your enemy until it's dead, whan u press move-key.
;auto-following will be turned off in several cases:
;1 u press move-key again
;2 u turn-off war mode
;3 your hp goes down %crithp
;4 u recieved message "run away"
;5 u moved to crossheal a friend
;6 u turned on auto-honoring
;set %autofollow #false ; if u want just to move once to an enemy whan u pressed move-key
set %autofollow #true

;the disstance u will go from your enemy whan u press move-key
;set %followDist 1 ; if u want to stand just near
;set %followDist 0 ; if u want to stand in exact position of your enemy
;set %followDist 5 ; if u r archer
set %followDist 1

;hotkey to turn on/off chasing-mode. whan it's turned on u will move/follow to a place behind an enemy
;it will auto-turn off if enemy is far-away (or dead) or u changed enemy or following was turned off
set %ChaseKey w
set %ChaseKeyMod

; hotkey to turn off following-chasing without toggling
set %turnOffMoveKey 3
set %turnOffMoveKeyMod alt

; button to activate auto-honor. it will be turned-on untill script honors some mob of types from %HonorMobs or
; u press this button again. also. whan script honored some mob (u recieve message about it) u can press move-key
; immidiatly. script will atack honored mob automatically.
set %HonorKey s
set %HonorKeyMod

;button to rehonor mob
set %instantHonorKey s
set %instantHonorKeyMod shift

;types of mobs that auto-honor will search for.
set %HonorMobs EN_WO_XO_ZO_SO_NO_YO_VI_R , _ , ME_HI_FH_DH , _ , PH , _ , LC_FHB_II , _ , CN_PI

;button for using refresh potions. script doesn't do it on it's own. it just runs razor macro drinkRefresh
;so if u want it to work u need to make such macro in razor (with name drinkRefresh), that will
;undress shield and use a potion.
set %RefreshKey f3
set %RefreshKeyMod alt

;button to use trapped poches. u need also additional backpack. used pouches will be dropped there.
;it avoides using already used pouches, whan u restart script.
set %UseTrap c
set %UseTrapMod alt

;script will use trapped pouch automaticaly if one of this mob-types are nearby and your hp > %crithp
set %AutoTrapMobs WO_XO_NO_WO_YO , _ , FH

;button to atack closest revenant
;this button also runs razor macro with name KillRevenant. so u can do this macro to equip undead
;slayer, cast concentrate. or something else, that u want
set %KillRev a
set %KillRevMod alt

;button for turning on-off auto-hiding
set %HideKey c ; turn on/off hiding

; set %autohideifstanding #true ; to hide automatically if stand on one place without fighting
; set %autohideifstanding #false ; nothing
set %autohideifstanding #true

; set %autohideifwaroff #true ; to hide if following was turned off by turning off war-mod
; set %autohideifwaroff #false ; nothing
set %autohideifwaroff #true

; set %autohideiflowhp #true ; to hide if hp < %crithp or hp < %cursehp
;set %autohideiflowhp #false ; nothing
set %autohideiflowhp #true

;button for turning on/off auto-casting concentrate whan effect of previous cast is finished
; the duration if your concentrate is set in %concms variable
set %AutoConcKey 2
set %AutoConcKeyMod alt

;button to cast conecntrate
set %ConcKey

;types of mobs to auto turn-on autoconcentrate. whan u fight them.
set %AutoConcTypes ZO_SO_NO , _ , FD_ME_HI_FH , _ , LC_FHB_II , _ , CN_PI

;button for turning on/off auto-casting divne fury whan effect of previous cast is finished
; the dureation of your divne fury is set in %divinems variable
set %AutoDivineKey 4
set %AutoDivineKeyMod alt

;button to cast divne fury
set %DivineKey

;button to take gold from ground. hold it to gather all. avoid gathering on the run not to crash
set %TakeGoldKey g
set %TakeGoldKeyMod

;button to loot corpse
;it also drops off empty potions, loots item with property evaluation,
;loots gold without going overweight, drops off gold if your overweight with items
;if u want property evalution to work u need to place script BMItemEval.euo
;in your easyuo directory
;this script is there http://www.easyuo.com/forum/viewtopic.php?p=102726#102726
set %LootCorspeKey v
set %LootCorspeKeyMod

;value (0..40) of items to loot. 0 - all the rubbish, 40 - very rare items
set %lootvalue 25

;the amount of weight u dont want to carry more than
set %maxweight 430

;maximum duration of looting in ms
set %LootingTime 7000

;drop unneeded money from corpses to ground after looting
;set %DonateGP #true ; drop money from looted corpse to ground
;set %DonateGP #false ; not to drop money from copse to ground
set %DonateGP #false

;total quantity of restock types
;if u dont need restock set 0 ; set %RestockTypeQ 0
set %RestockTypeQ 4
;types of items to restock from loot and maximum quantity of item in backpack
set %RestockTypeId1 YZF ; pig iron
set %RestockTypeQ1 40
set %RestockTypeId2 ZUF ; refresh potion
set %RestockTypeQ2 85
set %RestockTypeId3 YUF ; agility potion
set %RestockTypeQ3 40
set %RestockTypeId4 XUF ; strength potion
set %RestockTypeQ4 40

;button to activate spawn killing mode. script will clean all the area until there are no mobs around
;beware: it will neither attack red nor blue targets. it may attack players' pets and players if they are criminal and in necroform
;this mode is turned off automatically, if following-mode is turned off  for any reason or there are no targets to attack
set %KillingSpawnKey
set %KillingSpawnKeyMod

;this is needed to determine if u need to turn off killingspawn and following if u r low hp or not
;set %StopFollowingWhanKSandLowHp #true ; to turnoff killingspawn if u r low hp
;set %StopFollowingWhanKSandLowHp #false ; not to turn off killingspawn if u r low hp
set %StopFollowingWhanKSandLowHp #true

; button to set target for crossheal. u don't need to do it every time u restart script.
; the id of target is stored in memory every time u set it, even if u restart pc.
set %SetFriendKey 6
set %SetFriendKeyMod

; button to cast remove curse on crossheal target
set %FrRemCurseKey 1
set %FrRemCurseKeyMod alt

; button to cast close wound, use bendages on crossheal target. if u hold button, u will come close to heal target
set %FrHealKey q
set %FrHealKeyMod alt

;button to turn on/off autocrossheal. u will unstopobly auto-bendage your heal target while your own hp higher than %HpCrossHealPriority
set %FrAutoHealKey
set %FrAutoHealKeyMod

;this variable is made for starting crossheal with bendaging even if your bendaging self is not finished yet
; so if variable is 100, u have 105 hp at the moment and strated applying bendages on self 1 second ago
;but pressed crossheal button, script will bendage your crossheal target immidiatly.
set %HpCrossHealPriority 100

; button to cast cleanse by fire, use bendages on crossheal target
set %FrCureKey w
set %FrCureKeyMod alt

;button to move to crossheal target
set %FrMoveKey
set %FrMoveKeyMod

;set correctly your amount of faster casting, faster cast recovery, lower mana cost. it affects all spells
set %FC 4
set %FCR 6
SET %LMC 34

;whan your fire resist goes down this value, remove curse will be casted automaticaly
;if u have fire resist in normal case less whan whis value, this casting will never stop
set %FR 65

;whan your dexterity goes down this value, remove curse will be casted automaticaly
;if u have dexterity in normal case less whan whis value, this casting will never stop
set %dex 0

;whan your stamina goes down this value, refresh potion will be used automaticaly (ot divine will be casted if auto-divine is on)
;also u will be informed about your current stamina.
;u need razor macro drinkRefresh for it
set %staminareport 119

;whan your dex goes down this value, the script will just inform u without any actions
set %dexreport 132

;the duration (in ms) of your divene fury for informing (or renewing) whan it's near finish
set %divinems 23000

;the duration (in ms) of your concentrate for informing or auto-casting whan it's near finish
set %concms 10500

;time (in ms) to inform before divine or concentrate finish
set %informtime 1000

;set %IRatedThisScript #false ; to open menu with link to script thread and a hint how to rate whan u start script;
;set %IRatedThisScript #true ; not to open menu
set %IRatedThisScript #true


;----don't edit bellow------------

set #lpc 5000
ignoreitem #charid
;gosub FCR_CALC
;goSub LMC
gosub CheckName
set %Thpinform #systime
set %nextcurse #systime + 3000
set %nextcast #systime
set %nextsay #systime
set %nexttarggorund #systime
set %nexttargcurs #systime
set %furycasttime 1700 - %FC * 180
set %remcasttime 32 - %FC * 5
set %healcasttime 32 - %FC * 5
set %confcasttime 500 ; ms
set %waittime 1500 - %FCR * 250
if %FCR = 7
   set %chivadelay 0
else
    set %chivadelay 250
set %furymanacost 24 * ( 100 - %LMC ) / 100
set %healmanacost 10 * ( 100 - %LMC ) / 100
set %remmanacost 20 * ( 100 - %LMC ) / 100
set %cursemanacost 7 * ( 100 - %LMC ) / 100
set %confmanacost 10 * ( 100 - %LMC ) / 100
set %concmanacost 10 * ( 100 - %LMC ) / 100
set %divinemanacost 15 * ( 100 - %LMC ) / 100
if %fc = 0
{
   set %curecasttime 1150
   set %divinecastdelay 1300 + %waittime + %chivadelay
}
if %fc = 1
{
   set %curecasttime 850
   set %divinecastdelay 1050 + %waittime + %chivadelay
}
if %fc = 2
{
   set %curecasttime 600
   set %divinecastdelay 800 + %waittime + %chivadelay
}
if %fc = 3
{
   set %curecasttime 400
   set %divinecastdelay 550 + %waittime + %chivadelay
}
if %fc = 4
{
   set %curecasttime 350
   set %divinecastdelay 400 + %waittime + %chivadelay
}
set %conccastdelay 350 - %FC * 38 + %waittime + %chivadelay
if %fc < 2
   set %cursecastdelay 1050 - %FC * 250 + %waittime
else
   set %cursecastdelay 550 + %waittime
set %jindex #jindex + 1
set %inparal #false
set %nextstaminareport #systime
set %nextrefresh #systime
set %nextconf #systime
set %nextsayatwill #systime
set %trapused #false
set %paralreported #false
set %movereported #true
set %notmounted #false
set %nextrunawaymsg #systime
set %nexthide #systime
set %furyblocked #systime
set %confcasted250 #systime
set %nextturnhiding #systime
set %hidingon #false
set %nexthidingreport #systime
set %checkcurse #false
set %checkconf #false
set %checkConc #false
set %followon #false
set %nextturnfollow #systime
set %EnemyHided #false
set %CantGetThere #false
set %NextFollowReport #systime
set %nextturnhonor #systime
set %honoron #false
set %NextHonorReport #systime
set %NextHonorFind #systime
set %HonoredSuccesfully #false
set %HonoredMob #false
set %blockrefresh #false
set %nextturnAutoConcentrate #systime
set %ConcentrateOn #false
set %concinformed #true
set %refreshused1000 #systime
set %FuryCasted4000 #systime
set %RemFrindCasted500 #systime
set %nextBend 0
set %BendUsed500 #systime
set %StupidTargetSystem #false
set %DivineOn #false
set %CheckDIvine #false
set %DivineCasted400 #systime
set %nextturnAutoDivine #systime
set %nextnothingtolootreport #systime
set %movingtolootreported7000 #systime
set %Divineinformed #true
set %ChaseOn #false
set %nextturnChase #systime
set %HonorCoolDown #false
set %NextHonorAvailable #systime
set %nextdognatcall 0
set %bendUsed400 #systime
set %CheckBend #false
set %MortalStatusForBends #false
set %divenend #systime - 10
set %concend #systime - 10
set %CrosshealOn #false
set %LastBendTarget self
set %nextturnAutoCrossheal #systime
set %finishSelfHealing 0
set %KillingRevenant #false
set %furydisturbed500 0
set %NextBloodOathScan 0
set %InOldOath #false
set %EndTurningOffWar 0
set %nextcrosshealIDreport #systime
set %NextEnemyDistReport 0
set %HealingGhost #false
set %nextlunch #systime + 5000
set %hadfood #false
set %foodjournalcheck #false
set %foodused2000 0
set %food RGG_HQD_HND_PQD_QQD_FUD_AQD_YRD_BND_SQD_PRD
set %NextTakeGold #systime
set %autohideifstandingPosX #charposx
set %autohideifstandingPosY #charposy
set %nextautohideifstanding #systime + 5000
set %CorpseRightsArrayInited #false
set %ignoreWMfolowTurnOFF 0
set %lootExpireTime 121000
set %NextAvailableCorpsesToLootReport #systime
set %AvailableCorpsesToLootReportDelay 4000
set %NextPathfindToCorpse #systime
set %nextCorpseRightsCheck #systime + %lootExpireTime
set %enemyidNA #true
set %KillingSpawn #false
set %nextKillingSpawnReport 0
set %BadIdForAttackN 0
ignoreitem XII_ZII_ASC_WRC_GDJ_ZRC
ignoreitem LNF_QNF_WNF_PNF_KNF_MNF_JNF_YNF_VNF
ignoreitem xc
ignoreitem NRBF
ignoreitem TUL_IVL_HVL_GVL_VUL_FVL_CVL ; 8th level spells
ignoreitem QYM_PYM_CZM
set %needCantGetIgnoreReset #false
set %nextCantGetIgnoreReset 0
set %instantHiding15000 #systime
set %nextXhealReport 0
set %nextXhealT 0
set %tankstealthsay 0
set %warmodeactivated500 #systime - 500
set %lastEnemyType XXXXXX
set %nextpilumsay #systime
set %lastActiveEnemy #false
set %nextmsgmobisntclose #systime

set %Friend *WarriorAsistFriendID
finditem %Friend G
if #findkind <> -1 && %UseBendages
{
    set #ltargetid xxxx
    set %TexitLoop #systime + 3000
    while %StupidTargetSystem = #false && #systime < %TexitLoop
    {
          event macro 50 5
          wait 1
          if #ltargetid = %Friend
          {
             set %StupidTargetSystem #true
             break
          }
    }
}
set %LootPack *WarriorAssistantLootPack
if %LootPack = #backpackid
   set %LootPack xxx
finditem %LootPack
if #findkind <> -1
{
   set #lobjectid %LootPack
   event macro 17 0
}
if %RestockTypeQ <> 0
{
   set %RestockTypeStr _
   for %i 1 %RestockTypeQ
   {
       set %RestockTypeIdCur %RestockTypeId . %i
       set %RestockTypeStr %RestockTypeStr , _ , %RestockTypeIdCur
   }
}

tile init

if %IRatedThisScript = #false
   gosub RateMenu


loop:

     if %IRatedThisScript = #false
     {
        if #menubutton <> n/a
        {
           if #menubutton = Rate
           {
              gosub RateMenu2
              set %URL http://www.easyuo.com/forum/viewtopic.php?t=40116
              execute %URL
              set #menubutton n/a
           }
           if #menubutton = Later
           {
              menu hide
              set #menubutton n/a
              set %IRatedThisScript #true
           }
        }
     }

     if yes in #charghost
     {
        set %charid #charid
        if %AutoLogoutIfDead
           gosub LogOut
        if %followon
           gosub turnfollow dead
        while yes in #charghost || %charid <> #charid
        {
              wait 1
        }
        set %jindex #jindex + 1
     }
     if ( #hits < %crithp || #hits < %cursehp ) && %inparal = #false && ( #systime >= %nextcast || #systime >= %nexthide )
        gosub extremal
     if %followon && #hits < %crithp && ( %killingspawn = #false || %StopFollowingWhanKSandLowHp )
        gosub turnfollow crithp
     if ( #FR <= %FR || ( #dex < %dex && #hits > %crithp ) ) && #mana >= %remmanacost && %inparal = #false
        gosub remcurs self
     if %autocure && c in #charstatus && #hits <= %curehp && #mana >= %healmanacost
        gosub cleansebyfire self
        
     if %InstantCurseWeapon
     {
        if #systime >= %nextcurse && G in #charstatus && #systime >= %nextcast && %inparal = #false
           gosub curseweap instant
     }

     gosub hotkeys

     if #systime < %nexttargcurs && #targcurs = 1 && 1 = 2
     {
        if %nexttargkind = 1
           gosub safeTargself
        if %nexttargkind = 2
           gosub targetground
     }

     if #stamina < %staminareport
     {

        if G in #charstatus && %DivineOn && ( #mana >= %divinemanacost + %healmanacost ) && #systime >= %nextcast && %inparal = #false
        {
           gosub Divine
           set %nextrefresh #systime + %divinecastdelay - %waittime - %chivadelay + 2000
        }
        else
        {
            if #systime >= %nextrefresh && ( #followers > 2 || #mana < %furymanacost || #systime > %furydisturbed500 || #systime < %nextcast ) && ( #fr > %fr || #mana < %remmanacost ) && h notin #charstatus
               gosub drinkRefresh
        }
     }

    if %jindex > ( #jindex + 1 )
    {
       ;pause
       set %jindex #jindex + 1
    }
    if %jindex <= #jindex
    {
        set %nextjinedxend #jindex
        for %ji %jindex %nextjinedxend
        {
            scanjournal %ji
            if %charname in #journal
            {
               if %charname , : , _consecrus_arma in #journal
               {
                  if %checkConc = #false
                  {
                     if %ConcentrateOn
                        set %concend #systime + %concms - ( %conccastdelay - %waittime ) - 1000
                     else
                     {
                         set %nextcast #systime + %conccastdelay
                         set %concend #systime + %concms - %informtime
                     }
                     set %concinformed #false
                  }
                  set %lastspell concentrate
                  set %checkConc #false
                  if %TankMode && #systime > %nextsay
                  {
                     event macro 1 0 Tanks FIRE !!!
                     set %nextsay #systime + 3000
                  }
                  if %RTWMode && #systime > %nextsay
                  {
                     event macro 1 0 hasta Push !!!
                     set %nextsay #systime + 3000
                  }

               }
               if %charname , : , _divinum_furis in #journal
               {
                  if %CheckDIvine = #false
                  {
                     if %DivineOn
                        set %divenend #systime + %divinems - ( %divinecastdelay - %waittime ) - 1000
                     else
                     {
                         set %divenend #systime + %divinems - %informtime
                         set %nextcast #systime + %divinecastdelay
                     }
                     set %divineinformed #false
                  }
                  set %lastspell divine
                  set %CheckDIvine #false
                  if %TankMode && #systime > %nextsay
                  {
                     event macro 1 0 Tanks make Haste !!!
                     set %nextsay #systime + 3000
                  }
                  if %RTWMode && #systime > %nextsay
                  {
                     event macro 1 0 make Haste !!!
                     set %nextsay #systime + 3000
                  }
               }
               if %charname , : , _Forul_Solum in #journal
               {
                  set %nextcast #systime + 1500 + %waittime + %chivadelay
                  set %lastspell enemy
                  if %TankMode && #systime > %nextsay
                  {
                     event macro 1 0 Tanks forward !!!
                     set %nextsay #systime + 3000
                  }
                  if %RTWMode && #systime > %nextsay
                  {
                     event macro 1 0 for the Glory of Rome
                     set %nextsay #systime + 3000
                  }
               }
               if %charname , : , _An_Sanct_Gra_Char in #journal
               {
                  if %checkcurse = #false
                  {
                      set %nextcurse #systime + %curseduration
                      set %nextcurse200 #systime + %curseduration + 200
                      set %nextcast #systime + %cursecastdelay
                      set %lastspell curse
                  }
                  set %checkcurse #false
               }
               if %charname , : , _Dispiro_Malas in #journal
               {
                  set %lastspell dispel
                  set %nextcast #systime + %waittime + 500 + %chivadelay
               }
               if %charname , : , _Dium_Prostra in #journal
               {
                  set %lastspell sacrifice
                  set %nextcast #systime + %waittime + 300 + %chivadelay
               }
            }
            if You_begin_applying_the_bandages. in #journal
            {
               if %LastBendTarget = friend
               {
                  if %HealingGhost = #false
                  {
                     goSub CountHealDelay friend
                     set %nextBend #systime + 300 + #result * 1000
                     event exmsg %friend 0 0 #result
                     set %nextXhealReport #result - 1
                     set %nextXhealT #SCNT + 1
                  }
                  else
                      set %nextBend #systime + 10000
                  set %finishSelfHealing #systime - 10
                  set %bendstart #systime
               }
               if %LastBendTarget = self
               {
                  goSub CountHealDelay self
                  set %nextBend #systime + 300 + #result * 1000
                  set %finishSelfHealing %nextBend
                  set %bendstart #systime
                  set %nextXhealReport 0
               }
               if %CheckBend
                  set %CheckBend #false
            }
            if %HealingGhost && able in #journal
            {
               set %nextBend #systime - 10
            }
            if You_finish_applying_the_bandages. in #journal || you_heal_what_little in #journal || they_barely_help in #journal || you_did_not_stay_close_enough in #journal
            {
               set %timetonextbend %nextBend - #systime
               if %timetonextbend > 0 && %timetonextbend < 1000
                  set %nextBend #systime - 10
              ; event exmsg #charid 0 0 f
            }
            if You_exude_confidence. in #journal
            {
                  if %checkconf = #false
                  {
                     set %confcasted250 #systime + 250
                     set %nextconf #systime + 4000
                     set %nextcast #systime + %waittime + %confcasttime
                     set %lastspell confidence
                  }
                  set %checkconf #false
            }
            if Your_attack_penetrates_their_armor in #journal
            {
              if %TankMode && #systime > %nextsay
              {
                 event macro 1 0 Tanks rocket Launch !!!
                 set %nextsay #systime + 3000
              }
            }
            if You_cannot_move in #journal && : notin #journal
            {
              set %inparal #true
              if %paralreported = #false
              {
                  event exMsg #charid 0 32 PARALYZE
                  set %paralreported #true
                  set %autopouchuse #true
              }
              set %movereported #false
            }
            if %lastsys <> fall && You_fall_off_of_your_mount in #journal
            {
              set %lastsys fall
              event exmsg #charid 0 32 dismounted
              set %notmounted #true
              set %mountreminder #systime + 9700
              set %nextclearlastsys #systime + 10000
            }
            if You_can_move in #journal && : notin #journal
              set %inparal #false
            if In_Aglo_Corp_Ylem in #journal
              event exMsg #charid 0 30 Corpse Skin
            if You_cannot_honor_this_monster_because_it_is_too_damaged. in #journal
            {
              event exMsg #charid 0 30 damaged
              if %HonoredSuccesfully && #systime <= %HonorUsed7000
                 set %HonoredSuccesfully #false
            }
            if You_no_longer_embrace_your_honor in #journal && %lastsys <> Honor
            {
              event exmsg #charid 0 54 honor faded
              set %lastsys Honor
              set %nextclearlastsys #systime + 10000
              set %HonorCoolDown #true
              set %NextHonorAvailable #systime + 305000
            }
            if A_SPECIAL_ARTIFACT_HAS_BEEN_BESTOWED_ON_YOU in #journal
              event exmsg #charid 0 54 ART ART ART ART ART ART ART ART ART ART ART ART ART
            if your_blood_oath_has_been_broken in #journal
            {
              event exmsg #charid 0 30 no blood oath
              if %InOldOath
              {
                 set %InOldOath #false
                 if G notin #charstatus
                    event macro 6 0
              }
            }
            if That_location_is_blocked in #journal
            {
              event exmsg #charid 0 30 blocked
              finditem #enemyid G_ , 11
              if #findkind <> -1
              {
                 set %furyblocked #systime + 8000
                 set %furyblockedx #findx
                 set %furyblockedy #findy
              }
            }
            if Target_cannot_be_seen. in #journal
            {
              if #systime <= %HonorUsed3000
              {
                 set %honoron #true
                 set %NextHonorFind #systime + 1000
              }
              if #systime <= %FuryCasted4000
              {
                  event exmsg #charid 0 30 blocked
                  finditem #enemyid G_ , 11
                  if #findkind <> -1
                  {
                     set %furyblocked #systime + 4000
                     set %furyblockedx #findx
                     set %furyblockedy #findy
                  }
              }
            }
            if That_is_too_far_away in #journal
            {
               if #systime <= %HonorUsed3000
               {
                  set %honoron #true
                  set %NextHonorFind #systime + 1000
               }
               if #systime < %FrBendUsed400
               {
                  set %nextbend #systime - 10
                  ;set %nextXhealReport 0
               }
            }
            if ( disturbed IN #journal && : notin #journal ) || Insufficient_mana_for_this_spell in #journal
            {
              if %lastspell = curse
              {
                 set %checkcurse #true
                 set %cursecasted400 #systime - 10
              }
              if %lastspell = confidence
              {
                 set %checkconf #true
                 set %confcasted1000 #systime - 10
              }
              if %lastspell = concentrate
              {
                  set %concend #systime - 10
                  set %concinformed #false
                  set %nextcast #systime - 10
              }
              if %lastspell = divine
              {
                 set %divenend #systime - 10
                 set %divineinformed #false
                 set %nextcast #systime - 10
              }
            }
            if recovered IN #journal
               set %lastrecspell %lastspell
            if Can't_get_there in #journal
            {
              set %CantGetThere #true
              if %killingspawn
              {
                 finditem #enemyid
                 if #findkind <> -1
                 {
                    ignoreitem #findid CantGetThere10
                    set %nextCantGetIgnoreReset #systime + 10000
                    set %needCantGetIgnoreReset #true
                 }
              }
            }
            if #systime <= %hideUsed5000
            {
              if %charname , : , _You_fail_to_hide. in #journal
              {
                 set %nexthide #systime + 10200
                 set %nexthidingreport #systime + 9500
              }
              if %charname , : , You_have_hidden_yourself_well. in #journal
              {
                 set %nexthide #systime + 10200
                 set %nexthidingreport #systime + 9500
              }
              if You_must_wait_a_few_moments_to_use_another_skill. in #journal
                 set %nexthide #systime + 1000
              if %charname , : , You_can't_seem_to_hide_right_now. in #journal
                 set %nexthide #systime + 1000
            }
            if There_is_no_current_target in #journal && %StupidTargetSystem
               set %StupidTargetSystem #false
            if That_being_is_not_damaged in #journal && #systime <= %FrBendUsed400
            {
                   set %nextbend #systime + 500
                   ;set %nextXhealReport 0
            }
            if _has_changed_by_ in #journal
            {
               if Your_dexterity_has_changed_by_- in #journal
                  event exMsg #charid 0 32 DEX
               if Your_intelligence_has_changed_by_- in #journal
                  event exMsg #charid 0 32 INT
               if Your_strength_has_changed_by_- in #journal
                  event exMsg #charid 0 32 STR
            }
            if %foodjournalcheck
            {
               if You_eat_the_food,_and_begin_to_feel_more_satiated. in #journal || After_eating_the_food,_you_feel_much_less_hungry. in #journal || You_feel_quite_full_after_consuming_the_food. in #journal
               {
                  set %nextlunch #systime + 700
                  set %foodjournalcheck #false
               }
               if You_manage_to_eat_the_food,_but_you_are_stuffed in #journal || You_are_simply_too_full_to_eat_any_more in #journal
               {
                  set %nextlunch #systime + 900000
                  set %foodjournalcheck #false
               }
            }
            if The_Arcane_Focus_expired... in #journal
               event exmsg #charid 0 18 arcan expired
            if who_are_we? in #journal
               event macro 1 0 WE ARE THE LEGION
            if %activateRTWModeifromansaround && for_the_Glory_of_Rome in #journal
               set %RTWMode #true
       }
       set %jindex %nextjinedxend + 1
    }
    set %JournalRead #true
    if #SYSMSG <> N/A
    {
           if You_cannot_move in #SYSMSG
           {
              set %inparal #true
              if %paralreported = #false
              {
                  event exMsg #charid 0 32 PARALYZE
                  set %paralreported #true
                  set %autopouchuse #true
              }
              set %movereported #false
           }
           if You_can_move in #SYSMSG
              set %inparal #false
           if %lastsys <> fall && You_fall_off_of_your_mount in #SYSMSG
           {
              set %lastsys fall
              set %notmounted #true
              set %mountreminder #systime + 9700
              set %nextclearlastsys #systime + 10000
              event exmsg #charid 0 32 dismounted
           }
           if You_no_longer_embrace_your_honor in #SYSMSG && %lastsys <> Honor
           {
              event exmsg #charid 0 54 honor faded
              set %lastsys Honor
              set %nextclearlastsys #systime + 10000
              set %HonorCoolDown #true
              set %NextHonorAvailable #systime + 305000
           }
           if A_SPECIAL_ARTIFACT_HAS_BEEN_BESTOWED_ON_YOU in #SYSMSG
              event exmsg #charid 0 54 ART ART ART ART ART ART ART ART ART ART ART ART ART
           if %lastsys <> X && #systime >= %nextclearlastsys
              set %lastsys X
    }
    else
        set %lastsys X

           if %checkcurse && #systime >= %cursecasted400
            {
                              set %nextcurse #systime - 10
                              set %nextcurse200 #systime - 10
                              set %nextcast #systime - 10
                              set %checkcurse #false
            }

            if %CheckDIvine && #systime >= %DivineCasted400
            {
               set %nextcast #systime - 10
               set %CheckDIvine #false
               set %divineinformed #false
               set %divenend #systime - 10
            }

            if %checkConc && #systime >= %Conccasted400
            {
                              set %nextcast #systime - 10
                              set %checkConc #false
                              set %concinformed #false
                              set %concend #systime - 10
            }

            if %checkconf && #systime >= %confcasted1000
            {
                          set %checkconf #false
                          set %nextconf #systime - 10
                          set %nextcast #systime - 10
            }

            if %CheckBend && #systime >= %bendUsed400
            {
               set %CheckBend #false
               set %nextBend #systime - 10
            }
            if %foodjournalcheck && #systime >= %foodused2000
            {
                   set %nextlunch #systime
                   set %foodjournalcheck #false
            }

    if %movereported = #false
    {
       if %inparal = #false
       {
          event exmsg #charid 0 0 move move
          SET %movereported #true
          set %paralreported #false
          set %autopouchuse #false
       }
       else
       {
           if %autopouchuse && #hits > %crithp && #fr > %FR
           {
              finditem %AutoTrapMobs G_ , 12
              if #findkind <> -1
                 gosub UseTrap
           }
       }
    }
    gosub hotkeys
    if %notmounted && #systime > %mountreminder
    {
       event exMsg #charid 0 0 MOUNT NOW
       event macro 1 0 -macro Mount
       set %notmounted #false
       set %lastsys X
    }
    if %trapused && #systime >= %dragtrap && #systime > %nextrefresh && #hits > %crithp && #FR > %FR
       gosub dragTrap
       
    if %concinformed = #false && #systime > %concend
    {
       if %ConcentrateOn
       {
          if ( #hits > %crithp || #systime < %nextcurse ) && ( #followers > 1 || #systime > %FuryCasted4000 ) && #fr > %fr && h notin #charstatus && %inparal = #false
             gosub AutoConcentrare normal

       }
       else
       {
           if %KillingRevenant = #false
           {
              event ExMsg #charID 0 20 Conecntrate
              set %concinformed #true
           }
           else
               gosub Concentrate
       }
    }

    if %divineinformed = #false && #systime >= %divenend
    {
       if %DivineOn
       {
          if #hits > %crithp && ( #followers > 2 || #systime > %FuryCasted4000 ) && #fr > %fr && h notin #charstatus && %inparal = #false
          {
             goSub Divine Auto
          }
       }
       else
       {
           event ExMsg #charID 0 20 Divine
           set %divineinformed #true
       }
    }
    
    if %KillingRevenant
    {
       finditem %rev G
       if #findkind = -1
       {
          set %KillingRevenant #false
          event ExMsg #charID 0 30 Revenant Killed
       }
       if g notin #charstatus
          set %KillingRevenant #false
       if g in #charstatus && #enemyid <> N/A && #enemyid <> %rev
          set %KillingRevenant #false
    }
    
    if %HonorCoolDown && #systime >= %NextHonorAvailable
    {
             set %HonorCoolDown #false
             event exmsg #charid 0 54 honor available
    }

    if ( #hits < %crithp || #FR < %FR ) && #systime >= %nextrunawaymsg
    {
       if %inparal = #false && ( ( #FR < %FR && #mana < %remmanacost ) || ( #hits < %crithp && #mana < %cursemanacost && #systime > %nextcurse200 ) )
       {
          set %nextrunawaymsg #systime + 3000
          if %followon
             gosub turnfollow run
          event exmsg #charid 0 0 RUN AWAY
          if %autoturnonhiding
             set %hidingon #true
       }
    }

     if #hits < %informhp && ( #systime >= %Thpinform || #hits <> %lastHitsInformed || ( ( D in #charstatus ) <> %lastmortalstatus ) || ( ( C in #charstatus ) <> %lastpoisonstatus ) )
     {
        set %lastmortalstatus D in #charstatus
        set %lastpoisonstatus C in #charstatus
        set %HpInformString #hits
        if %lastpoisonstatus
           set %HpInformString %HpInformString , #spc , P
        if %lastmortalstatus
           set %HpInformString %HpInformString , #spc , M

        event ExMsg #charid 0 51 %HpInformString
        set %lastHitsInformed #hits
        set %Thpinform #systime + 10000
        set %HpInformed #True
     }
     if %HpInformed && #hits >= %informhp
     {
        set %lastmortalstatus D in #charstatus
        set %lastpoisonstatus C in #charstatus
        set %HpInformString #hits
        if %lastpoisonstatus
           set %HpInformString %HpInformString , #spc , P
        if %lastmortalstatus
           set %HpInformString %HpInformString , #spc , M

        event ExMsg #charid 0 51 %HpInformString
        set %HpInformed #False
        set %Thpinform #systime
     }

     if ( #stamina < %staminareport || #dex < %dexreport ) && #systime >= %nextstaminareport
     {
        if #dex >= %dexreport
        {
           event ExMsg #charid 0 20 stamina #stamina
            set %nextstaminareport #systime + 5000
        }
        else
        {
            event ExMsg #charid 0 20 dex #dex
            set %nextstaminareport #systime + 5000
        }
        set %staminareported #True
     }
     if %staminareported && #dex >= %dexreport && #stamina >= %staminareport
     {
        set %staminareported #False
        set %nextstaminareport #systime
     }

     if %furyreminder && #systime >= %nextremindfury && #mana >= %furymanacost && #FR > %FR && #hits > %crithp && %inparal = #false && #systime > ( %nextcast - 300 )
     {
        set %remind #false
        if #followers = 1 && #mana >= ( %furymanacost + 3 )
           set %remind #true
        if #followers = 2
        {
           if #mana >= ( %furymanacost * 16 ) / 10
              set %remind #true
        }
        if #followers = 3
        {
           if #mana >= ( #maxmana - 10 )
              set %remind #true
        }
        if #followers = 4
        {
           if #mana = #maxmana
              set %remind #true
        }
        if %remind
        {
           if %firstfuryremind
           {
              if %lastFuryRemindColour = 6
                 set %lastFuryRemindColour 71
              else
                 set %lastFuryRemindColour 6
              set %turnofffuryreminder #systime + 7000
              set %firstfuryremind #false
              set %FuryRemindColour %lastFuryRemindColour
           }
           else
               set %FuryRemindColour %FuryRemindColour - 1
           set %nextremindfury #systime + 3000
           finditem #enemyid G
           if #findkind <> -1 && #finddist > 1
              event exMsg #charid 0 %FuryRemindColour far Fury
           else
               event exMsg #charid 0 %FuryRemindColour Fury
        }
        if #systime > %turnofffuryreminder && #followers <> 5
           set %furyreminder #false
     }

     if %hidingon
     {
        if #systime > %nexthidingreport
        {
           event exMsg #charid 0 11 hiding
           set %nexthidingreport #systime + 20000
        }
        if #systime >= %nexthide && h notin #charstatus
           gosub hide
     }

     if %honoron && #systime >= %NextHonorFind
     {
        gosub Honor
        set %NextHonorFind #systime + 300
     }

     if %TankMode && #hits > %crithp && C notin #charstatus && #systime > %nextsay && #systime > %nextsayatwill && H notin #charstatus
        gosub sayatwill
     if %RTWMode && #hits > %crithp && C notin #charstatus && #systime > %nextsay && #systime > %nextsayatwill && H notin #charstatus
        gosub sayatwillRTW
        
     if #enemyid <> N/A && %PreviousEnemyId <> #enemyid
     {
        finditem #enemyid g
        if #findkind <> -1
           set %lastEnemyType #findtype
        set %PreviousEnemyId #enemyid
        gosub BadIdForAttackDel %PreviousEnemyId
        gosub OrgoniseLastAttackArray %PreviousEnemyId
        set %NextEnemyDistReport #systime - 10
     }
     
     if %followon = #false && #systime >= %NextEnemyDistReport
     {
        finditem %PreviousEnemyId G
        if #findkind = -1
           set %NextEnemyDistReport #systime + 1000
        if #findkind <> -1 && #finddist > %followdist
        {
           event exmsg #charid 0 26 #finddist dist
           set %NextEnemyDistReport #systime + 1500
        }
     }

     if #systime >= %nextlunch && #hits = #maxhits && c notin #charstatus && h notin #charstatus
           gosub eat
           
     if #enemyid = n/a && %autohideifstanding && #systime >= %nextautohideifstanding
     {
        set %nextautohideifstanding #systime + 11000
        if #charposx = %autohideifstandingPosX && #charposy = %autohideifstandingPosY
        {
           if h notin #charstatus && #systime >= %nexthide
              gosub hide
        }
        set %autohideifstandingPosX #charposx
        set %autohideifstandingPosY #charposy
        if #systime < %instantHiding15000
           set %nextautohideifstanding + 500
     }

     if %enemyidNA = #false && #enemyid = n/a
     {
        set %enemyidNA #true
        set %lastActiveEnemy #false
        
        if G notin #charstatus
        {
           if %ConcentrateOn
              gosub TurnAutoConcentrate WM
           if %DivineOn
              gosub TurnAutoDivine WM
        }
     }
     if #enemyid <> n/a && ( %enemyidNA || %lastActiveEnemy <> #enemyid )
     {
        set %lastActiveEnemy #enemyid
        finditem #enemyid g
        if #findkind <> -1
        {
           if #findtype in %AutoConcTypes
           {
              if %ConcentrateOn = #false
                 gosub TurnAutoConcentrate AutoConcTypes
           }
        }
        set %enemyidNA #false
     }
     
     if #systime >= %nextCorpseRightsCheck
        gosub CorpseRightsArrayCheck

     gosub hotkeys
     
     IF %KillingSpawn
     {
        if %needCantGetIgnoreReset && #systime >= %nextCantGetIgnoreReset
        {
           ignoreitem reset CantGetThere10
           set %needCantGetIgnoreReset #false
        }
        if #systime >= %nextKillingSpawnReport
        {
           gosub KillingSpawn AutoReport
           set %nextKillingSpawnReport #systime + 20000
        }
     }
goto loop

sub hotkeys
     if %followon && #systime >= %nextdognatcall && %inparal = #false
        gosub dognat auto
     sleep 20
     if %ImAfraidOfBloodOath && #systime >= %NextBloodOathScan
       gosub AntiBloodOath
     if %CrosshealOn
       gosub AutoCrossheal
     gosub BendageSelf
     onhotkey %turnOffMoveKey %turnOffMoveKeyMod
              gosub turnfollow TurnOff
     onhotkey %MoveKey
              gosub follow
     onhotkey %HealBut
              gosub chivaheal
     onhotkey %FuryBut
              gosub summonfury charpos
     onhotkey %FuryBut alt
              gosub summonfury direction
     onhotkey %FuryBut shift
              gosub summonfury WestEast
     onhotkey %RemCurseBut
              gosub remcurs self
     onhotkey %RefreshKey %RefreshKeyMod
              gosub drinkRefresh
     onhotkey %KillRev %KillRevMod
              gosub killrevenant
     onhotkey %UseTrap %UseTrapMod
              gosub UseTrap
     onhotkey %HideKey
              gosub turnhiding
     onhotkey %HonorKey %HonorKeyMod
              gosub TurnHonor
     onhotkey %AutoConcKey %AutoConcKeyMod
              gosub TurnAutoConcentrate normal
     onhotkey %SetFriendKey %SetFriendKeyMod
              gosub SetHealFriend
     onhotkey %FrRemCurseKey %FrRemCurseKeyMod
              gosub remcurs %friend
     onhotkey %FrHealKey %FrHealKeyMod
              gosub HealFriend
     onhotkey %FrCureKey %FrCureKeyMod
              gosub CureFriend
     onhotkey %ConcKey
              gosub Concentrate
     onhotkey %AutoDivineKey %AutoConcKeyMod
              gosub TurnAutoDivine normal
     onhotkey %DivineKey
              gosub Divine normal
     onhotkey %ChaseKey %ChaseKeyMod
              gosub TurnChasing normal
     onhotkey %FrAutoHealKey %FrAutoHealKeyMod
              gosub TurnAutoCrossheal normal
     onhotkey %FrMoveKey %FrMoveKeyMod
             gosub movetofriend
     onhotkey %TakeGoldKey %TakeGoldKeyMod
              gosub GatherGold
     onhotkey %LootCorspeKey %LootCorspeKeyMod
              gosub LootCorpse
     onhotkey %KillingSpawnKey %KillingSpawnKeyMod
             gosub KillingSpawn hotkey
     onhotkey %instantHonorKey %instantHonorKeyMod
              gosub InstantReHonor
return

sub TurnHotkeys
    sleep 10
    if %ImAfraidOfBloodOath && #systime >= %NextBloodOathScan
       gosub AntiBloodOath
    if %CrosshealOn
       gosub AutoCrossheal
    if %UseBendages
       gosub BendageSelf
    onhotkey %turnOffMoveKey %turnOffMoveKeyMod
              gosub turnfollow TurnOff
    onhotkey %HideKey
              gosub turnhiding
    onhotkey %AutoConcKey %AutoConcKeyMod
             gosub TurnAutoConcentrate normal
    onhotkey %AutoDivineKey %AutoDivineKeyMod
              gosub TurnAutoDivine normal
    onhotkey %ChaseKey %ChaseKeyMod
              gosub TurnChasing normal
    onhotkey %HonorKey %HonorKeyMod
              gosub TurnHonor
    onhotkey %MoveKey
              gosub follow
    onhotkey %FrAutoHealKey %FrAutoHealKeyMod
              gosub TurnAutoCrossheal
return

sub LootSetup
    set %setup #false
          set #targcurs 1
          event exmsg #charid 0 0 target pack to put items in
          while #targcurs = 1
          {
                sleep 10
          }
          set %LootPack #ltargetid
          while g in #charstatus
          {
                event macro 6 0
                set %waitforoffwar #systime + 350
                while g in #charstatus && #systime < %waitforoffwar
                {
                      sleep 10
                }
          }
          set #lobjectid %LootPack
          event macro 17 0
          set %endWaitCont #systime + 1000
          while #systime < %endWaitCont && ( #CONTNAME <> container_gump || #CONTID <> %LootPack )
          {
                sleep 10
          }
          if #CONTNAME = container_gump && #CONTID = %LootPack && #CONTTYPE <> YFM
          {
             set %setup #true
             event exmsg #charid 0 0 OK
             set *WarriorAssistantLootPack %LootPack
          }
          else
          {
              event exmsg #charid 0 0 invalid container. main pack is used
              set %LootPack #backpackid
          }
return %setup

sub LootCorpse
  set %usedpathfinddtoloot #false
  LootStart:
  if %usedpathfinddtoloot
     set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
  finditem %LootPack
  if #findkind = -1
     gosub LootSetup
    ;pause
    ;searching closest corpse %CorpseID
   Finditem YFM G_2
   if #findkind <> -1
   {
      if #findcnt > 1
      {
         set %CorpseID #findid
         set %mdist #finddist
         for #findindex 2 #findcnt
         {
             if #finddist < %mdist
             {
                set %CorpseID #findid
                set %mdist #finddist
             }
         }
      }
      else
          set %CorpseID #findid
      set %NextPathfindToCorpse #systime - 10
   }
   else
   {
       if #systime > %NextAvailableCorpsesToLootReport
       {
          finditem YFM G_ , 15
          if #findkind <> -1
          {
             for #findindex 1 #findcnt
             {
                 if #findindex = 10
                 {
                    event exmsg #findid 0 0 too many loot
                    break
                 }
                 event exmsg #findid 0 0 loot
             }
             set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
          }
          else
          {
              if #systime > %nextnothingtolootreport
              {
                 event exmsg #charid 0 38 nothing to loot
                 set %nextnothingtolootreport #systime + 1000
              }
          }
          return #false
       }
       else
       {
           if #systime > %NextPathfindToCorpse
           {
              Finditem YFM G_15
              if #findkind <> -1
              {
                 if #findcnt > 1
                 {
                    set %CorpseIDtoMove #findid
                    set %mdist #finddist
                    for #findindex 2 #findcnt
                    {
                        if #finddist < %mdist
                        {
                           set %CorpseIDtoMove #findid
                           set %mdist #finddist
                        }
                    }
                 }
                 else
                     set %CorpseIDtoMove #findid
                 finditem %CorpseIDtoMove G_ , 15
                 if #findkind <> -1
                 {
                    set %HitsBeforeMovingToCorpse #hits
                    gosub MoveToMod #findx #findy #findz 2
                    finditem %CorpseIDtoMove G_ , 15
                    if #finddist > 3 || #systime > %movingtolootreported7000
                    {
                       event exmsg #charid 0 53 moving to loot
                       set %movingtolootreported7000 #systime + 7000
                    }
                    set %usedpathfinddtoloot #true
                    set %NextPathfindToCorpse #systime + 2000
                    while #findkind <> -1 && #hits >= %HitsBeforeMovingToCorpse && #systime <= %NextPathfindToCorpse && ( ( abs ( #charposx - #findx ) > 2 ) || ( abs ( #charposy - #findy ) > 2 ) )
                    {
                          sleep 10
                          finditem %CorpseIDtoMove G_ , 15
                    }
                    if #hits < %HitsBeforeMovingToCorpse
                    {
                       event exmsg #charid 0 38 stopped HP
                       return
                    }
                    finditem %CorpseIDtoMove G_ , 15
                    if #systime > %NextPathfindToCorpse
                    {
                       event exmsg #charid 0 38 move timeout
                       return
                    }
                    if #findkind = -1
                    {
                       event exmsg #charid 0 38 loot disappeared
                       return
                    }
                    if #finddist > 2
                    {
                       event exmsg #charid 0 38 Dist loot #finddist
                       return
                    }
                    if #findkind <> -1 && ( ( abs ( #charposx - #findx ) <= 2 ) && ( abs ( #charposy - #findy ) <= 2 ) )
                       goto LootStart
                 }
              }
              else
              {
                  if #systime > %nextnothingtolootreport
                  {
                     event exmsg #charid 0 75 trophies are gathered
                     set %nextnothingtolootreport #systime + 3000
                  }
              }
           }
           return #false
       }
   }
   if %followon
      gosub turnfollow loot
   if %ConcentrateOn
      gosub TurnAutoConcentrate loot
   if %DivineOn
      gosub TurnAutoDivine loot
   event exmsg #charid 0 53 looting...
   ;turning off war-mod
   while g in #charstatus
   {
         event macro 6 0
         set %waitforoffwar #systime + 350
         while g in #charstatus && #systime < %waitforoffwar
         {
                 sleep 10
         }
   }

set %jindex2 #jindex + 1
CorpseOpening:
finditem %CorpseID G_2
if #findkind = -1
{
    finditem %CorpseID
    event exmsg #charid 0 38 Dist loot #finddist
    return
}
if #CONTID <> %CorpseID
{
   set #lobjectid %CorpseID
   event macro 17 0
   set %TreadyToLoot #systime + 570
}
else
    set %TreadyToLoot #systime
; 1111111111111111111111111111111111opening corpse
set %nextOpenCorpseTry #systime + 500
set %CorpseIgnored #false
set %OpenCorpseAgain #false
set %CorpseToofaraway #false
while #systime < %nextOpenCorpseTry && %CorpseID <> #CONTID && %CorpseIgnored = #false && %OpenCorpseAgain = #false && %CorpseToofaraway = #false
{
    set %nextjinedxend2 #jindex
    if %jindex2 <= %nextjinedxend2
    {
       for %j2 %jindex2 %nextjinedxend2
       {
           scanjournal %j2
           if You_did_not_earn_the_right in #journal || You_may_not_loot_this_corpse. in #journal
                   set %CorpseIgnored #true
           if You_must_wait_to_perform_another_action. in #journal
           {
              wait 3
              set %OpenCorpseAgain #true
           }
           if target_cannot_be in #journal
                   set %CorpseIgnored #true
       }
       set %jindex2 %nextjinedxend2 + 1
    }

    finditem %CorpseID G_2
    if #findkind = -1
       set %CorpseToofaraway #true
    sleep 10
}
if %CorpseToofaraway
{
    finditem %CorpseID
    event exmsg #charid 0 38 Dist loot #finddist
    return
}
if %CorpseIgnored
   goto LootFinished
if #systime >= %nextOpenCorpseTry || %OpenCorpseAgain
   goto CorpseOpening

if #conttype = YFM
   set %lastcont #CONTID
   
set %charposx #charposx
set %charposy #charposy
set %HitsBeforeLoot #hits - 10

;waiting to be able to loot
while #systime < %TreadyToLoot && %CorpseIgnored = #false
{
    if #conttype = YFM
         set %lastcont #CONTID

    set %nextjinedxend2 #jindex

    if %jindex2 <= %nextjinedxend2
    {
       for %j2 %jindex2 %nextjinedxend2
       {
           scanjournal %j2
           if You_did_not_earn_the_right in #journal
              set %CorpseIgnored #true
       }
       set %jindex2 %nextjinedxend2 + 1
    }
    sleep 10
}
if %CorpseIgnored
   goto LootFinished

;dropping off empty bottles
finditem WUF C_ , #backpackid
if #findkind <> -1
{
   set %EmptyBottlesQ 0
   for #findindex 1 #findcnt
   {
       set %EmptyBottlesQ %EmptyBottlesQ + #findstack
   }
   if %EmptyBottlesQ >= 20
   {
      repeat
              exevent drag #findid #findstack
              exevent dropg #charposx #charposy #charposz
              wait 11
              finditem WUF C_ , #backpackid
      until #findkind = -1
   }
}

set %TimeendLoot #systime + %LootingTime
set %OpenCorpseAgain #false

;restocking
;pause

set %HitsLessThanBeforeLoot #false
if %RestockTypeQ <> 0
{
   finditem %RestockTypeStr C_ , %CorpseID
   while #systime < %TimeendLoot && #findkind <> -1
   {
         for %i 1 %RestockTypeQ
         {
             if #findtype = %RestockTypeId . %i
             {
                set %RestockTypeIDQ %RestockTypeQ . %i
             }
         }
         if %charposx <> #charposx || %charposy <> #charposy
         {
             set %OpenCorpseAgain #true
             break
         }
         if #hits < %HitsBeforeLoot
         {
            set %HitsLessThanBeforeLoot #true
            break
         }
         gosub Restock #findid #findtype #findstack %RestockTypeIDQ
         finditem %RestockTypeStr C_ , %CorpseID
   }
   if %HitsLessThanBeforeLoot
   {
      event exmsg #charid 0 38 stopped HP
      set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
      return #false
   }
   if %OpenCorpseAgain
   {
      set %lastcont xxx
      goto CorpseOpening
   }
   ignoreitem reset Restock

}
;11111111111111111111111looting items
;pause
set %goldQ 0
finditem * C_ , %CorpseID
if #findcnt = 0 || #findkind = -1
{
   wait 10
   finditem * C_ , %CorpseID
}
while #systime < %TimeendLoot && #findkind <> -1 && %OpenCorpseAgain = #false && %HitsLessThanBeforeLoot = #false
{
      for #findindex 1 #findcnt
      {
          if #systime >= %TimeendLoot
             break
          if #findtype = POF
          {
             set %goldQ %goldQ + 1
             if #findcnt = #findindex || %goldQ > 1
             {
                if #weight >= %maxweight - 10
                {
                   ignoreitem #findid GP
                   continue
                }
                set %cantakegold ( %maxweight - #weight ) * 150
                if #findstack < %cantakegold
                   set %cantakegold #findstack
                if %cantakegold = 0
                {
                   ignoreitem #findid GP
                   continue
                }
                set %ItemToLoot #findid
                set %FindStack %cantakegold
             }
             else
                 continue
          }
          if #findtype <> POF && #findstack > 1
          {
                 ignoreitem #findid
                 continue
          }
          if #findtype <> POF
          {
             repeat
                   event property #findid
                   sleep 10
             until ( weight in #property ) || ( #systime >= %TimeendLoot )
             if #systime >= %TimeendLoot
                break
             set %iev_done #false
             CALL BMItemEval.euo #findid
             ;event macro 1 0 #result
             if #result >= %lootvalue
             {
                set %ItemToLoot #findid
                set %FindStack #findstack
             }
             else
             {
                 ignoreitem #findid
                 continue
             }
          }
          dragagain:
          if #hits < %HitsBeforeLoot
          {
            set %HitsLessThanBeforeLoot #true
            break
          }
          if %charposx <> #charposx || %charposy <> #charposy
          {
             set %OpenCorpseAgain #true
             break
          }
          exevent drag %ItemToLoot %FindStack
          exevent dropc %LootPack
          set %pauseforloot #systime + 600
          ;wait 3
          set %nextjinedxend2 #jindex
          set %dragagain #false
          while #systime < %pauseforloot
          {
                if %jindex2 <= %nextjinedxend2
                {
                   for %j2 %jindex2 %nextjinedxend2
                   {
                       scanjournal %j2
                       if You_must_wait_to_perform_another_action in #journal
                       {
                         wait 1
                         set %dragagain #true
                         break
                       }
                   }
                   set %jindex2 %nextjinedxend2 + 1
                }
                if %dragagain
                   break
          }
          if %dragagain
             goto dragagain
      }
      finditem * C_ , %CorpseID
}
if %HitsLessThanBeforeLoot
{
      event exmsg #charid 0 38 stopped looting HP
      set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
      return #false
}
if #systime >= %TimeendLoot
{
   event exmsg #charid 0 38 loot timeout
   return
}
if %OpenCorpseAgain
{
   set %lastcont xxx
   goto CorpseOpening
}


;dropping off gold
   if #weight > %maxweight
   {
              finditem POF C_ , %LootPack
              while #weight > %maxweight && #findkind <> -1
              {
                    set %goldtodrop ( #weight - %maxweight ) * 150
                    if %goldtodrop < 1000
                       set %goldtodrop 1000
                    if #findstack < %goldtodrop
                       set %goldtodrop #findstack
                    exevent drag #findid %goldtodrop
                    exevent dropg #charposx #charposy #charposz
                    wait 11
                    finditem POF C_ , %LootPack
              }
   }
finditem %CorpseID
if #findkind <> -1 && #finddist > 2
{
    event exmsg #charid 0 38 Dist loot #finddist
    return
}

;donating gold
if %DonateGP
{
   ignoreitem reset GP
   finditem POF C_ , %CorpseID
   while #findkind <> -1 && #systime < %TimeendLoot
   {
      set %AmountToDrop #findstack
      if %AmountToDrop < 200
      {
         ignoreitem #findid GP
         break
      }
      exevent drag #findid %AmountToDrop
      exevent dropg #charposx #charposy #charposz
      wait 11
      if #hits < %HitsBeforeLoot
      {
            set %HitsLessThanBeforeLoot #true
            break
      }
      finditem POF C_ , %CorpseID
      if #findkind <> -1
      {
          if %charposx <> #charposx || %charposy <> #charposy
          {
             set %OpenCorpseAgain #true
             break
          }
      }
   }
}
if %OpenCorpseAgain
{
   set %lastcont xxx
   goto CorpseOpening
}
if %HitsLessThanBeforeLoot
{
      event exmsg #charid 0 38 stopped looting HP
      set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
      return #false
}
if #systime >= %TimeendLoot
{
         event exmsg #charid 0 38 loot timeout
         return
}
LootFinished:

ignoreitem %CorpseID
event exmsg #charid 0 75 LOOTED
gosub CorpseRightsArrayAdd %CorpseID
if %usedpathfinddtoloot = #false
{
       finditem YFM G_ , 15
       if #findkind <> -1
       {
          if #systime > %NextAvailableCorpsesToLootReport
          {
             for #findindex 1 #findcnt
             {
                 if #findindex = 10
                 {
                    event exmsg #findid 0 0 too many loot
                    break
                 }
                 event exmsg #findid 0 0 loot
             }
          }
       }
       set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
       return #false
}
set %NextAvailableCorpsesToLootReport #systime + %AvailableCorpsesToLootReportDelay
return

;gosub Restock #findid #findtype %findstack %RestockTypeIDQ
sub Restock
    set %ID %1
    set %Type %2
    set %Stack %3
    set %RestockQ %4

    ;pause
    set %InPackQ 0
    finditem %Type C_ , #backpackid
    if #findkind <> -1
    {
       for #findindex 1 #findcnt
       {
           set %InPackQ %InPackQ + #findstack
       }
    }
    set %NeedToTake %RestockQ - %InPackQ

    if %NeedToTake <= 0
    {
       ignoreitem %ID Restock
       return
    }
    else
    {
        if %NeedToTake < %Stack
           ignoreitem %ID Restock
        else
        {
            if %NeedToTake > %Stack
               set %NeedToTake %Stack
        }
    }
    
    exevent drag %ID %NeedToTake
    exevent dropc #backpackid
    wait 10
    
return


sub CorpseRightsArrayAdd
    if %CorpseRightsArrayInited = #false
    {
       set %CorpseRightsArrayFirst 1
       set %CorpseRightsArrayLast 0
       set %CorpseRightsArrayInited #true
    }
    set %CorpseRightsArrayLast %CorpseRightsArrayLast + 1
    set %CorpseRightsArrayId . %CorpseRightsArrayLast %1
    set %CorpseRightsArrayT . %CorpseRightsArrayLast #systime + %lootExpireTime
return

sub CorpseRightsArrayCheck
    if %CorpseRightsArrayInited = #false
    {
       set %nextCorpseRightsCheck #systime + %lootExpireTime
       return
    }

    if #systime >= %CorpseRightsArrayT . %CorpseRightsArrayFirst
    {
       ignoreitem %CorpseRightsArrayId . %CorpseRightsArrayFirst
       finditem %CorpseRightsArrayId . %CorpseRightsArrayFirst G
       if #findkind <> -1
       {
                    event exmsg #findid 0 0 LOOT
                    event exmsg #findid 0 0 LOOT
                    event exmsg #findid 0 0 LOOT
       }
       set %CorpseRightsArrayFirst %CorpseRightsArrayFirst + 1
       if %CorpseRightsArrayFirst > %CorpseRightsArrayLast
       {
          set %CorpseRightsArrayInited #false
          set %nextCorpseRightsCheck #systime + %lootExpireTime
          return
       }
    }
    set %nextCorpseRightsCheck %CorpseRightsArrayT . %CorpseRightsArrayFirst

return

sub AntiBloodOath
    if G notin #charstatus && %InOldOath = #false
    {
       set %NextBloodOathScan #systime + %BloodOathScanDelay
       return
    }
    Call ScanBuffBar
    set %oathed _CurseBloodOath_ in %BuffBarIconNames
    if %oathed
    {
       if G in #charstatus
       {
          if %InOldOath = #false && #systime > %EndTurningOffWar
          {
             set %InOldOath #true
             set %EndTurningOffWar #systime + 1000
             event macro 6 0
             if %followon
                gosub turnfollow oath
             event exmsg #charid 0 0 OATH
          }
          else
          {
              if #systime <= %EndTurningOffWar
                 event macro 6 0
          }
       }
    }
    else
    {
        if %InOldOath
        {
           set %InOldOath #false
           if G notin #charstatus
              event macro 6 0
        }
    }
    set %NextBloodOathScan #systime + %BloodOathScanDelay
return

sub BendageSelf
    if ( #systime < %nextbend ) && %LastBendTarget = self
       return #false
    if #hits = #maxhits && C notin #charstatus
       return #false
    if D in #charstatus
       return #false
    if H in #charstatus
       return #false
    if #systime < %finishSelfHealing
       return
    if C notin #charstatus
    {
       set %HP #maxhits - #hits
       if %HP < %BendageHP
          return #false
    }
    if #systime < %nextbend && %LastBendTarget = friend && #hits > %HpCrossHealPriority
       return #false
    if %UseBendages = #false
    {
       set %nextBend #systime + 999999999
       return #false
    }
    event macro 58 0
    goSub CountHealDelay self
    set %nextBend #systime + 300 + #result * 1000
    set %bendUsed400 #systime + 400
    set %CheckBend #true
    set %LastBendTarget self
    set %finishSelfHealing %nextBend
    set %bendstart #systime
return #true

Sub CountHealDelay
    if %1 = self
    {
       if #dex >= 140
          return 4
       if #dex >= 120
          return 5
       if #dex >= 100
          return 6
       if #dex >= 80
          return 7
       if #dex >= 60
          return 8
       if #dex >= 40
          return 9
       if #dex >= 20
          return 10
       else
          return 11
    }
    if %1 = friend
    {
       if #dex >= 120
          return 3
       if #dex >= 60
          return 4
       else
           return 5
    }
return

sub GatherGold
    if #systime < %NextTakeGold
       return
    finditem %LootPack
    if #findkind = -1
       gosub LootSetup
    finditem POF G_ , 2
    if #findkind = -1
       return
    if #weight >= %maxweight
       return
    set %cantakegold ( %maxweight - #weight ) * 50
    if #findstack < %cantakegold
       set %cantakegold #findstack
    exevent drag #findid %cantakegold
    wait 3
    exevent dropc #backpackid
    set %NextTakeGold #systime + 350
return

sub TurnChasing
    if #systime > %nextturnChase || %1 <> normal
    {
       set %nextturnChase #systime + 300
       if %ChaseOn
       {
          if %1 = normal
             event ExMsg #charid 0 33 OFF Chasing
          if %1 = NoMob
             event ExMsg #charid 0 33 OFF Chasing
          if %1 = Changed
             event ExMsg #charid 0 33 OFF Chasing
          ;if %1 = OffFollow
             ;event ExMsg #charid 0 33 OFF Chasing
          set %ChaseOn #false
          if %autofollow = #false && %followon
             gosub turnfollow NoMsg
       }
       Else
       {
           set %ChaseOn #true
           if %followon = #false
              gosub turnfollow NoMsg
           event ExMsg #charid 0 68 Chasing ON
       }
    }
return

sub Divine
    if #systime < %nextcast
       return
    if #mana >= %divinemanacost && %inparal = #false
    {
       if %1 = Auto
       {
          finditem #enemyid , _ , %HonorMobs G
          if #findkind = -1
          {
             if %DivineOn
                gosub TurnAutoDivine NoMob
             if %ConcentrateOn
                gosub TurnAutoConcentrate NoMob
             return
          }
          if G notin #charstatus
          {
             if %DivineOn
                gosub TurnAutoDivine WM
             return
          }
          event ExMsg #charID 0 20 Divine
       }
       event macro 15 205
       set %lastspell divine
       if %DivineOn
          set %divenend #systime + %divinems - ( %divinecastdelay - %waittime - %chivadelay ) - 1000
       else
           set %divenend #systime + %divinems - %informtime
       set %divineinformed #false
       set %CheckDIvine #true
       set %DivineCasted400 #systime + 400
       set %nextcast #systime + %divinecastdelay
    }
return

sub Concentrate
    if #systime < %nextcast
       return
    if #mana >= %concmanacost && %inparal = #false
    {
       event macro 15 203
       set %lastspell concentrate
       if %ConcentrateOn
          set %concend #systime + %concms - ( %conccastdelay - %waittime - %chivadelay ) - 1000
       else
           set %concend #systime + %concms - %informtime
       set %concinformed #false
       set %checkConc #true
       set %Conccasted400 #systime + 400
       set %nextcast #systime + %conccastdelay
    }
return

sub AutoConcentrare
          if G notin #charstatus && %1 <> Instant
          {
               if %DivineOn
                  gosub TurnAutoDivine NoMob
               gosub TurnAutoConcentrate NoMob
               set %concinformed #true
          }
          if #systime >= %nextcast && #mana >= %concmanacost && %inparal = #false && ( G in #charstatus || %1 = Instant )
          {
             finditem #enemyid , _ , %HonorMobs , _ , %rev G
             if #findkind <> -1 || %1 = Instant
             {
                event macro 15 203
                set %lastspell concentrate
                set %concend #systime + %concms - ( %conccastdelay - %waittime - %chivadelay ) - 1000
                set %concinformed #false
                set %nextcast #systime + %conccastdelay
                set %checkConc #true
                set %Conccasted400 #systime + 400
             }
             else
             {
                    if %DivineOn
                       gosub TurnAutoDivine NoMob
                    gosub TurnAutoConcentrate NoMob
                    set %concinformed #true
             }
          }
return

sub TurnAutoDivine
    if #systime > %nextturnAutoDivine || %1 <> normal
    {
       set %nextturnAutoDivine #systime + 300
       if %DivineOn
       {
          if %1 = normal
             event ExMsg #charid 0 33 OFF Divne
          if %1 = loot
             set %divineinformed #true
          if %1 = WM
             set %divineinformed #true
          if %1 = NoMob
          {
             event ExMsg #charid 0 33 OFF Divine
             set %divineinformed #true
          }
          set %DivineOn #false
       }
       Else
       {
           set %DivineOn #true
           event ExMsg #charid 0 68 Divine ON
           if %Divineinformed
           {
              set %Divineinformed #false
              goSub Divine Instant
           }
       }
    }
return

sub TurnAutoConcentrate
    if #systime > %nextturnAutoConcentrate || %1 <> normal
    {
       set %nextturnAutoConcentrate #systime + 300
       if %ConcentrateOn
       {
          if %1 = normal
             event ExMsg #charid 0 33 OFF Concentrate
          if %1 = loot
             set %concinformed #true
          if %1 = WM
             set %concinformed #true
          if %1 = NoMob
          {
             event ExMsg #charid 0 33 OFF Concentrate
             set %concinformed #true
          }
          set %ConcentrateOn #false
       }
       else
       {
           set %ConcentrateOn #true
           event ExMsg #charid 0 68 Concentrate ON
           ;set %concinformed #false
           if %concinformed
           {
              set %concinformed #false
              gosub AutoConcentrare Instant
           }
       }
    }
return

sub TurnHonor
    if #systime > %nextturnhonor
    {
       set %nextturnhonor #systime + 300
       if %honoron
       {
          event ExMsg #charid 0 33 OFF honor
          set %honoron #false
       }
       else
       {
           event ExMsg #charid 0 68 honor ON
           set %honoron #true
           set %nextturnhonor #systime + 300
           set %NextHonorReport #systime + 8000
           if %followon
              gosub turnfollow honor
       }
    }
return

sub InstantReHonor
       finditem %HonoredMob G_ , 12
       if #findkind <> -1
       {
          event macro 49 1
          target 10
          set %ltargetid #ltargetid
          set %ltargetkind #ltargetkind
          set %HonorAgain #true
          while %HonorAgain
          {
             set #ltargetid %HonoredMob
             set #ltargetkind 1
             event macro 22 0
             set %HonorAgain #false
             if #targcurs = 1
                set %HonorAgain #true
          }
          set #ltargetid %ltargetid
          set #ltargetkind %ltargetkind
       }
return

sub Honor
;pause
    finditem %HonorMobs G_ , 12
    if #findkind <> -1
    {
       if #findtype = R && #findrep = 6 && #findcnt = 1
          return
       set %MobToHonor #findid
       if #findcnt > 1
       {
          set %MobToHonor #false
          set %MobToHonorDist 1000
          ;if #findtype = R && #findrep = 6
          ;{
          ;   set %MobToHonorDist 1000
          ;   set %MobToHonor #false
          ;}
          for #findindex #findcnt 1
          {
             if #finddist < %MobToHonorDist && ( #findtype <> R || #findrep <> 6 )
             {
                if #findid <> %HonoredMob || %HonoredSuccesfully
                {
                   set %MobToHonorDist #finddist
                   set %MobToHonor #findid
                }
             }
          }
          if %MobToHonor = #false
             return
       }
       set %ltargetid #ltargetid
       set %ltargetkind #ltargetkind
       if %TankMode && #systime > %nextsay
       {
                 event macro 2 0 identifying target
                 set %nextsay #systime + 3000
       }
       if %RTWMode && #systime > %nextsay
       {
                 event macro 2 0 reforming to strike
                 ;set %nextsay #systime + 3000
       }
       doublehonor:
       set %hpbeforehonore #hits
       set %poisonbeforehonot C in #charstatus
       set #ltargetid %MobToHonor
       set #ltargetkind 1
       event macro 49 1
       target 10
       if #targcurs <> 1 || #ltargetid <> %MobToHonor
          goto doublehonor
       set %HonorAgain #true
       while %HonorAgain
       {
             set #ltargetid %MobToHonor
             set #ltargetkind 1
             event macro 22 0
             set %HonorAgain #false
             if #targcurs = 1
                set %HonorAgain #true
       }
       if ( #hits <> %hpbeforehonore ) || ( %poisonbeforehonot <> ( C in #charstatus ) )
          goto doublehonor
       set #ltargetid %ltargetid
       set #ltargetkind %ltargetkind
       set %HonoredMob %MobToHonor
       ;pause
       set %HonoredSuccesfully #true
       set %HonorUsed3000 #systime + 3000
       set %HonorUsed7000 #systime + 7000
       ;event exMSG #charid 0 0 honored
       event exMSG %MobToHonor 0 43 HONORED
       set %honoron #false
       ;gosub OrgoniseLastAttackArray %MobToHonor
    }
    else
    {
        if #systime >= %NextHonorReport
        {
              event exMsg #charid 0 11 honoring
              set %NextHonorReport #systime + 20000
        }
    }
return

sub follow
    if %autofollow
    {
       if %followon
          gosub dognat forced
       else
           gosub turnfollow normal
    }
    else
        gosub dognat forced
return

sub dognat
    set %nextdognatcall #systime + 300
    if %1 = forced
       set %forcedFollow #true
    else
        set %forcedFollow #false
        
    if #LLIFTEDKIND = 1 && %forcedFollow <> #true
       return
        
    finditem #enemyid G
    if #findtype = NO && %followon ; shadow knight with crashin jump
    {
       if #enemyhits = n/a || ( #ENEMYHITS >= 50 && #ENEMYHITS <= 65 )
       {
          set %lastfollowid #enemyid
          set %pathT1000 #systime - 10
          gosub turnfollow TurnOff
          return
       }
    }
    if %TankMode && #finddist > 3 && #systime > %nextsay
              {
                 event macro 1 0 Tanks CHARGE !!!
                 set %nextsay #systime + 3000
              }

    if %RTWMode && #finddist > 3 && #systime > %nextsay
              {
                 event macro 1 0 CHARGE !!!
                 set %nextsay #systime + 3000
              }

    if #findkind <> -1 && G in #charstatus
    {
        if #enemyid <> %lastfollowid
        {
                    gosub attack #enemyid add
                    set %pathT1000 #systime
                    set %NextFollowReport #systime
                    set %lastfollowid #enemyid
                    set %pathT1000 #systime - 10
                    if %ChaseOn
                       gosub TurnChasing Changed
        }
        if #ENEMYID <> N/A
           set %lastfollowid #enemyid

        if #systime >= %NextFollowReport || #ENEMYHITS <> %lasthits
        {
           event exMSG #enemyid 0 26 #ENEMYHITS
           set %NextFollowReport #systime + 10000
           set %lasthits #ENEMYHITS
        }

        if #finddist > %followDist && ( %forcedFollow || #systime >= %pathT1000 || #findx <> %pathx || #findy <> %pathy || %CantGetThere )
        {
           if %CantGetThere = #false
           {
              if %ChaseOn = #false
              {
                 ;if #systime >= %pathT1000
                    gosub MoveToMod #findx #findy #findz %followDist
                 ;else
                 ;    event pathfind #findx #findy #findz
              }
              else
              {
                  if ( abs ( #findx - %pathx ) <= 1 ) && ( abs ( #findy - %pathy ) <= 1 )
                     gosub Chase2
                  else
                      Gosub Chase #findx #findy #findz %followDist
              }
           }
           else
           {
               event pathfind #findx #findy #findz
               set %CantGetThere #false
           }
           set %pathT1000 #systime + 1000
           if a notin #charstatus
           {
              set %pathx #findx
              set %pathy #findy
           }
        }
        else
        {
            if #systime >= %pathT1000 && %ChaseOn = #false && #finddist = 0
            {
                   gosub escape
                   set %pathT1000 #systime + 1000
            }
            else
            {
                if #finddist <= %followDist
                   set %pathT1000 #systime
            }
        }
    }
    else
    {
       if %autofollow
       {
             if g notin #charstatus
             {
                   gosub turnfollow WM
                   return
             }
             if ( %ImAfraidOfBloodOath = #false || %InOldOath = #false ) && g in #charstatus && #findkind = -1
                gosub searchTargetToAtack
             if #findkind = -1 && %ChaseOn
                gosub TurnChasing NoMob
       }
    }
return

sub escape
    set %CHARPOSmodX #CHARPOSx + %followDist
    Tile get %CHARPOSmodX #CHARPOSy #cursKind
    if Impassable notin #TILEFLAGS
         event pathfind %CHARPOSmodX #CHARPOSY #CHARPOSZ
    else
    {
        set %CHARPOSmodY #CHARPOSy - %followDist
        Tile get #CHARPOSX %CHARPOSmodY #cursKind
        if Impassable notin #TILEFLAGS
           event pathfind #CHARPOSX %CHARPOSmodY #CHARPOSZ
        else
        {
            set %CHARPOSmodY #CHARPOSy + %followDist
            Tile get #CHARPOSX %CHARPOSmodY #cursKind
            if Impassable notin #TILEFLAGS
               event pathfind #CHARPOSX %CHARPOSmodY #CHARPOSZ
            else
            {
                    set %CHARPOSmodX #CHARPOSx - %followDist
                    Tile get %CHARPOSmodX #CHARPOSy #cursKind
                    if Impassable notin #TILEFLAGS
                       event pathfind %CHARPOSmodX #CHARPOSY #CHARPOSZ
            }
        }
    }

return

sub Chase2
;            %pathx #findx %pathy #findy #findz %followDist
             set %dx #findx - %pathx
             set %dy #findy - %pathy
             set %nextmovex #findx + %dx * %followDist
             set %nextmovey #findy + %dy * %followDist
             Tile get %nextmovex %nextmovey #cursKind
             if Impassable notin #TILEFLAGS
                event pathfind %nextmovex %nextmovey #findz
             else
                 event pathfind #findx #findy #findz

return

sub Chase
    set %dx %1 - #charposx
    set %absdx ABS %dx
    set %dy %2 - #charposy
    set %absdy ABS %dy
    if %dx > 0
          set %xmod %4
    else
    {
        if %dx = 0
           set %xmod 0
        else
            set %xmod 0 - %4
    }
    if %absdx > %4
       set %nextmovex #findx + %xmod
    else
       set %nextmovex #findx ;+ %dx
    if %dy > 0
       set %ymod %4
    else
    {
        if %dy = 0
           set %ymod 0
        else
            set %ymod 0 - %4
    }
    if %absdy > %4
       set %nextmovey #findy + %ymod
    else
       set %nextmovey #findy ;+ %dy

    Tile get %nextmovex %nextmovey #cursKind
    if Impassable notin #TILEFLAGS
       event pathfind %nextmovex %nextmovey %3
    else
    {
        Tile get %1 %nextmovey #cursKind
        if Impassable notin #TILEFLAGS
           event pathfind %1 %nextmovey %3
        else
        {
            Tile get %nextmovex %2 #cursKind
            if Impassable notin #TILEFLAGS
               event pathfind %nextmovex %2 %3
            else
                event pathfind %1 %2 %3
        }
    }
return

sub MoveToMod
    set %dx #charposx - %1
    set %absdx ABS %dx
    set %dy #charposy - %2
    set %absdy ABS %dy
    if %dx > 0
          set %xmod %4
    else
    {
        if %dx = 0
           set %xmod 0
        else
            set %xmod 0 - %4
    }
    if %absdx > %4
       set %nextmovex #findx + %xmod
    else
       set %nextmovex #charposx
    if %dy > 0
       set %ymod %4
    else
    {
        if %dy = 0
           set %ymod 0
        else
            set %ymod 0 - %4
    }
    if %absdy > %4
       set %nextmovey #findy + %ymod
    else
       set %nextmovey #charposy

    Tile get %nextmovex %nextmovey #cursKind
    if Impassable notin #TILEFLAGS || #TILENAME = NoName
       event pathfind %nextmovex %nextmovey %3
    else
        event pathfind %1 %2 %3
return

sub KillingSpawn
    set %KillingSpawnStack1 %1
    event exmsg #charid 0 53 killing spawn...
    gosub AddAllPossibleTargetsToAttackArray
    if %KillingSpawnStack1 = hotkey
    {
       set %KillingSpawn #true
       gosub searchTargetToAtack
       if %followon = #false
          gosub turnfollow NoMsg
       set %nextKillingSpawnReport #systime + 20000
    }
return

sub AddAllPossibleTargetsToAttackArray
       if %needCantGetIgnoreReset
       {
              ignoreitem reset CantGetThere10
              set %needCantGetIgnoreReset #false
       }
    set %qadded 0
    finditem * G
    if #findkind <> -1
    {
       for #findindex 1 #findcnt
       {
        if #findrep = 0
           continue
          ; ;&&
        if #findrep in 3_4_5 && #findtype <> YFM && #findtype <> pof && #findid <> #charid && #findid <> %friend
        {
           if #findtype <> IS && #findtype <> XU && #findtype <> HS && #findtype <> AV && #findtype <> KS && #findtype <> LAB && #findtype <> MAB && #findtype <> PAB && #findtype <> QAB
           {
              ;event exmsg #findid 0 0 #findtype #findrep
              gosub OrgoniseLastAttackArray #findid
              if #result
                 set %qadded %qadded + 1
           }
        }
        if %qadded = 10
           break
       }
    }
    ;if %qadded <> 0
    ;   event macro 1 0 %qadded targets to attack
    if %qadded = 0 && %KillingSpawn
    {
       finditem #enemyid
       if #findkind = -1
       {
          set %KillingSpawn #false
          event exMsg #charid 0 75 THE SPAWN IS DEAD
       }
    }
return


sub DelLastAttackArray
    if %1 = n/a
       return
    set %LastAttackArrayEntryFound #false
    for %iAtArr 1 10
    {
        if %1 = %LastAttacked . %iAtArr
        {
           set %LastAttacked . %iAtArr deleted
           set %LastAttackArrayEntryFound #true
           break
        }
    }
    if %LastAttackArrayEntryFound
    {
       str Len %1
       set %entryLength #strRes
       str Pos %searchTargetToAtackString %1
       set %EntryPos #strRes
       if %EntryPos <> 0
       {
          str Del %searchTargetToAtackString %EntryPos %entryLength
          set %searchTargetToAtackString #strRes
       }
       if %killingspawn
          gosub BadIdForAttackAdd %1
    }
return

sub BadIdForAttackAdd
    set %BadIdForAttackN %BadIdForAttackN + 1
    set %BadIdForAttack . %BadIdForAttackN %1
return

sub BadIdForAttackDel
    if %BadIdForAttackN = 0
       return
    set %badToDeleteFound #false
    for %iBArr 1 %BadIdForAttackN
    {
           if %1 = %BadIdForAttack . %iBArr
           {
              set %badToDeleteFound #true
              set %badToDeleteI %iBArr
              break
           }

    }
    if %badToDeleteFound
    {
       if %BadIdForAttackN > %badToDeleteI
       {
          for %iBArr %badToDeleteI %BadIdForAttackN
          {
              set %iBArr1 %iBArr + 1
              set %BadIdForAttack . %iBArr %BadIdForAttack . %iBArr1
          }
       }
       set %BadIdForAttackN %BadIdForAttackN - 1
    }
return

sub OrgoniseLastAttackArray
    if %1 = n/a
       return #false
    set %return #false
    for %iAtArr 1 10
    {
        if %1 = %LastAttacked . %iAtArr
        {
           set %return #true
           break
        }
    }
    if %return
       return #false
    if %BadIdForAttackN > 0
    {
       for %iBArr 1 %BadIdForAttackN
       {
           if %1 = %BadIdForAttack . %iBArr
           {
              set %return #true
              break
           }
           
       }
       if %return
          return #false
    }
    set %searchTargetToAtackString _
    for %iAtArr 9 1
    {
        set %iAtArr1 %iAtArr + 1
        set %LastAttacked . %iAtArr1 %LastAttacked . %iAtArr
        set %workString %LastAttacked . %iAtArr1
        if %workString <> deleted
           set %searchTargetToAtackString %searchTargetToAtackString , %workString , _
    }
    set %LastAttacked1 %1
    set %searchTargetToAtackString %searchTargetToAtackString , %LastAttacked1 , _
return #true

sub attackloopbody
                          if G in #charstatus
                             set %inwarStatus #true
                          onhotkey %MoveKey
                          {
                                   if %followon && #systime > %nextturnfollow
                                      gosub turnfollow normal
                                   set %ExitAtackSub #true
                          }
                          if %inwarStatus && G notin #charstatus
                          {
                             if %followon
                                gosub turnfollow WM
                             set %ExitAtackSub #true
                          }
                          else
                          {
                              set #ltargetkind 1
                              set #ltargetid %MobToAttack
                              event macro 27 0
                              finditem %MobToAttack G
                          }
                          sleep 10
return

sub attack
                    if #systime < %ignoreWMfolowTurnOFF
                       set %ignoreWMfolowTurnOFF #systime - 10
                    set %MobToAttack %1
                    set %attackStack2 %2
                    gosub OrgoniseLastAttackArray #enemyid
                   ; set %intime #systime
                    set %ltargetid #ltargetid
                    set %ltargetkind #ltargetkind
                    set %inwarStatus G in #charstatus
                    set %ExitloopTIme #systime + 1500
                    set %ExitAtackSub #false
                    if g notin #charstatus && #systime >= %warmodeactivated500
                       event macro 6 0
                    gosub attackloopbody
                    while #systime < %ExitloopTIme && %ExitAtackSub = #false && ( %MobToAttack <> #enemyid || G notin #charstatus ) && #findkind <> -1
                    {
                          gosub attackloopbody
                    }
                    if #systime >= %ExitloopTIme
                    {
                       finditem %MobToAttack
                       gosub DelLastAttackArray %MobToAttack
                       return #FALSE
                    }
                    if %ExitAtackSub
                       return #FALSE
                    set #ltargetid %ltargetid
                    set #ltargetkind %ltargetkind
                    set %lastfollowid %MobToAttack
                    if %attackStack2 = add
                       gosub OrgoniseLastAttackArray %MobToAttack
                    ;set %outtime #systime - %intime
                    ;event macro 1 0 %outtime
return #true

sub turnfollow
    if #systime > %nextturnfollow || %1 <> normal
    {
       if %1 = TurnOff
       {
          event ExMsg #charid 0 33 OFF following
          set %followon #false
          set %killingspawn #false
          return
       }
       if %followon
       {
          if %1 = crithp
          {
             event ExMsg #charid 0 33 OFF following HP
             if %autoturnonhiding
                set %hidingon #true
          }
          if %1 = normal
          {
              ;event ExMsg #charid 0 33 OFF following
              return
          }
          if %1 = cross
              event ExMsg #charid 0 33 OFF following heal
          if %1 = WM
          {
             if #systime < %ignoreWMfolowTurnOFF
                return
             event ExMsg #charid 0 33 OFF following WM
             if %autoturnonhiding
                set %hidingon #true
             if %autohideifwaroff
                gosub hide
             set %nextautohideifstanding #systime - 10
             set %instantHiding15000 #systime + 15000
          }
          if %1 = rev
             event ExMsg #charid 0 33 OFF following
          ;if %1 <> crithp && %1 <> normal && %1 <> cross && %1 <> WM && %1 <> rev
             ;event ExMsg #charid 0 33 OFF following %1
          set %followon #false
          if %ChaseOn
             gosub TurnChasing OffFollow
          ;set %lastfollowid #false
          if %1 = normal
             set %nextturnfollow #systime + 400
          set %killingspawn #false
          return
       }
       else
       {
           set %followon #true
           if %1 <> NoMsg
              event ExMsg #charid 0 68 following ON
           if %1 = normal && g notin #charstatus
           {
              event macro 6 0
              set %ignoreWMfolowTurnOFF #systime + 600
              set %warmodeactivated500 #systime + 500
           }
           set %nextturnfollow #systime + 300
           gosub searchTargetToAtack
       }
    }
return

sub searchTargetToAtack
           finditem #enemyid G
           if #findkind = -1
           {
              if %followon
              {
                 finditem %HonoredMob G
                 if #findkind <> -1 && #findrep <> 1
                 {
                    gosub MoveToMod #findx #findy #findz %followDist
                    gosub attack %HonoredMob no
                 }
                 else
                 {
                     finditem %lastfollowid G
                     if #findkind <> -1
                     {
                        gosub MoveToMod #findx #findy #findz %followDist
                        gosub attack %lastfollowid add
                     }
                     else
                     {
                         ;pause
                         set %lastEnemyTypeFound #false
                         if %KillingSpawn
                         {
                            finditem %lastEnemyType G_ , 10
                            if #findkind <> -1
                               set %lastEnemyTypeFound #true
                         }
                         if %lastEnemyTypeFound = #false
                            finditem %searchTargetToAtackString G
                         if #findkind <> -1
                         {
                            set %FoundToAttackId #findid
                            set %FoundToAttackDist #finddist
                            if #findrep = 1
                                      ignoreitem #findid
                            if #findcnt > 1
                            {
                               for #findindex 2 #findcnt
                               {
                                   if #finddist < %FoundToAttackDist
                                   {
                                      set %FoundToAttackId #findid
                                      set %FoundToAttackDist #finddist
                                   }
                                   if #findrep = 1
                                      ignoreitem #findid
                               }
                               finditem %FoundToAttackId G
                            }
                            gosub MoveToMod #findx #findy #findz %followDist
                            if #finddist > 10
                            {
                               set %StopWaitingComeToHonorT #systime + 500
                               while #finddist > 10 && #systime < %StopWaitingComeToHonorT && #findkind <> -1
                               {
                                     wait 1
                                     finditem %FoundToAttackId
                               }
                            
                            }
                            if #findkind <> -1
                            {
                               event macro 49 1
                               target 12
                               set #ltargetkind 1
                               set #ltargetid %FoundToAttackId
                               event macro 22 0
                               gosub attack %FoundToAttackId no
                            }
                         }
                         else
                         {
                             if %killingspawn
                                gosub AddAllPossibleTargetsToAttackArray
                         }
                     }
                 }
              }
           }
           else
           {
               if %followon
               {
                      gosub MoveToMod #findx #findy #findz %followDist
                      gosub attack #enemyid add
               }
           }
return

sub killrevenant

    finditem IS G
    if #findkind <> -1
    {
       set %rev #false
       set %revdist 100
       for #findindex 1 #findcnt
       {
           if #findrep = 6 && #finddist < %revdist
           {
              set %revdist #finddist
              set %rev #findid
           }
       }
       if %rev <> #false
       {
          event macro 1 0 -Macro KillRevenant
          set %nextrefresh #systime + 3000
          gosub attack %rev no
          if #result = #false
             return
          set %KillingRevenant #true
          if %DivineOn
             gosub TurnAutoDivine rev
          if %followon
             gosub turnfollow rev
          ;event macro 1 0 -Macro KillRevenant
          if #systime <= %EndTurningOffWar
             set %EndTurningOffWar #systime - 10
          set %nextrefresh #systime + 2500
          set %nextcast #systime + 1200
       }
    }

return

sub extremal
            if H in #charstatus || A in #charstatus
               return

            if #hits < %cursehp && %KillingRevenant = #false && %usecurseweapon
            {
               gosub curseweap 1
               if #result
               {
                  ;if g in #charstatus
                  ;   gosub dognat forced
                  ;if %FCR > 2
                  ;   set %nextcast #systime + 1100
                  return
               }
            }

            if #hits < %crithp && %autoturnonhiding && #systime < %nextcast
               set %hidingon #true

            ;if #systime < %nextcast && #hits < %crithp && #systime >= %nexthide && #systime >= %confcasted250
            ;   gosub hide

            if #hits < %crithp && #systime >= %nextcast && H notin #charstatus && ( #FR > %FR || #mana < %remmanacost )
            {
               if %autoconfidence && %KillingRevenant = #false && ( C notin #charstatus || %autocure = #false ) && #systime >= %nextconf && #mana >= %confmanacost && #systime >= %nextcast && A notin #charstatus
               {
                  set %obsuinsteadofconf #false
                  if %autoclosewounds && C notin #charstatus && D notin #charstatus && #mana >= %healmanacost
                  {
                     finditem #enemyid G_ , 1
                     if #findkind <> -1
                     {
                        gosub obsuvulni self
                        set %obsuinsteadofconf #true
                     }
                  }
                  if %obsuinsteadofconf = #false
                  {
                     event macro 15 146
                     set %lastspell confidence
                     set %confcasted250 #systime + 250
                     set %confcasted1000 #systime + %confcasttime + 500
                     set %nextrefresh #systime + 1000
                     set %checkconf #true
                     set %nextconf #systime + 5000
                     set %nextcast #systime + %waittime + %confcasttime
                  }
               }
               else
               {
                   IF %autoclosewounds && C notin #charstatus && D notin #charstatus && #mana >= %healmanacost && #systime >= %nextcast && A notin #charstatus
                      gosub obsuvulni self
               }
               if #systime >= %nextcast && %UseBendages && %autoclosewounds && ( c in #charstatus || d in #charstatus )
               {
                  set %disttomob 20
                  set %needremovecast #false
                  if g in #charstatus
                  {
                     finditem #ENEMYID g
                     if #findkind <> -1
                        set %disttomob #finddist
                  }
                  if ( ( %disttomob <= 2 && #systime < %nextcurse ) || %usecurseweapon = #false  ) || ( ( %disttomob > 2 && #systime < %nextconf ) || %autoconfidence = #false )
                     set %needremovecast #true
                  if %needremovecast && d in #charstatus
                  {
                        gosub remcurs self
                        set %needremovecast #false
                  }
                  if %needremovecast && c in #charstatus && %InstantCurseWeapon = #false && %autocure = #false
                     gosub cleansebyfire self
               }
            }
            if %autohideiflowhp && #systime >= %nexthide && #systime >= %confcasted250 && %KillingRevenant = #false && g notin #charstatus
               gosub hide
return

sub hide
            set %nextautohideifstanding #systime + 500
            if #systime < %nexthide
               return
            if h notin #charstatus && A notin #charstatus
            {
               finditem #enemyid G_ , 1
               if #findkind = -1
               {
                  event macro 13 21
                  ;finditem #enemyid
                  ;event exmsg #charid 0 56 #finddist
                  set %nexthide #systime + 1000
                  set %hideUsed5000 #systime + 5000
               }
               else
                   set %nexthide #systime + 200
            }
return

sub turnhiding
    if #systime > %nextturnhiding
    {
       set %nextturnhiding #systime + 300
       if %hidingon
       {
          event ExMsg #charid 0 33 OFF hiding
          set %hidingon #false
       }
       else
       {
           event ExMsg #charid 0 68 hiding ON
           set %hidingon #true
           set %nexthidingreport #systime + 7000
       }
    }
return

sub TurnAutoCrossheal
;pause
    if #systime > %nextturnAutoCrossheal || %1 <> normal
    {
       set %nextturnAutoCrossheal #systime + 300
       if %CrosshealOn
       {
          ;if %1 = normal
             event ExMsg #charid 0 33 OFF crossHeal
          set %CrosshealOn #false
       }
       Else
       {
           if %UseBendages
           {
              set %CrosshealOn #true
              if %1 <> auto
                 event ExMsg #charid 0 68 crossHeal ON
           }
       }
    }
return

sub AutoCrossheal
    if #systime < %nextbend
    {
       if %nextXhealReport > 0 && #SCNT >= %nextXhealT
       {
          event exmsg %friend 0 0 %nextXhealReport
          set %nextXhealReport %nextXhealReport - ( #SCNT - %nextXhealT + 1 )
       }
       if %LastBendTarget = friend
          return
       if %LastBendTarget = self && #hits <= %HpCrossHealPriority
          return
    }
    finditem %friend G
    if #findkind = -1
    {
       set %HealingGhost #false
       if %CrosshealOn && %UseBendages
          gosub TurnAutoCrossheal auto
       return
    }
    else
    {
        if #finddist > 2
        {
           if #systime >= %nextcrosshealIDreport
           {
              set %nextcrosshealIDreport #systime + 5000
              event exmsg %friend 0 0 heal
           }
           set %HealingGhost #false
           return
        }
    }
    if %StupidTargetSystem = #false
    {
       set %TexitLoop #systime + 500
       set #ltargetid xxxx
       while %StupidTargetSystem = #false && #systime < %TexitLoop
       {
          event macro 50 5
          wait 1
          if #ltargetid = %Friend
          {
             set %StupidTargetSystem #true
             break
          }
       }
    }
    if %StupidTargetSystem
    {
       event macro 59 0
          set %FrBendUsed400 #systime + 400
          set %LastBendTarget friend
          set %HealJournalread #false
          set %bendstart #systime
       if #findtype <> KS && #findtype <> KV && #findtype <> ZU
       {
          goSub CountHealDelay friend
          set %nextBend #systime + 300 + #result * 1000
          set %HealingGhost #false
       }
       else
       {
           set %HealingGhost #true
           set %nextBend #systime + 10000
       }
    }
return

sub SetHealFriend
    set #targcurs 1
    while #targcurs = 1
    {
          wait 1
    }
    set %Friend #ltargetid
    set *WarriorAsistFriendID %Friend
    event ExMsg %Friend 0 0 HEAL
    if %UseBendages
    {
       set %StupidTargetSystem #false
       set %TexitLoop #systime + 2000
       set #ltargetid xxxx
    }
    while %StupidTargetSystem = #false && #systime < %TexitLoop && %UseBendages = #true
    {
          event macro 50 5
          wait 1
          if #ltargetid = %Friend
          {
             set %StupidTargetSystem #true
             break
          }
    }
return


sub CureFriend
    set %NeedBend #false
    set %NeedCleanse #false
    if #systime >= %nextcast && #mana >= %healmanacost && ( %lastspell <> cure || #targcurs <> 1 )
       set %NeedCleanse #true
    if ( #systime >= %nextbend || ( %LastBendTarget <> friend && #hits > %HpCrossHealPriority ) ) && %UseBendages
       set %NeedBend #true

    finditem %Friend G
    if #findkind <> -1
    {
          if #finddist > 8
          {
             if %followon
                gosub turnfollow cross
          }
          if ( #finddist > 9 || %NeedCleanse = #false ) && %StupidTargetSystem = #false && %UseBendages
          {
             set %StupidTargetSystem #true
             set #LTARGETID XXXXXXX
             event macro 52 5
             wait 1
             if #ltargetid <> %friend
                set %StupidTargetSystem #false

             set %TexitLoop #systime + 500
             set #ltargetid xxxx
             while %StupidTargetSystem = #false && #systime < %TexitLoop
             {
                   event macro 50 5
                   wait 1
                   if #ltargetid = %Friend
                   {
                      set %StupidTargetSystem #true
                      break
                   }
             }
          }
          finditem %Friend G
          if #finddist <= 9
          {
             if #targcurs = 1 && %lastspell = cure
             {
                    gosub SafeTargID %friend 9
                    if #result
                    {
                       set %NeedCleanse #false
                       event exmsg %friend 0 0 cured
                    }
             }
          }
          else
              event exmsg #charid 0 0 fare cure

          if #finddist <= 2 && #systime >= %nextbend && %UseBendages
             set %NeedBend #true
    }
    else
        set %NeedBend #false

    if %NeedBend && %StupidTargetSystem
    {
       event macro 59 0
       set %FrBendUsed400 #systime + 400
       goSub CountHealDelay friend
       ;set %nextXhealReport #result - 1
       ;set %nextXhealT #SCNT + 1
       set %nextBend #systime + 300 + #result * 1000
       set %LastBendTarget friend
       set %bendstart #systime
    }

    if %NeedCleanse
    {
       gosub cleansebyfire %friend
       if #result
          event exmsg %friend 0 0 cured
    }

    if %CrosshealOn = #false && %UseBendages
          gosub TurnAutoCrossheal auto
return

sub HealFriend
    set %NeedBend #false
    set %NeedObsu #false
    if #systime >= %nextcast && #mana >= %healmanacost && ( %lastspell <> heal || #targcurs <> 1 )
       set %NeedObsu #true
    if ( #systime >= %nextbend || ( %LastBendTarget <> friend && #hits > %HpCrossHealPriority ) ) && %UseBendages
       set %NeedBend #true

    finditem %Friend G
    if #findkind <> -1
    {
          if #finddist > 2
          {
             set %NeedBend #false
             set %NeedObsu #false
             event exmsg %friend 0 0 far heal
             if %followon
                gosub turnfollow cross
             event pathfind #findx #findy #findz
          }
          if %StupidTargetSystem = #false && %UseBendages
          {
             set %StupidTargetSystem #true
             set #LTARGETID XXXXXXX
             event macro 52 5
             wait 1
             if #ltargetid <> %friend
                set %StupidTargetSystem #false

             set %TexitLoop #systime + 500
             set #ltargetid xxxx
             while %StupidTargetSystem = #false && #systime < %TexitLoop
             {
                   event macro 50 5
                   wait 1
                   if #ltargetid = %Friend
                   {
                      set %StupidTargetSystem #true
                      break
                   }
             }
          }
          finditem %Friend G
          if #finddist <= 2
          {
              if #targcurs = 1 && ( %lastspell = heal )
              {
                 if #finddist <= 1
                 {
                    gosub SafeTargID %friend 1
                    if #result
                       set %NeedObsu #false
                 }
              }
          }
    }
    else
        set %NeedBend #false

    if %NeedBend && %StupidTargetSystem
    {
       event macro 59 0
       set %FrBendUsed400 #systime + 400
       goSub CountHealDelay friend
       ;set %nextXhealReport #result - 1
       ;set %nextXhealT #SCNT + 1
       set %nextBend #systime + 300 + #result * 1000
       set %LastBendTarget friend
       set %bendstart #systime
    }
    
    if %NeedObsu
    {
       gosub obsuvulni %friend
    }
    if %CrosshealOn = #false && %UseBendages
          gosub TurnAutoCrossheal auto

return

sub movetofriend
    finditem %friend g
    if #findkind <> -1
    {
       if #finddist > 0
       {
          if %followon
             gosub turnfollow cross
          event pathfind #findx #findy #findz
       }
       if %CrosshealOn = #false && %UseBendages
          gosub TurnAutoCrossheal auto
    }

return

sub chivaheal
   if #systime < %nextcast || A in #charstatus
      return
   ;if #hits < %informhp
   ;{
   ;   gosub curseweap 3
   ;   if #result
   ;      return
   ;}
   if #mana >= %healmanacost
   {
      if C in #charstatus
         gosub cleansebyfire self
      else
      {
          if d in #charstatus
             gosub remcurs self
          else
              gosub obsuvulni self
      }
   }
return

sub curseweap

      if #systime >= %nextcurse && #systime >= %nextcast && #mana >= %cursemanacost && A notin #charstatus && G in #charstatus
      {
                  if %usecurseweapon = #false
                  {
                     set %nextcurse #systime + 9999999
                     return
                  }
               finditem YZF C_ , #backpackid
               if #findkind <> -1
               {
                   if %1 <> instant
                      finditem #enemyid G_ , %1
                   if #findkind <> -1 || %1 = instant
                   {
                      event macro 15 104
                      set %lastspell curse
                      set %cursecasted400 #systime + 400
                      if %TankMode && #systime > %nextsay
                      {
                         event macro 1 0 Tanks repair Tracks !!!
                         set %nextsay #systime + 3000
                      }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
                      set %nextrefresh #systime + 4000
                      set %nextcurse #systime + %curseduration
                      set %nextcurse200 #systime + %curseduration + 200
                      set %checkcurse #true
                      set %nextcast #systime %cursecastdelay + 200
                      return #true
                   }
               }
      }
return #false


sub summonfury
    set %furydisturbed500 #systime + 500
   if #FOLLOWERS < 5 && #mana >= %furymanacost && #systime >= %nextcast && A notin #charstatus
   {
           set %param %1
           if %param = direction
           {
              gosub GetTargetForFuryDirection
              if #result = #false
                 return
           }
           ;set %furyreminder #true
           ;set %turnofffuryreminder #systime + 60000
           ;set %firstfuryremind #true
           ;set %nextremindfury #systime
           set %FuryCasted4000 #systime + 4000
           set %jindex2 #jindex + 1
           if #targcurs = 1
           {
              gosub targetground
              key esc
           }
           event macro 15 606
           set %lastspell fury
           set %finishingreading #systime + %furycasttime + 1350
           set %waitforfurycursor 0 ;#systime - 300 + %furycasttime
           set %finishwaitforfury #systime + 500
           set #ltargetkind 2
           if %TankMode && #systime > %nextsay
           {
                 event macro 1 0 Tanks Paradrop !!!
                 set %nextsay #systime + 3000
           }
           if %RTWMode && #systime > %nextsay && #systime > %nextpilumsay
           {
                         event macro 1 0 pilum throw !!!
                         set %nextsay #systime + 3000
                         set %nextpilumsay #systime + 20000
           }
          set %furyread #false
          set %paralread #false
          set %realparalread #false
          set %furydisturbed500 0
          set %q 0
          while #systime < %finishingreading
          {
              set %nextjinedxend2 #jindex
              if %jindex2 <= %nextjinedxend2
              {
                  set %q %q + 1
                  for %ji2 %jindex2 %nextjinedxend2
                  {
                      scanjournal %ji2
                      if %charname , : , _Rauvvrae in #journal
                      {
                         set %furyread #true
                      }
                      if Insufficient_mana_for_this_spell in #journal
                      {
                         set %paralread #true
                         break
                      }
                      if ( You_cannot_move in #journal || disturbed IN #journal || recovered IN #journal || you_cannot_perfom_this_special in #journal ) && : notin #journal
                      {
                         set %paralread #true
                         if You_cannot_move in #journal
                            set %realparalread #true
                         break
                      }
                  }
                  set %jindex2 %nextjinedxend2 + 1
              }
              if ( #systime > %finishwaitforfury && %furyread = #false ) || %paralread
              {
                 set %furydisturbed500 #systime + 500
                 ;pause
                 break
              }
              if #systime > %finishwaitforfury
                 gosub TurnHotkeys

              if #targcurs = 1 && #systime >= %waitforfurycursor
                 break
          }
          if %paralread
          {
             if %followon && %realparalread = #false
             {
                finditem #enemyid G
                if #findkind <> -1 && #finddist > 1
                   gosub dognat
             }
             return
          }
              set %nextcast #systime + %waittime
              if %param = charpos
                 gosub targetground
              if %param = direction
                 gosub safeTargGround %lastGoodXtile %lastGoodYtile #charposz
              if %param = WestEast
                 GOSUB targetfuryWestEast
              set %nexttargcurs #systime + 500
              set %nexttargkind 2
              finditem #enemyid G
              if #findkind <> -1 && #finddist > 1
              {
                 if %followon
                    gosub dognat forced
                 else
                 {
                     if #systime >= %nextmsgmobisntclose
                     {
                        event exmsg #charid 0 30 mob isn't close
                        set %nextmsgmobisntclose #systime + 3000
                     }
                 }
              }
   }
return


sub targetground
    finditem #enemyid G_ , 9
    if #findkind <> -1 && ( #systime > %furyblocked || %furyblockedx <> #findx || %furyblockedy <> #findy )
        gosub safeTargGround #findx #findy #findz
    else
        gosub safeTargGround #charposx #charposy #charposz
return

sub targetfuryWestEast
    if %WestEastFuryDir = West
       set %WestEastFuryDir East
    else
        set %WestEastFuryDir West
        
    if %WestEastFuryDir = East
       set %x #charposx + 5
    else
        set %x #charposx - 5

    gosub safeTargGround %x #charposy #charposz
return

sub GetTargetForFuryDirection
    set %reverseDirection #false
    set %chardir #chardir
    set %d 7
    furyreverseDirection:
    set %y #charposy
    set %x #charposx
    if %reverseDirection
    {
       set %chardir %chardir + 4
       if %chardir > 7
          set %chardir %chardir - 8
    }
     if %chardir = 0 1 ;N
        set %y %y - %d
     if %chardir = 1 2 ;NE
        set %y %y - %d
        set %x %x + %d
     if %chardir = 2 1 ;E
        set %x %x + %d
     if %chardir = 3 2 ;SE
        set %x %x + %d
        set %y %y + %d
     if %chardir = 4 1 ;S
        set %y %y + %d
     if %chardir = 5 2 ;SW
        set %y %y + %d
        set %x %x - %d
     if %chardir = 6 1 ;W
        set %x %x - %d
     if %chardir = 7 2 ;WN
        set %x %x - %d
        set %y %y - %d

     if %x <> #charposx
        set %needXtileCheck #true
     else
         set %needXtileCheck #False
     if %y <> #charposy
        set %needYtileCheck #true
     else
         set %needYtileCheck #false

     if %needXtileCheck
     {
        if %x > #charposx
           set %xdmod 0 + 1
        else
            set %xdmod 0 - 1
     }
     if %needYtileCheck
     {
        if %y > #charposy
           set %ydmod 0 + 1
        else
            set %ydmod 0 - 1
     }

     set %TileIsPassable #true
     set %lastGoodXtile #false
     for %i 1 %d
     {
         if %needXtileCheck
            set %CheckXTile #charposx + ( %i * %xdmod )
         else
             set %CheckXTile #charposX

         if %needYtileCheck
            set %CheckYTile #charposY + ( %i * %ydmod )
         else
             set %CheckYTile #charposY
          ;pause
         Tile cnt %CheckXTile %CheckYTile #cursKind
         for %j 1 #TILECNT
         {
             Tile get %CheckXTile %CheckYTile %j #cursKind
             if marble in #TILENAME || ( Impassable in #TILEFLAGS && #TILENAME <> NoName )
             {
                set %TileIsPassable #false
                break
             }
         }
         if %TileIsPassable = #false
            break
         if %i > 2
         {
            set %lastGoodXtile %CheckXTile
            set %lastGoodYtile %CheckYTile
         }
     }
     if %TileIsPassable || %lastGoodXtile <> #false
        return #true
     else
     {
     ;pause
         if %reverseDirection = #false
         {
            set %reverseDirection #true
            goto furyreverseDirection
         }
         else
             return #false
     }

return #false

sub safeTargGround
    set %ltargetkind #ltargetkind
    set %LTARGETX #LTARGETX
    set %LTARGETy #LTARGETy
    set %LTARGETz #LTARGETz
    set %SafeTargetAgain #true
    set %SafeEndLoop #systime + 1000
    while %SafeTargetAgain && #systime < %SafeEndLoop
    {
        set #LTARGETX %1
        set #LTARGETy %2
        set #LTARGETz %3
        set #ltargetkind 2
        event macro 22 0
        set %SafeTargetAgain #false
        sleep 5
        if #targcurs = 1
           set %SafeTargetAgain #true
    }
    set #ltargetkind %ltargetkind
    set #LTARGETX %LTARGETX
    set #LTARGETy %LTARGETy
    set #LTARGETz %LTARGETz
return

sub safeTargself
    set %SafeTargetAgain #true
    set %SafeEndLoop #systime + 500
    while %SafeTargetAgain && #systime < %SafeEndLoop
    {
        event macro 23 0
        set %SafeTargetAgain #false
        sleep 5
        if #targcurs = 1
           set %SafeTargetAgain #true
    }
return

sub safeTargId
    finditem %1 G_ , %2
    if #findkind = -1
       return #false
    set %ltargetid #ltargetid
    set %ltargetkind #ltargetkind
    set #ltargetkind 1
    set #ltargetid %1
    set %SafeTargetAgain #true
    set %SafeEndLoop #systime + 500
    while %SafeTargetAgain && #systime < %SafeEndLoop
    {
        event macro 22 0
        set %SafeTargetAgain #false
        sleep 5
        if #targcurs = 1
           set %SafeTargetAgain #true
    }
    set #ltargetid %ltargetid
    set #ltargetkind %ltargetkind
return #true

sub remcurs
   set %param %1
   if A in #charstatus
      return

   if %param <> self
   {
      if #targcurs = 1 && %lastspell = remove
      {
         gosub safeTargId %param 9
         if #result
         {
            event exmsg %friend 0 0 removed
            set %RemFrindCasted500 #systime + 500
         }
         return
      }
      if #systime < %RemFrindCasted500
         return
   }

   if #systime < %nextcast
      return
    if H notin #charstatus && #mana >= %remmanacost
    {
           set %jindex2 #jindex + 1
           event macro 15 209
           set %lastspell remove
           if %TankMode && #systime > %nextsay
           {
                 event macro 1 0 Tanks repair Tracks !!!
                 set %nextsay #systime + 3000
           }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
           set %finishingreading #systime + 1400 + %remcasttime * 50
           set %waitforremovecursor #systime - 100 + %remcasttime * 50
           set %finishwaitforremove #systime + 700
           set #ltargetkind 1
          set %removeread #false
          set %paralread #false
          set %q 0
          while #systime < %finishingreading
          {
              set %nextjinedxend2 #jindex
              if %jindex2 <= %nextjinedxend2
              {
                  for %ji2 %jindex2 %nextjinedxend2
                  {
                      scanjournal %ji2
                      if %charname , : , _Extermo_Vomica in #journal
                      {
                         set %removeread #true
                         if %TankMode && #systime > %nextsay
                         {
                            event macro 1 0 Tanks repair Tracks !!!
                            set %nextsay #systime + 3000
                         }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
                      }
                      if You_must_have_at_least_20_Mana_to_use_this_ability. in #journal
                      {
                         set %paralread #true
                         break
                      }
                      if ( You_cannot_move in #journal || disturbed IN #journal || recovered IN #journal || you_cannot_perfom_this_special in #journal ) && : notin #journal
                      {
                         set %paralread #true
                         break
                      }
                    }
                  set %jindex2 %nextjinedxend2 + 1
              }
              if #systime > %finishwaitforremove
                 gosub TurnHotkeys
              if ( #systime > %finishwaitforremove && %removeread = #false ) || %paralread
                 break
              if #targcurs = 1 && #systime >= %waitforremovecursor
                 break
          }
          if %removeread = #false || %paralread
          {
             return
          }
           if %param = self
           {
              set %nextcast #systime + %waittime + %chivadelay
              gosub safeTargself
              set %nexttargcurs #systime + 500
              set %nexttargkind 1
           }
           else
           {
               set %nextcast #systime + %waittime + %chivadelay
               gosub safeTargId %param 9
               if #result
               {
                  event exmsg %friend 0 0 removed
               }
               else
               {
                   event exmsg #charid 0 0 far remove
               }
           }
    }
return

sub obsuvulni
   if #systime < %nextcast || A in #charstatus || ( %1 = self && ( #Hits = #maxhits || #mana < %healmanacost || D in #charstatus ) )
      return
    set %param %1
    if H notin #charstatus || %1 <> self
    {
           if #targcurs = 1 && %param = self && %lastspell = heal
           {
              gosub safeTargself
              key esc
           }
           set %jindex2 #jindex + 1
           event macro 15 202
           set %lastspell heal
           if %TankMode && #systime > %nextsay
           {
                 event macro 1 0 Tanks repair Tracks !!!
                 set %nextsay #systime + 3000
           }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
           set %finishingreading #systime + 1400 + %healcasttime * 50
           set %waitforobsucursor #systime - 100 + %healcasttime * 50
           set %finishwaitforobsu #systime + 700
           set %poisonedormortaled #false
           set #ltargetkind 1
          set %obsuread #false
          set %paralread #false
          set %q 0
          while #systime < %finishingreading
          {
              if %param = self && ( c in #charstatus || d in #charstatus )
                 set %poisonedormortaled #true
              set %nextjinedxend2 #jindex
              if %jindex2 <= %nextjinedxend2
              {
                  for %ji2 %jindex2 %nextjinedxend2
                  {
                      scanjournal %ji2
                      if %charname , : , _Obsu_Vulni in #journal
                      {
                         set %obsuread #true
                         if %TankMode && #systime > %nextsay
                         {
                            event macro 1 0 Tanks repair Tracks !!!
                            set %nextsay #systime + 3000
                         }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
                      }
                      if You_must_have_at_least_10_Mana_to_use_this_ability. in #journal
                      {
                         set %paralread #true
                         break
                      }
                      if ( You_cannot_move in #journal || disturbed IN #journal || recovered IN #journal || you_cannot_perfom_this_special in #journal  ) && : notin #journal
                      {
                         set %paralread #true
                         break
                      }
                  }
                  set %jindex2 %nextjinedxend2 + 1
              }
              if #systime > %finishwaitforobsu
                 gosub TurnHotkeys
              if %poisonedormortaled && c notin #charstatus && d notin #charstatus
                 set %poisonedormortaled #false
              if ( #systime > %finishwaitforobsu && %obsuread = #false ) || %paralread || ( %poisonedormortaled && a notin #charstatus )
                 break
              if #targcurs = 1 && #systime >= %waitforobsucursor
                 break
          }
          if %obsuread = #false || %paralread
          {
             return #false
          }
          if %param = self
          {
           if %poisonedormortaled = #false
           {
              set %nextcast #systime + %waittime + %chivadelay
              gosub safeTargself
           }
           set %nexttargcurs #systime + 500
           set %nexttargkind 1
          }
          else
          {
               set %nextcast #systime + %waittime + %chivadelay
               gosub safeTargId %param 2
               return #result
          }
    }
return #true

sub cleansebyfire
   if ( ( #systime < %nextcast || C notin #charstatus || H in #charstatus ) && %1 = self ) || #mana < %healmanacost || A in #charstatus
      return #false
   set %param %1
   if %param <> self
   {
      if #targcurs = 1 && %lastspell = cure
      {
         gosub safeTargId %param 9
         return
      }
      else
      {
          if #systime < %nextcast
                      return
      }

   }
           set %jindex2 #jindex + 1
           event macro 15 201
           set %lastspell cure
           if %TankMode && #systime > %nextsay
           {
                 event macro 1 0 Tanks repair Tracks !!!
                 set %nextsay #systime + 3000
           }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
           set %finishingreading #systime + 1400 + %curecasttime
           set %waitforcurecursor #systime - 100 + %curecasttime
           set %finishwaitforcure #systime + 700
           set #ltargetkind 1
          set %cureread #false
          set %paralread #false
          while #systime < %finishingreading
          {
              set %nextjinedxend2 #jindex
              if %jindex2 <= %nextjinedxend2
              {
                  for %ji2 %jindex2 %nextjinedxend2
                  {
                      scanjournal %ji2
                      if %charname , : , _Expor_Flamus in #journal
                      {
                         set %cureread #true
                         if %TankMode && #systime > %nextsay
                         {
                            event macro 1 0 Tanks repair Tracks !!!
                            set %nextsay #systime + 3000
                         }
                      if %RTWMode && #systime > %nextsay
                      {
                         event macro 1 0 chirurgeon !!!
                         set %nextsay #systime + 3000
                      }
                      }
                      if You_must_have_at_least_10_Mana_to_use_this_ability. in #journal
                      {
                         set %paralread #true
                         break
                      }
                      if ( You_cannot_move in #journal || disturbed IN #journal || recovered IN #journal  || you_cannot_perfom_this_special in #journal ) && : notin #journal
                      {
                         set %paralread #true
                         break
                      }
                  }
                  set %jindex2 %nextjinedxend2 + 1
              }
              if #systime > %finishwaitforcure
                 gosub TurnHotkeys
              if ( #systime > %finishwaitforcure && %cureread = #false ) || %paralread
                 break
              if #targcurs = 1 && #systime >= %waitforcurecursor
                 break
          }
          if %cureread = #false || %paralread
          {
             return #false
          }
           if %param = self
           {
              set %nextcast #systime + %waittime + %chivadelay
              gosub safeTargself
              set %nexttargcurs #systime + 500
              set %nexttargkind 1
           }
           else
           {
               set %nextcast #systime + %waittime + %chivadelay
               gosub safeTargId %param 9
               return #result
           }
return #true

sub drinkRefresh
    if ( #FR < %FR && #mana >= %remmanacost ) || A in #charstatus || #systime < %nextrefresh
       return
    if #hits < %crithp && #mana > %healmanacost
       return

    set %TSpellCasted #systime - ( %nextCast - %waittime )
    if %TSpellCasted > 600 && %TSpellCasted < ( %waittime + 100 )
          return
    if %lastspell = curse && %TSpellCasted < ( %waittime + 200 ) && #hits <> #maxhits
          return
    if %lastspell = confidence && %TSpellCasted < 600
          return
    if %lastspell = concentrate && %TSpellCasted < 400
          return


    if #systime >= %nextrefresh
    {

       finditem ZUF C_ , #backpackid
       if #findkind = -1
       {
          ;event exMsg #charid 0 0 no refresh found
          return
       }
       event macro 1 0 -macro drinkRefresh
       set %nextrefresh #systime + 10000
       set %nextcast #systime + 1500
       ;event macro 1 0 %TSpellCasted %lastspell
    }
return

sub eat
    finditem %food C_ , #backpackid
    if #findkind <> -1
    {
       set #findindex #findcnt
       set #LOBJECTID #findid
       event macro 17 0
       set %nextlunch #systime + 1200000
       set %hadfood #true
       set %foodjournalcheck #true
       set %foodused2000 #systime + 2000
    }
    else
    {
        if %hadfood
        {
           event exMsg #charid 0 32 NO FOOD
           set %nextlunch #systime + 30000
        }
        else
            set %nextlunch #systime + 600000
    }
return

sub UseTrap
    if #hits < %crithp
    {
       ;event exmsg #charid 0 0 few hit points #hits
       return
    }
    UseTrap:
    while A in #charstatus
    {
          sleep 10
    }
    finditem LKF C_ , #backpackid
    if #findkind <> -1
    {
       set %lobjectid #lobjectid
       set #lobjectid #findid
       event macro 17 0
       set #lobjectid %lobjectid
       set %trap #findid
       set %trapused #true
       set %dragtrap #systime + 600
    }
    else
    {
        ignoreitem reset trap
        finditem LKF C_ , #backpackid
        if #findkind <> -1
           goto UseTrap
        else
            event exMsg #charid 0 0 no traps left
    }
    set %autopouchuse #false
return

sub dragTrap
       while A in #charstatus
       {
             sleep 10
       }
       finditem ZJF C_ , #backpackid
       if #findkind <> -1
       {
          exevent drag %trap
          exevent dropc #findid
          wait 12
          finditem %trap C_ , #backpackid
          if #findkind = -1
          {
             ignoreitem %trap trap
             set %trapused #false
          }
       }
       else
       {
           ignoreitem %trap trap
           set %trapused #false
       }
       finditem LKF C_ , #backpackid
       if #findcnt < 6
          event exMsg #charid 0 0 #findcnt traps left
       set %dragtrap #systime + 600
return

sub LogOut
wait 5
set %maxLogoutWait #systime + 3000
set %LogOutOk #true
if #CONTNAME <> paperdoll_gump
   event macro 8 1
while %LogOutOk && #systime <= %maxLogoutWait
{
      while #CONTNAME <> paperdoll_gump && #systime <= %maxLogoutWait
      {
            sleep 10
      }
      set %xclick #CONTPOSX + 212
      set %yclick #CONTPOSy + 108
      click %xclick %yclick dmc
      set %LogOutOk #false
      wait 2
      if #CONTNAME = paperdoll_gump
         %LogOutOk #true
}
while ( #CONTNAME <> YesNo_gump || #CONTSIZE <> 178_108 ) && #systime <= %maxLogoutWait
{
      sleep 10
}
set %LogOutOk #true
while %LogOutOk && #systime <= %maxLogoutWait
{
      set %xclick #CONTPOSX + 116
      set %yclick #CONTPOSy + 84
      click %xclick %yclick dmc
      set %LogOutOk #false
      wait 2
      if #CONTNAME = YesNo_gump
         %LogOutOk #true
}
return


sub CheckName
    str len #charname
    set %strlen #strres
    set %charname #charname
    for %i 1 %strlen
    {
        str left %charname %i
        if #spc in #strres
        {
           str del %charname %i 1
           set %charname #strres
           str ins %charname _ %i
           set %charname #strres
        }
    }
return

sub sayatwill
    if %lastsayatwilli <> 8
    {
       finditem KS_KV_ZU G
       if #findcnt >= 2
       {
          event macro 1 0 ROCK n ROLL !!!
          set %lastsayatwilli 8
       }
    }
    sayatwillbegin:
    gosub takerandom 6
    ;event exmsg #charid 0 0 #result
    if #result = %lastsayatwilli
       goto sayatwillbegin
    set %sayatwilli #result
    if %sayatwilli = 1
       event macro 1 0 i m a tank
    if %sayatwilli = 2
    {
       if #enemyid = n/a
          event macro 1 0 ready to roll out
       else
           event macro 1 0 i m not afraid of this zerg
    }
    if %sayatwilli = 3
    {
       finditem FN G_ , 2
       if #findkind = -1
          goto sayatwillbegin
       event macro 1 0 this dog is a tank too. ha
    }
    if %sayatwilli = 4
       event macro 1 0 i m a siege tank
    if %sayatwilli = 5
    {
       finditem IS_HS_XU_AV_LAB_MAB_PAB_QAB G_ , 1
       if #findkind = -1 || #findrep = 6
          goto sayatwillbegin
       event macro 1 0 are u stronger than a tank?
    }
    if %sayatwilli = 6
       event macro 1 0 Da-da-da-dah-da, da-da-da-DAH-da
    set %nextsay #systime + 3000
    set %nextsayatwill #systime + 30000
    set %lastsayatwilli %sayatwilli

return

sub sayatwillRTW
    if %lastsayatwilli <> 8
    {
       finditem KS_KV_ZU G
       if #findcnt >= 3
       {
          event macro 1 0 legion took casualties. It's time for Triari...
          set %lastsayatwilli 8
       }
    }
    sayatwillbegin:
    gosub takerandom 7
    ;event exmsg #charid 0 0 #result
    if #result = %lastsayatwilli
       return
    set %sayatwilli #result
    if %sayatwilli = 1
       event macro 1 0 Rome should rule the world
    if %sayatwilli = 2
    {
       if #enemyid = n/a
          event macro 1 0 Carthage must be destroyed
       else
           event macro 1 0 i l put this gual's head on a pike
    }
    if %sayatwilli = 3
    {
       finditem FN G_ , 2
       if #findkind = -1
          return
       event macro 1 0 i like this war dog... is it a poodle?
    }
    if %sayatwilli = 4
       event macro 1 0 i hate carthaganians even more than gauls
    if %sayatwilli = 5
    {
       finditem IS_HS_XU_AV_LAB_MAB_PAB_QAB G_ , 2
       if #findkind = -1 || #findrep = 6
          return
       event macro 1 0 have a nice fight roman citizen
    }
    if %sayatwilli = 6
       event macro 1 0 i m a true roman
    if %sayatwilli = 7
       event macro 1 0 i hate gauls
    set %nextsay #systime + 3000
    set %nextsayatwill #systime + 50000
    set %lastsayatwilli %sayatwilli

return

sub takerandom
      set %del 1000 / %1
      set %result #random / %del + 1
      if %result > %1
         goto takerandomagain
return %result

sub RecieveTargetName
    set %person %1
    if %person = N/A
       return #spc
    set %returndelay #systime + 300
    personname:
    if #systime > %returndelay
       return #false
    event Property %person
    if revenant in #property || lich in #property
       return #false
    if $ notin #property
    {
       finditem %person
       if #findtype notin WO_XO_ZO_SO_NO_WO_YO_FN
          goto personname
    }
    str len #property
    if #strres < 2
    {
       goto personname
    }
    str Pos #property $ 1
    set %rab #strres - 1
    str left #property %rab
    set %rab [
    if %rab in #strres
    {
       set %rabstring #strres
       str Pos %rabstring %rab 1
       set %rab #strres - 2
       str left %rabstring %rab
    }
    set %rabstring #strres
    if lord in %rabstring
    {
       str len %rabstring
       set %rabint #strRes
       set %rabint %rabint - 5
       str right %rabstring %rabint
    }
return #strres

sub RateMenu
    menu clear
    menu window size 208 26
    menu Window Title Rate script now?
    menu window color black
    menu font bgcolor teal
    menu font color black
    menu font size 12
    menu button Rate 3 3 150 20 i want to rate it now
    menu button Later 155 4 50 20 later
    menu Show 421 270
    set #menubutton n/a
return

sub RateMenu2
    menu clear
    menu window size 400 63
    menu Window Title How to rate
    menu window color black
    menu font size 12
    menu font bgcolor black
    menu font color white
    menu text 1 3 5 To rate a script, u need to be registered easyuo.com user
    menu text 1 3 22 and have at least 1 post. Open script thread and find rate
    menu text 1 3 39 button in the left. Press it.
    set #menubutton n/a
return
