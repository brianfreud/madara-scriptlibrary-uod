;=========================================;
; Script Name: Algander's Leather Farmer
; Author: Algander
; Credits:        1.3 original mainloop by Indecent
;                 Zio's for his modified autolooter
;                 Scorna for his great subs
; Version: 3.1
; Shard OSI/FS: OSI? - FS
; Revision Date:
; Purpose: Kill, Skin with BWC, and bank via BOS optionally
;=========================================;
; Setup:
; - If you want to bank your leather start the script ,
;   have a runebook with your bank rune as the first rune in the book.
;=========================================;
;Funzioni sperimentali:
;setta tasto resync client
set %tasto F11
;controllare prima dell'avvio
set %smartrecovery 8 ;aumentare in caso di lag (Default: 8) *solo metodo magery
;per l'uso melee casta in automatico spell/abilità.
set %autocastEoO #false
set %ability_timeout 5 ;setta il tempo di recast per le abilità
set %consecrus_timeout 9
set %autoprimary #true
set %autosecondary #false
set %ignorepoison #true
set %autocons #false
set %autohonor #false
set %autoconfidence #false
set %EoOlist FE_AE_DF_CD_; UD_DE_FE_AE_ ;DF_CD_ dragons // Lista di mob su cui castare Enemy of 1
set %consList DF_CD_ ;Lista di mob su cui castare Consecrus

;User defined variables
;loot type section
set %bwc HFR ;trova la butcher direttamente da type
set %nonBWC VRH_TSF_CNF_WSF_GMH_ ;aggiungete in questa lista i type della lama che volete usare. (ES: VRH kryss WSF dagger CNF skinningknife)
set %frecce RWF
set %wool OFF
set %cutleather JJG
set %uncutleather DEG
set %feather VLK_
set %drgnscale STO
set %bones IJK_TJK_BJK_UJK_LJK_FJK_RJK_EJK_ZIK_YIK_JJK_GJK_KJK_HJK_OJK_XIK_SJK_DJK_MJK_AJK_OZF_
set %cutbones GUF_OZF_
;=========================================;
;mob type section
set %hidebearers GE_LD_JD_XE_YE_RG_EG_ZI_TG_AH_ZF_NG_IG_BG_VD_ZE_PG_WF_XD_KB_YF_FE_OH_SG_OF_MG_DG_SF_VF_ZD_M_L_YG_XG_DF_CD_DE_FE_AE_  ;GE_ umano runuo? DF_CD_ dragon DE_FE_AE lizardmen
set %bonebearers ZC_UGB_CF_WE_XI_  ;ZC_orc UGB_horde_minion CF_WE_skellies XI_shadow wisp
set %woodbearers VGB_  ; VGB_bogling GD_corpser (you will have to be on manual for these)
set %featherbearers WC_AG_UD_T_
set %sheep PF_FG_
set %enemy FD_DF_CD_RE_AF_BE_BI_UD_PE_QD_SD_DE_ND_FE_RE_YD_WE_CF_TI_VC_AI_NC_MD_TD_WGB_OD_ ;BE-mongbat TD_headless (XC is ogre but also house?) UD_harpy PE_troll QD_ettin WG_rat SD_spider DE_lizardmen ND 0rc
set %people HS_IS_NAB_OAB_QAB_PAB_MAB_RAB_SAB_LAB_ ;HS_IS humans other=necroforms
set %animals %enemy ;animals to attack
;=========================================;
; <Changelog>
; versione 3.1
; fixati i contatori, rimossa ridondanza dalla sub journal (poteva causare crash), ricerca prioritaria dei mob aggressivi (prima di cercare i mob da farmare uccide quelli pericolosi),
; miglioramenti e fix ai cast delle spell (compresi metodi di caccia magery), correzione al loot, corretto bug targeting melee, implementato uso delle bende, fixato un bug nel looting
; inserito cast di confidence, corretta calibratura del peso.
; versione 3.05b
; raffinati i check sui journal, funzioni di cast automatico per war, fix minori ai cicli recall, rimossi check ridondanti dal recall, sostituito drop delle risorse casa al vecchio metodo bag of sending
; check automatico della razza, check automatico per la butcher's war cleaver, riscritto drag & drop
; versione 3.04b
; cambiato il calcolo del ritorno alla runa di partenza, migliorata la pausa dei pathfind, nuovo menu stats con cronometro, fix generali.
; versione 3.03b
; rimosso lo stile caccia taming con pet, fix sulle nuove funzioni, implementato lo script di lettura journal, adesso non serve più il file scanforjournal della 1.6..
; versione 3.02b
; modifiche varie ai messaggi dello script, funzione di ritorno al punto di partenza
; (se il pg si allontana troppo da dove è arrivato cerca di tornare indietro, se non riesce recalla all'ultima runa usata)
; stile di caccia con pet non-mount (ancora da testare a fondo), diminuito il peso massimo quando non si usa la BWC
; VERSIONE 3.01b
; rimaneggiate tutte le variabili utilizzate, implementate statistiche e nuovo menu.
; funzione salvatamer/salvajail XD: i bull a Delucia adesso vengono ignorati, collegate alcune liste di loot (Pelli, penne, ossa e lana) all'attivazione delle relative liste mob.
; versione 2.3.1
; inserita scelta loot scaglie, soglia hp editabile da menu, check peso elfi da menu, possibilità di skinnare senza bwc, cool targeting (:look:)
; versione 2.3
; correzione all'anti-criminal, RISCRITTO completamente il recall e le funzioni che lo chiamano, check automatico per la skill di recall,
; eliminata variabile waitafterrecall, risolto il bug in cui lootava un corpo a caso dopo il recall.
; versione 2.2
; inserita la sub di cura nelle routine di combattimento, inserito check sui pet tamati, fix generici, aggiunti alcuni messaggi di verifica.
; versione 2.1
; migliorata notevolmente la sub di cura, cura anche da poison e distingue se usare heal o greater heal stile razor.
; VERSIONE 2.0 (versione più stabile testata)
; implementato stile di caccia magery semplice.
; Implementato il menu.
; correzioni, riordinamento dello script e aggiunta delle call scanjournal da parte dello zio.
; corretto il bug che talvolta faceva targettare il mob più lontano.
; rivista la parte del recall, il bug che fa recallare più volte sulla stessa
; runa nn sembra ancora completamente risolto ma ora è gestito meglio...
; 23/11/2008 - 1.6 - correzioni generali dello script da parte dello zio, risolto il "bug" in cui spesso veniva targettato il mob più lontano
; 9/11/2008 - 1.5 - corretto il recall, inserita sub antiblock, implementato modo di caccia magery!
; 29/09/2008 - 1.3.1b - automatizzata la ricerca del Butcher's war cleaver, non importa piu targettarlo a mano a inizio script.
;            31/09/2008 - 1.3.1 - ripulito il codice, aggiunti alcuni animali.
; 31/09/2008 - 1.4 - implementate/corrette le prime due voci della lista implementazioni =D
;            2/11/2008 corretto il looting, se un mob muore lontano il pg si avvicina. aggiunta una funzione automatica per tagliare le ossa
;============================================================;
;-+-+-+-+-<starting the script, DO NOT modify below!>-+-+-+-+-;
;vars initialization, changes may be significant at first start
Set %searchdistance 5 ; default 5 Set lower if pathfinding gets confused
set %dropbag ERROR!
set %bookid ERROR!
set %xcasa N/A
set %ycasa N/A
Set %numberofplaces 0
set %hitsctrl -15
set %storebank #true
set %lootaleather #true
set %lootafeather #true
set %lootaossa #false
set %lootalana #false
set %lootafrecce #true
set %lootaScales #false
set %pathback #true
set %autobandage #false
set %huntstyle 3
set %healmethod 1
set %nruneatt 1
set %ability_timer 0
set %cons_timer 0
set %bandtimer 0
set %sys_color 946
set %save_color 53
;==========================;
;colori risorse
;red 1645 green 2129 yellow 2216 black 1109 blue 2224 white 2301
set %redscale 1645
set %greenscale 2129
set %yellowscale 2216
set %blackscale 1109
set %bluescale 2224
set %whitescale 2301
set %normalleather 0
set %spinedleather 2220
set %hornedleather 2117
set %barbedleather 2129
;==========================;
;contatori
set %tot_normalleather 0
set %tot_spinedleather 0
set %tot_hornedleather 0
set %tot_barbedleather 0
set %tot_redscale 0
set %tot_greenscale 0
set %tot_yellowscale 0
set %tot_blackscale 0
set %tot_bluescale 0
set %tot_whitescale 0
set %tot_feather 0
set %tot_frecce 0
set %tot_ossa 0
set %tot_wool 0
;==========================;
gosub inizializza_variabili
recheck:
gosub menu_avvio
gosub finesetup
gosub Check_Skill_Recall
gosub menu_avviato
;==========================;
if ( %xcasa = N/A || %ycasa = N/A ) && %storebank = #false
   {
   display ok Qualche variabile non è impostata correttamente
           + $ perfavore ricontrolla le tue impostazioni.
   goto recheck
   }
if %storebank = #false
   {
   set %timeout #scnt + 8
   event pathfind %xcasa %ycasa
   while #charposx <> %xcasa || #charposy <> %ycasa
   {
   wait 2
   if #scnt > %timeout
      break
   }
   finditem %dropbag g_3
   if #findkind <> 1
        {
         display ok Non è possibile raggiungere il container per le risorse,
                 + $ perfavore ricontrolla le tue impostazioni.
         goto recheck
        }
   }
if %Bookid = ERROR! || %dropbag = ERROR! || %numberofplaces = 0 && %storebank = #true
   {
   display ok Qualche variabile non è impostata correttamente
           + $ perfavore ricontrolla le tue impostazioni.
   goto recheck
   }
set %timetstart #scnt
;#=#=#=#=#=#=#=#=#=#=#=#=#=#=# MAIN LOOP #=#=#=#=#=#=#=#=#=#=#=#=#=#=#
Loop:
if #HITS < %hitscheck || ( C in #CharStatus && ! %ignorepoison )
 gosub curati
wait 10
gosub cambiaspot

find:
gosub timecalc
gosub Edit_stato Ricerca , #spc , del , #spc , target
;check aggiuntivo per non avere "container cannot hold more.." quando non si usa la BWC su felucca ;)
if #Weight >= %WeightMax && #curskind <> 0  
   + || #curskind = 0 && %usabwc = #false && #Weight >= ( %WeightMax - 60 )
   + || #curskind = 0 && %usabwc = #true && #Weight >= ( %WeightMax - 40 )
   {
   gosub unload
   }
if %pathback
        {
        set %dix ( %startposx - #charposx ) ABS
        set %diy ( %startposy - #charposy ) ABS
        if %diy > %dix
           set %distanza %diy
        else
           set %distanza %dix
        if %distanza > %searchdistance * 4
           {
           gosub antiblock
           event ExMsg #charid 3 50 Meglio tornare indietro!
           event pathfind %startposx %startposy
           gosub ScanForJournalMsg Can't_get_there 1 10 5
           if #result = #TRUE
             {
             gosub recall
             if #result = #false
                gosub cambiaspot
             }
           set %waitTimeout #scnt2 + 50 ;5secondi di timeout
           while #charposx <> %startposx || #charposy <> %startposy
             {
             if #scnt2 > %waitTimeout
                 break
             }
           goto find
           }
        }
set %victim N/A ;reset
FindItem %enemy G_ , 11
if #findkind <> -1 && #findtype notin %animals && #findstack < 1
      {
      set %victim #findid
      event ExMsg %victim 3 1080 *-[Enemy found!]-*
      if %huntstyle = 1
               {
               if %autohonor = #true
                 {
                 event macro 49 1
                 target 1s
                 set #ltargetid %victim
                 event macro 22 0
                 }
               set #Ltargetid %victim
               set #LTARGETKIND 1
               event macro 27 0
               }
      goto killit
      }
for %distance 1 %searchdistance
      {
      set %_distance %distance * 4
      ;event ExMsg #charid 2 1074 Scanning @ range %_distance
      FindItem %animals G_ , %_distance
      if #findkind <> -1 && #findstack < 1
             {
             set %victim #findid
             break
             }
      }
      if #findrep in 1_2_7 && #findstack < 1 ;ignora eventuali pet tamati
             {
             ignoreItem %victim 1
             event ExMsg %victim 3 50 Target ignorato!
             goto find
             }
      if #findtype = YG || #findtype = XG && #findstack < 1
            {
            if #curskind < 2 && #charposx > 5120 && #charposx < 5210 && #charposy > 3880 && #charposy < 4000
                  {
                  ignoreItem %victim 1
                  event ExMsg %victim 3 50 Bull di Delucia ignorato!
                  goto find
                  }
            }
       event ExMsg %victim 3 1080 *-[Target aquired!]-*
if %victim = N/A
   {
   ignoreItem reset 1
   gosub cambiaspot
   goto find
   }
  if %huntstyle = 1
     {
     if %autohonor = #true
       {
       event macro 49 1
       target 1s
       set #ltargetid %victim
       event macro 22 0
       }
     set #Ltargetid %victim
     set #LTARGETKIND 1
     event macro 27 0
     }
  ;msg Killing %victim $
Killit:
gosub edit_stato Kill , #spc , del , #spc , target
if %huntstyle = 1  ;melee istance
   {
   Finditem %victim G_
   if #findkind = -1
      goto loot
   if #finddist > 1
         {
         event Pathfind #Findx #Findy #findz
         wait 10
         gosub ScanForJournalMsg Can't_get_there 1 10 0
         if #result = #TRUE
             {
             ignoreItem %victim 1
             event ExMsg %victim 3 50 Target ignorato!
             goto find
             }
         }
   set #Ltargetid %victim
   set #LTARGETKIND 1
   event macro 27 0
   if #hits < ( #maxhits - 5 ) && %bandtimer < #scnt2 && %autobandage
      {
      set %banddelay ( ( 11 - ( #dex / 20 ) ) * 10 )
      set %bandtimer #scnt2 + %banddelay
      event macro 58
      }
   if %autocastEoO = #true && #findrep <> 5 && #findtype in %eoolist && #mana >= 14
       {
     	 event macro 15 206
     	 wait 15
     	 goto recast
     	 }
   if %autocons = #true && #scnt > %cons_timer && #mana >= 9 && #finddist < 4
       {
     	 event macro 15 203
     	 set %cons_timer #scnt + %consecrus_timeout
     	 wait 15
     	 }
   if %autoprimary = #true && #scnt > %ability_timer && #mana >= 20
       {
     	 event macro 35 0
     	 set %ability_timer #scnt + %ability_timeout
     	 goto recast
       }
   if %autosecondary = #true && #scnt > %ability_timer && #mana >= 25
       {
       event macro 36 0
       set %ability_timer #scnt + %ability_timeout
     	 goto recast
       }
   if #scnt > %conf_timer && #hits <= ( #maxhits - 30 )
       {
       event macro 15 146
       set %conf_timer #scnt + 4
       wait 5
     	 goto recast
       }
   recast:
   if ( #hits < %hitscheck || ( C in #CharStatus && ! %ignorepoison ) ) && #mana > 14
       gosub curati
   }
if %huntstyle = 2 || %huntstyle = 3       ;magery istance
{
  set %firstspell #true
  Finditem %victim G_
   if #findkind = -1
      goto loot
   pathfind:
  while #findkind <> -1
        {
        Finditem %victim G_
        if #findkind = -1
           goto loot
         while #finddist > 9
             {
              gosub ScanForJournalMsg Can't_get_there 1 10 0
              if #result = #TRUE
                   {
                   event ExMsg %victim 3 50 Target ignorato!
                   ignoreItem %victim 1
                   goto find
                   }
              event Pathfind #Findx #Findy #findz
              wait 15
              finditem %victim
              }
        recast:
        if #hits < ( #maxhits - 5 ) && %bandtimer < #scnt2 && %autobandage
            {
            set %banddelay ( ( 11 - ( #dex / 20 ) ) * 10 )
            set %bandtimer #scnt2 + %banddelay
            event macro 58
            }
        set %timeout #scnt2 + 25
        Finditem %victim
        if #findkind = -1
           break
        if ! %firstspell
           wait %smartrecovery
        if #hits < %hitscheck || C in #CharStatus
           gosub curati
        if %firstspell && %painspike
           event macro 15 109
        else
            {
            if %huntstyle = 2
               {
               if #finddist < 6
                  {
                  if #findtype notin DG_VF_M_L && #finddist < 2 && #enemyhits > 10
                     event macro 15 11
                  else
                     event macro 15 4
                  }
                if #enemyhits < 35
                  event macro 15 11
                else
                  event macro 15 17
               }
            if %huntstyle = 3
               {
               if #finddist < 6
                  {
                  if #findtype notin DG_VF_M_L && #finddist < 2 && #enemyhits > 10
                     event macro 15 11
                  else
                     event macro 15 4
                  }
               else
                  event macro 15 29
               }
            }
        target
        if you_have_not_yet in #sysmsg && %smartrecovery < 25
               {
               if %smartrecovery > 21
                    set %smartrecovery 10
               set %smartrecovery %smartrecovery + 1
               goto recast
               }
        set #ltargetid #findid
        set %jinx #jindex
        event macro 22 0
        wait 5
        set %firstspell #false
;smartrecovery controlla che le spell non si accavallino Es: cast troppo veloce
;se a causa di di lag le spell si dilungano troppo si autolimita per non avere una pausa infinita
          for %jentry %jinx #jindex
                {
                scanjournal %jinx
                if Your_concentration in #journal
                     {
                     goto recast
           	         }
                if You_are_frozen in #journal
                     {
                     wait 10
           	         goto pathfind
                     }
                if Target_cannot_be_seen in #journal
                      {
                     ;goto pathfind
                     ignoreItem %victim 1
                     event ExMsg %victim 3 50 Target ignorato!
                     goto find
                     }
                 }
        }
}
goto Killit

loot:
;wait 10
gosub antiblock
gosub FindCorpse
if #result <> #false
   {
   gosub LootCorpse
   }
;wait 10
goto find
;================================================================
sub FindCorpse
;gosub antiblock
   Finditem YFM G_20
   if #FindCnt < 1 || #FindDist > 22
      return #false
   set %CorpseID #FindId
   set %CorpseType #FindType
   ignoreitem #findid
  return %CorpseId
;================================================================
sub LootCorpse
gosub edit_stato Looting...
apri:
set %waitTimeout #scnt2 + 60 ;6secondi di timeout
while #FindDist > 2
		{
		event pathfind #FindX #FindY #FindZ
	  if #scnt2 > %waitTimeout
	      goto saltaloot
 		gosub ScanForJournalMsg Can't_get_there 1 10 2
        if #result = #true
    goto saltaloot
    finditem %corpseid
    wait 10
		}
gosub antiblock
set #lobjectid %corpseid
event macro 17 0
gosub wait_loot
if #result = #false
   goto apri
if #result = ignora
        {
        event ExMsg %CorpseID 3 50 Carcassa ignorata!
        ignoreitem %corpseID 2
        goto saltaloot
        }
if #curskind = 0
    {
    gosub ScanForJournalMsg criminal_act! 2 10 5
       if #result = #TRUE
        {
        event ExMsg %CorpseID 3 50 Carcassa ignorata!
        ignoreitem %corpseID 2
        goto saltaloot
        }
    }
if %lootaleather
    {
    recut:
    wait 2
    set %jindex #jindex
    set #lobjectid %skin_blade
    event macro 17 0
    for %i %jindex #jindex
        {
        scanjournal %i
        if what_do_you_want_to_use in #journal
           break
        if You_must_wait_to_perform_another_action. in #journal 2
                   wait 1
                   goto recut
        }
    target 4s
    set #ltargetid %CorpseID
    set #lTargetKind 1
    set %jindex #jindex
    event macro 22 0
    for %i %jindex #jindex
          {
          scanjournal %i
          if target_cannot_be in #journal
              {
              finditem %corpseid G_
              move #findx #findy 1 1
              wait 5
              goto recut
              }
          }
    }

wait 8
_Looting:
scanjournal 1
if out_of_sight in #journal && : notin #journal
   {
   event ExMsg %CorpseID 3 50 Carcassa fuori portata!
   goto saltaloot
   }
if %lootaossa = #TRUE
   {
   finditem %bones , %cutbones C_ , %CorpseID
   if #findkind <> -1
      {
      exevent drag #findid #findstack
      wait 5
      exevent dropc #backpackid
      goto _Looting
      }
   }
if %lootalana = #TRUE
   {
   finditem %wool C_ , %CorpseID
   if #findkind <> -1
      {
      exevent drag #findid #findstack
      wait 5
      exevent dropc #backpackid
      wait 8
      goto _Looting
      }
   }
if %lootafeather = #TRUE
   {
   finditem %feather C_ , %CorpseID
   if #findkind <> -1
      {
      exevent drag #findid #findstack
      wait 5
      exevent dropc #backpackid
      wait 8
      goto _Looting
      }
   }
if %lootaleather = #TRUE
   {
   if %usaBWC = #TRUE
         {
         finditem %cutleather C_ , %CorpseID
         if #findkind <> -1
            {
            exevent drag #findid #findstack
            wait 5
            exevent dropc #backpackid
            wait 8
            goto _Looting
            }
         }
   else
         finditem %uncutleather C_ , %CorpseID
         if #findkind <> -1
          {
            exevent drag #findid #findstack
            wait 5
            exevent dropc #backpackid
            wait 8
            finditem %uncutleather C_ , #backpackid
            if #findkind = -1
               goto _looting
            set %cutIt #findid
            gosub tagliuzza %cutIt
            goto _Looting
          }
if %lootafrecce = #TRUE
   {
   finditem %frecce C_ , %CorpseID
   if #findkind <> -1
      {
      exevent drag #findid #findstack
      wait 5
      exevent dropc #backpackid
      wait 8
      goto _Looting
      }
   }
if %lootascales = #TRUE
   {
   finditem %drgnscale C_ , %CorpseID
   if #findkind <> -1
      {
      exevent drag #findid #findstack
      wait 5
      exevent dropc #backpackid
      wait 8
      goto _Looting
      }
   }
saltaloot:
return
;================================================================
sub tagliuzza
tagliuzza:
set %daTagliare %1
set #LObjectID %Scissors
gosub edit_stato Taglio , #spc , pelli/ossa
Event Macro 17 0
target
Set #LTargetID %daTagliare
Set #LTargetKind 1
Event Macro 22 0
wait 10
finditem %datagliare C_ , #backpackid
if #findkind = 0
   goto tagliuzza
return
;==========================CAST_HEALING==========================
sub curati
curati:
gosub edit_stato Cure , #spc , di , #spc , emergenza!
menu set Editstato %status
       if %healmethod = 1
          {
          goto mageryheal
          }
       if %healmethod = 2
          {
          goto chivaheal
          }
       if #charGhost = YES
          {
          namespace push
          namespace local logout
          logout:
          set !timeOut #scnt + 5
          event macro 20 0
          waitlogout:
          if #scnt > !timeOut
          	goto logout
          if #contname <> YesNo_gump
          	goto waitlogout
          set !x #contposx + 120
          set !y #contposy + 90
          _quit:
          click !x !y
          set !timeOut #scnt + 20
          _waitlogout:
          if #scnt > !timeout
          	goto quit
          if #contname <> MainMenu_gump
          	goto _waitlogout
          namespace pop
          display ok sei morto! $ lo script è stato fermato.
          stop
          }
return
;================================================================
chivaheal:                      ;da rivedere i tempi di recovery
chkstatuschiv:
  if #mana < 7
     return
   while C in #charstatus && ! %ignorepoison
        {
         set %timeout #scnt2 + 15
         event macro 15 201         ;cleanse se poisonato
         while #targcurs <> 1 && %timeout > #scnt2
               {
               if Your_concentration in #sysmsg || you_have_not_yet in #sysmsg
                        {
                        wait 1
                        goto chkstatuschiv
                 	      }
               }
         event macro 23 0
         wait 18
        }
   while #Hits <= %hitscheck
        {
         set %timeout #scnt2 + 15
         event macro 15 202
         while #targcurs <> 1 && %timeout > #scnt2
               {
               if Your_concentration in #sysmsg || you_have_not_yet in #sysmsg
                        {
                        wait 1
                        goto chkstatuschiv
                 	      }
               }
         while C in #charstatus && %ignorepoison && #targcurs = 1
               {
               }
         event macro 23 0
         wait 15
         goto chkstatuschiv
        }
   if #charGhost = YES
      goto curati
mageryheal:                      ;i tempi di recovery sono calcolati con FCR3 in assenza di lag
chkstatusmag:
   while C in #charstatus && ! %ignorepoison
        {
         set %timeout #scnt2 + 15
         event macro 15 10
         while #targcurs <> 1 && %timeout > #scnt2
               {
               if Your_concentration in #sysmsg || you_have_not_yet in #sysmsg
                        {
                        wait 1
                        goto chkstatusmag
                 	      }
               }
         event macro 23 0
         wait 15
        }
   if #Hits < %hitscheck
     {
     if #hits >= ( #maxhits - 25 )
        {
         set %timeout #scnt2 + 15
         event macro 15 3
         while #targcurs <> 1 && %timeout > #scnt2
               {
               if Your_concentration in #sysmsg || you_have_not_yet in #sysmsg
                        {
                        wait 1
                        goto chkstatusmag
                 	      }
               }
         event macro 23 0
         wait 20
        }
     else
        {
         set %timeout #scnt2 + 15
         event macro 15 28                ;altrimenti fa greater heal
         while #targcurs <> 1 && %timeout > #scnt2
               {
               if Your_concentration in #sysmsg || you_have_not_yet in #sysmsg
                        {
                        wait 1
                        goto chkstatusmag
                 	      }
               }
         event macro 23 0
         wait 23
        }
   goto chkstatusmag
      }
   if #charGhost = YES
    goto curati
return
;================================================================
sub unload
if #HITS < %hitscheck || ( C in #CharStatus && ! %ignorepoison )
 gosub curati
riprova_deposito:
gosub edit_stato Deposito , #spc , il , #spc , loot
set !nruneatt %nruneatt
set %nruneatt 1
gosub recall
set %nruneatt !nruneatt
event SysMessage Recallato alla banca
if %storebank = #true
      {
        repeat
        set !jindex #jindex + 1
        set %nextrecalltobank #systime + 3000
        set %bankopened #false
        msg bank $
        while #systime < %nextrecalltobank && %bankopened = #false
              {
              set %nextjinedxend #jindex
              if !jindex <= %nextjinedxend
                  {
                  for %i !jindex %nextjinedxend
                      {
                      scanjournal %i
                      if container in #journal
                            {
                            set %bankopened #true
                            break
                            }
                      }
                  set !jindex %nextjinedxend + 1
                  }
              sleep 10
              }
        finditem %dropbag
        until #findkind <> -1
      }

else
    {
     set %timeout #scnt + 10
     while #charposx <> %xcasa || #charposy <> %ycasa
           {
           event pathfind %xcasa %ycasa
           wait 2s
           if #scnt > %timeout
              goto riprova_deposito
           }
           key %tasto
           wait 10
    }
   _p2b1:
   if %lootaleather = #TRUE
      {
      finditem %cutleather  C_ , #backpackid
      if #findkind <> -1   ; found something
         {
         exevent drag #findid #findstack
         wait 5
         exevent dropc %dropbag
         wait 7
         gosub Contatore leather #findstack #findcol
         goto _p2b1
	       }
      }
   if %lootafeather = #TRUE
      {
      finditem %feather  C_ , #backpackid
      if #findkind <> -1   ; found something
	       {
         exevent drag #findid #findstack
         wait 5
         exevent dropc %dropbag
         wait 7
         gosub Contatore feather #findstack
         goto _p2b1
         }
      }
   if %lootafrecce = #TRUE
      {
      finditem %frecce  C_ , #backpackid
      if #findkind <> -1   ; found something
	       {
         exevent drag #findid #findstack
         wait 5
         exevent dropc %dropbag
         wait 7
         gosub Contatore frecce #findstack
         goto _p2b1
         }
      }
   if %lootaossa = #TRUE
      {
      finditem %bones C_ , #backpackid
      while #findkind <> -1
         {
         set %cutIt #findid
         gosub tagliuzza %cutIt
         finditem %bones C_ , #backpackid
         }
      finditem %cutbones  C_ , #backpackid  ;GUF cutted bone IDtype
      if #findkind <> -1   ; found something
	       {
         exevent drag #findid #findstack
         wait 5
         exevent dropc %dropbag
         wait 7
	       gosub Contatore ossa #findstack
	       goto _p2b1
         }
      }
   if %lootalana = #TRUE
      {
      finditem %wool  C_ , #backpackid
      if #findkind <> -1   ; found something
	       {
         exevent drag #findid #findstack
         wait 5
         exevent dropc %dropbag
         wait 7
         gosub Contatore wool #findstack
         goto _p2b1
         }
      }
   if %lootascales = #TRUE
      {
      finditem %drgnscale  C_ , #backpackid
      if #findkind <> -1   ; found something
	       {
         exevent drag #findid #findstack
         wait 5
         exevent dropc %dropbag
         wait 7
	       gosub Contatore scaglie #findstack #findcol
         goto _p2b1
         }
      }
if %autobandage
    {
    finditem ZLF CA_ , #BACKPACKID
    if #findstack > 100
         goto skip_restock
    gosub open_cont
    finditem ZLF C_ , %dropbag
    if #findstack > 0
        {
        exevent drag #findid 100
        wait 5
        exevent dropc #backpackid
        wait 7
        }
    }
skip_restock:
gosub aggiorna_stats
gosub recall
if #result = #false
    gosub cambiaspot
return
;================================================================
sub open_cont
set #lobjectid %dropbag
while #contid <> %dropbag
      {
      event macro 17 0
      wait 20
      }
return
;================================================================
sub Contatore
   set %item %1
   set %quantita %2
   set %colore %3

   if %item = leather
      {
      if %colore = %normalleather
      set %item normalleather
      if %colore = %spinedleather
      set %item spinedleather
      if %colore = %hornedleather
      set %item hornedleather
      if %colore = %barbedleather
      set %item barbedleather
      }
   if %item = scaglie
      {
      if %colore = %whitescale
      set %item whitescale
      if %colore = %bluescale
      set %item bluescale
      if %colore = %blackscale
      set %item blackscale
      if %colore = %yellowscale
      set %item yellowscale
      if %colore = %redscale
      set %item redscale
      if %colore = %greenscale
      set %item greenscale
      }

  set %tot_ . %item %tot_ . %item + %quantita
return
;================================================================
sub reset_stats
    set %tot_normalleather 0
    set %tot_spinedleather 0
    set %tot_hornedleather 0
    set %tot_barbedleather 0
    set %tot_redscale 0
    set %tot_greenscale 0
    set %tot_yellowscale 0
    set %tot_blackscale 0
    set %tot_bluescale 0
    set %tot_whitescale 0
    set %tot_feather 0
    set %tot_frecce 0
    set %tot_ossa 0
    set %tot_wool 0
    set %timetstart #scnt
    set %total_time 0
    set %start_time 0
    set #menubutton = N/A
    gosub aggiorna_stats
return
;================================================================
sub aggiorna_stats
        gosub putPersistentVar ALF tot_feather
        gosub putPersistentVar ALF tot_ossa
        gosub putPersistentVar ALF tot_wool
        gosub putPersistentVar ALF tot_frecce
        gosub putPersistentVar ALF tot_normalleather
        gosub putPersistentVar ALF tot_spinedleather
        gosub putPersistentVar ALF tot_hornedleather
        gosub putPersistentVar ALF tot_barbedleather
        gosub putPersistentVar ALF tot_redscale
        gosub putPersistentVar ALF tot_greenscale
        gosub putPersistentVar ALF tot_yellowscale
        gosub putPersistentVar ALF tot_blackscale
        gosub putPersistentVar ALF tot_bluescale
        gosub putPersistentVar ALF tot_whitescale
        menu set normalleatheredit %tot_normalleather
        menu set spinedleatheredit %tot_spinedleather
        menu set hornedleatheredit %tot_hornedleather
        menu set barbedleatheredit %tot_barbedleather
        menu set redscaleedit %tot_redscale
        menu set greenscaleedit %tot_greenscale
        menu set yellowscaleedit %tot_yellowscale
        menu set blackscaleedit %tot_blackscale
        menu set bluescaleedit %tot_bluescale
        menu set whitescaleedit %tot_whitescale
        menu set Editfeather %tot_feather
        menu set Editossa %tot_ossa
        menu set Editwool %tot_wool
        menu set Editfrecce %tot_frecce
        gosub timecalc
return
;================================================================
sub menu_avviato
  menu Clear
	menu Window Title Leather farmer
	menu Window Color Maroon
	menu Window Size 264 384
	menu window transparent 80
	menu Font Transparent #true
	menu Font Align Right
	menu Shape cornice2 80 328 170 45 4 7 2 Olive 7 $00300080
	menu Shape CorniceStatus 17 306 233 37 4 7 2 Olive 7 $00300080
	menu Shape shape3 164 52 85 173 4 7 1 Yellow 7 Maroon
	menu Shape shape2 12 148 137 77 4 7 1 Yellow 7 Maroon
	menu Shape shape1 12 52 137 81 4 7 1 Yellow 7 Maroon
	menu Font Name Comic Sans MS
	menu Font Size 11
	menu Font Style bi
	menu Font Color Teal
	menu Font Transparent #false
	menu Font Align Left
	menu Font BGColor Maroon
	menu Text Titolino 12 4 Leather farmer by Algander
	menu Shape Mirino 230 8 19 17 1 7 3 Green 4 White
	menu Font Name MS Sans Serif
	menu Font Color WindowText
	menu Font Transparent #true
	menu Text StatisticsLbl 88 24 Statistiche
	menu Text StatoLbl 70 284 Stato dello script
	menu Font Size 8
	menu Font Style b
	menu Font Color Lime
	menu Font Transparent #false
	menu Text PelliLbl 68 44 Pelli
	menu Text ScaglieLbl 188 44 Scaglie
	menu Font Color $00004080
	menu Text lbl_plain 20 64 Plain
	menu Font Color Highlight
	menu Text lbl_spined 20 80 Spined
	menu Font Color Red
	menu Text lbl_horned 20 96 Horned
	menu Font Color Green
	menu Text lbl_Barbed 20 112 Barbed
	menu Font Color Lime
	menu Text VarieLbl 68 140 Varie
	menu Font Style
	menu Font Color ActiveCaption
	menu Text lbl_penne 20 156 Penne
	menu Text lbl_Lana 20 172 Lana
	menu Text lbl_ossa 20 188 Ossa
	menu Shape scaglia1 172 60 69 25 2 7 1 Black 7 White
	menu Shape scaglia2 172 112 69 25 2 7 1 Black 7 Yellow
	menu Shape scaglia3 172 138 69 25 2 7 1 Black 7 Red
	menu Shape scaglia4 172 164 69 25 2 7 1 Black 7 Green
	menu Shape scaglia5 172 190 69 25 2 7 1 Black 7 BtnText
	menu Shape scaglia6 172 86 69 25 2 7 1 Black 7 Blue
	menu Font Color WindowFrame
	menu Font Transparent #true
	menu Text whitescaleedit 190 66 %tot_whitescale
	menu Font Color ScrollBar
	menu Text bluescaleedit 190 92 %tot_bluescale
	menu Font Color WindowFrame
	menu Text yellowscaleedit 190 118 %tot_yellowscale
	menu Font Color InactiveCaptionText
	menu Text redscaleedit 190 144 %tot_redscale
	menu Font Color ActiveCaption
	menu Text greenscaleedit 190 170 %tot_greenscale
	menu Font Color WindowFrame
	menu Text blackscaleedit 190 195 %tot_blackscale
	menu Font Color WindowText
	menu Font Transparent #false
	menu Text Lbl_tempo 16 236 Tempo:
	menu Font Style b
	menu Text lbl_tottempo 116 236 Tempo totale:
	menu Font Style
	menu Font Color WindowFrame
	menu Text normalleatheredit 78 64 %tot_normalleather
	menu Text spinedleatheredit 78 80 %tot_spinedleather
	menu Text hornedleatheredit 78 96 %tot_hornedleather
	menu Text barbedleatheredit 78 112 %tot_barbedleather
	menu Text editfeather 78 156 %tot_feather
	menu Text editwool 78 172 %tot_wool
	menu Text editossa 78 188 %tot_ossa
	menu Font Color WindowText
	menu Text timedit 60 236 h m
	menu Text tot_timeedit 200 236 h m
	menu Font Color ActiveCaption
	menu Text lbl_frecce 20 204 Frecce
	menu Font Color WindowFrame
	menu Text editfrecce 78 204 %tot_frecce
	menu Font Size 10
	menu Font Style i
	menu Font Color WindowText
	menu Text lblglobal 20 348 Globale
	menu Shape shapex 82 336 166 17 3 7 1 $00300080 7 $00300080
	menu Font Size 8
	menu Font Style
	menu Font BGColor BtnShadow
	menu Edit EditStato 27 314 213 %status
	menu Font Color Olive
	menu Font BGColor Maroon
	menu Button ResetBtn 35 258 91 21 Reset Stats
	menu Font Style b
	menu Font Color Red
	menu Button btnPausa 139 258 91 21 Pausa!
	menu Font Style
	menu Font Color WindowText
	menu Font BGColor BtnShadow
	menu Edit globaledit 88 344 153 %global
	menu Show 421 270
	set #menubutton N/A
return
;================================================================
sub AntiBlock
   set %maxpausa #scnt + 40
   for %i 5 1
  {
    if #MENUBUTTON = btnpausa
       {
       set #menubutton N/A
       gosub edit_stato Script , #spc , messo , #spc , in , #spc , pausa , #spc , dall'utente.
       while #menubutton <> btnpausa
             {
             wait 20
             }
       set #menubutton N/A
       }
    if #MENUBUTTON = ResetBtn
       gosub reset_stats
    if #MENUBUTTON = closed
       stop
    scanjournal %i
    if ( The_world_is_saving in #journal || Cleaning_resources in #journal ) && : notin #journal
    {
         gosub edit_stato Save , #spc , rilevato, , #spc , in , #spc , attesa...
         event ExMsg #charID 3 0 SAVE IN CORSO
         aspettaskip:
         for %i 5 1
        {
            scanjournal %i
            if World_save_complete in #journal || Resources_cleaned in #journal
           {
               wait 1s
               goto fine
           }
         wait 5
        }
        if #scnt > %maxpausa
        {
             DELETEJOURNAL
             goto fine
         }
        goto aspettaskip
    }
  }
fine:
return
;================================================================
sub menu_avvio
	menu Clear
	menu Window Title Leather farmer
	menu window transparent 100
	menu Window Color Maroon
	menu Window Size 318 326
	menu Font Transparent #true
	menu Font Align Right
	menu Font Name Comic Sans MS
	menu Font Size 11
	menu Font Style bi
	menu Font Color Teal
	menu Font Transparent #false
	menu Font Align Left
	menu Font BGColor Maroon
	menu Text Titolino 52 4 Leather farmer by Algander
	menu Shape Mirino 270 8 19 17 1 7 3 Green 4 White
  menu Shape BarraLoot 69 48 3 141 3 7 1 Black 7 Navy
	menu Font Name MS Sans Serif
	menu Font Size 10
	menu Font Style b
	menu Font Color Yellow
	menu Text LabelLoot 20 28 Loot:
	menu Font Size 8
	menu Font Color Menu
  menu Text LabelCura 92 28 Metodo di cura
	menu Shape BarraOpzioni 16 268 277 5 3 7 1 Black 7 Yellow
	menu Font Style
	menu Font Color Fuchsia
	menu Text LabelOpt 108 248 Opzioni avanzate
	menu Shape RiquadroStart 204 48 97 109 4 7 1 Olive 7 Purple
	menu Font Color Window
	menu Text HPlbl 114 276 HP prima di curarsi
	menu Text LabelSearchdis 16 276 Search distance
	menu Text LabelNrune 212 276 Numero rune
	menu Font Color Aqua
	menu Text drop_bag 206 236 Container: %dropbag
	menu Font Color Aqua
	menu Text LabelBook 8 213 Runebook: %bookid
	menu Text XYCasa 8 253 Casa: %xcasa , #spc , %ycasa
	menu Font Style b
	menu Font Color Window
	menu Text stilecaccia 116 160 Stile di caccia
	menu Font Style
	menu Check lootpelli 8 56 57 17 %lootaleather Pelli
	menu Check lootpenne 8 78 57 17 %lootafeather Penne
	menu Check lootossa 8 100 57 17 %lootaossa Ossa
	menu Check lootlana 8 122 57 17 %lootalana Lana
	menu Check lootfrecce 8 144 57 17 %lootafrecce Frecce
	menu Check lootScales 8 166 57 17 %lootaScales Scaglie
	menu Font Color WindowText
	menu Font BGColor Window
	menu Combo Create HealCombo 92 52 81
	menu combo add HealCombo Magery
	menu combo add HealCombo Chivalry
	;menu combo add HealCombo Bende
	menu combo select HealCombo %healmethod
	menu Font Color WindowText
	menu Font BGColor Purple
	menu Button start 216 64 73 77 Start
	menu Font BGColor Window
	menu Edit searchdis 16 292 33 %searchdistance
	menu Edit Nrune 212 292 26 %numberofplaces
	menu Edit hitsctrl 114 292 33 %hitsctrl
	menu Font Color ScrollBar
	menu Text DehHits 154 296 (- , #maxhits .. -1)
	menu Text DefRune 246 296 (1..16)
	menu Text DefDis 56 296 (1..7)
  menu Font Color Window
	menu Font BGColor Maroon
	menu Check chkautoband 82 84 84 17 %autobandage Auto-bendata
	menu Check chkPB 82 110 122 37 %pathback Ritorna indietro se troppo distante (no-wandering)
	menu Check bankcheck 224 180 85 21 %storebank Store in bank
	menu Font Color WindowText
	menu Font BGColor BtnFace
	menu Button SetBagBtn 220 208 81 21 Set Container
  menu Button SetrbookBbtn 16 190 79 21 Set Runebook
  menu Button SetCasa 16 230 79 21 Set Casa
	menu Font BGColor Window
	menu List Create huntstyle 112 176 89 61
 	menu List Add huntstyle Melee
	menu List Add huntstyle Magery - Fireball
  menu List Add huntstyle Magery - Lighting
 	;menu List Add huntstyle Pet - Nonmount
  menu List select huntstyle %huntstyle
	menu Show 421 270
	set #menuButton N/A

MenuLoop:

if #MENUBUTTON = closed
   stop
if #MENUBUTTON = SetrbookBbtn
   {
   set #MENUBUTTON = N/A
   gosub set_rbook
   menu set LabelBook Runebook: %bookid
   }
if #MENUBUTTON = SetBagBtn
   {
   set #MENUBUTTON = N/A
   gosub set_bag
   menu set drop_bag Bag: %dropbag
   }
If #MENUBUTTON = start ;<-- controlla se start è premuto e inizia.
   {
   menu hide
   return
   }
if #MENUBUTTON = SetCasa
   {
   set #MENUBUTTON = N/A
   set %xcasa #charposx
   set %ycasa #charposy
   gosub putPersistentVar ALF xcasa
   gosub putPersistentVar ALF ycasa
   menu set XYCasa Casa: %xcasa , #spc , %ycasa
   }
goto MenuLoop
;================================================================
sub set_bag
    menu get bankcheck
    if %storebank <> #menuRes
       {
       set %storebank #menures
       gosub putPersistentVar ALF storebank
       }
    set #targcurs 1
    while #targcurs = 1
        {
        event ExMsg #CHARID 3 50 Targetta la Resource Bag
        wait 1s
        }
    set %dropbag #ltargetID
    ;if ! %storebank
    ;   {
    ;   set %xcasa #charposx
    ;   set %ycasa #charposy
    ;   gosub putPersistentVar ALF xcasa
    ;   gosub putPersistentVar ALF ycasa
    ;   }
    gosub putPersistentVar ALF dropbag
    event ExMsg #CHARID 3 50 Ok
return
;================================================================
sub set_rbook
    set #targcurs 1
    while #targcurs = 1
        {
        event ExMsg #CHARID 3 50 Targetta il Runebook
        wait 1s
        }
    set %bookid #ltargetID
    gosub putPersistentVar ALF bookid
    event ExMsg #CHARID 3 50 Ok
return
;================================================================
sub finesetup
finditem #charid
if #findtype = IS || #findtype = HS
   set %chkelf #false
else
   set %chkelf #true

finditem %bwc C_ , #backpackid
set %usabwc #true
if #findkind = -1
   {
   set %usabwc #false
   finditem %nonbwc C_ , #backpackid
            if #findkind = -1
            {
            display Procurati una lama per tagliare le pelli $ e riavvia lo script
            halt
            }
   }
set %skin_blade #findid

    menu get lootpelli
    if %lootaleather <> #menuRes
       {
       set %lootaleather #menures
       gosub putPersistentVar ALF lootaleather
       }
    menu get lootpenne
    if %lootafeather <> #menuRes
       {
       set %lootafeather #menures
       gosub putPersistentVar ALF lootafeather
       }
    menu get lootossa
    if  %lootaossa <> #menuRes
       {
       set %lootaossa #menures
       gosub putPersistentVar ALF lootaossa
       }
    menu get lootlana
    if %lootalana <> #menuRes
       {
       set %lootalana #menures
       gosub putPersistentVar ALF lootalana
       }
    menu get lootfrecce
    if %lootafrecce <> #menuRes
       {
       set %lootafrecce #menures
       gosub putPersistentVar ALF lootafrecce
       }
    menu get lootscales
    if %lootascales <> #menuRes
       {
       set %lootascales #menures
       gosub putPersistentVar ALF lootascales
       }
    menu get bankcheck
    if %storebank <> #menuRes
       {
       set %storebank #menures
       gosub putPersistentVar ALF storebank
       }
    menu get chkPB
    if %pathback <> #menuRes
       {
       set %pathback #menures
       gosub putPersistentVar ALF pathback
       }
    menu getnum searchdis
    if %searchdistance <> #menuRes
       {
        set %searchdistance #menures
        gosub putPersistentVar ALF searchdistance
       }
    menu getnum hitsctrl
    if %hitsctrl <> #menuRes
       {
        set %hitsctrl #menures
        gosub putPersistentVar ALF hitsctrl
       }
    menu getnum Nrune
    if %numberofplaces <> #menuRes
       {
        set %numberofplaces #menures
        gosub putPersistentVar ALF numberofplaces
       }
    menu get healcombo
    if %healmethod <> #menuRes
       {
       set %healmethod #menures
       gosub putPersistentVar ALF healmethod
       }
    menu get huntstyle
    if %huntstyle <> #menuRes
       {
       set %huntstyle #menures
       gosub putPersistentVar ALF huntstyle
       }
    menu get chkautoband
    if %autobandage <> #menuRes
       {
       set %autobandage #menures
       gosub putPersistentVar ALF autobandage
       }
       
;setta le liste mob in base ai loot scelti
    if %lootaleather
       set %animals %animals , %hidebearers
    if %lootafeather
       set %animals %animals , %featherbearers
    if %lootaossa
       set %animals %animals , %bonebearers
    if %lootalana
       set %animals %animals , %sheep

set %hitscheck ( #maxhits + %hitsctrl )  ;a quanti hp inizia a curarsi

    if %chkelf
       set %weightmax #maxweight - 50
    else
       set %weightmax #maxweight + 20
    if %usabwc = #false
       set %weightmax %weightmax - 40

chooseSkill Necro
if #skill > 600
   set %painspike #true
else
   set %painspike #false
       
if %lootaossa = #true || %usaBWC = #false
   {
   FindItem JAG_KAG C_ , #BackPackID
   If #FindKind = -1
      {
      Display Ok you do not have any scissors.$ Get one and restart.$ Script Halted
      Halt
      }
   Set %Scissors #FindID
   }
if %autobandage
   {
   finditem ZLF CA_ , #BACKPACKID
   if #findstack = 0
      display ok Non hai bende nello zaino!
      + $Lo script provvederà al restock con il
      + $prossimo passaggio dalla casa/banca.
      + $$Ricorda che le bende devono essere dentro$al contenitore.
   }
return
;================================================================
sub Check_Skill_Recall
   set %magery
   set %chiva
   set %skillsel

   chooseSkill Mager
   set %magery #SKILL

   chooseSkill Chiva
   set %chiva #SKILL

   set %magie 0
   if %magery > ( %chiva - 1 )
   {
        set %skillsel %magery
        set %magie 1
    }
    else
    {
        set %skillsel %chiva
        set %magie 2
    }
    if %skillsell < 250
    {
        display OK Hai skill per recallarti troppo basse $ Script fermato.
        halt
    }
    if %skillsell < 500
    {
        event ExMsg #CHARID 3 25 La skill per recallare è un po' bassina... ma salirà via via^^ $
    }

return
;================================================================
sub cambiaspot
riprovarecall:
gosub AntiBlock
     set %nruneatt %nruneatt + 1
     if %nruneatt > %numberofplaces
         {
         set %nruneatt 2
         }
     gosub recall
     if #result = #false
         goto riprovarecall
wait 15
event SysMessage Recallato alla runa %nruneatt
set %Startposx #charposx
set %Startposy #charposy
return
;================================================================
sub Recall

   if %nruneatt = 1
      gosub edit_stato Recallo , #spc , alla , #spc , banca
   else
      gosub edit_stato Recallo , #spc , alla , #spc , runa , #spc , %nruneatt
   if %huntstyle = 4
      msg all follow me $
   set %_runenumber %nruneatt
   set %bookx 0
   set %booky 0
   set %_oldx #charposx
   set %_oldy #charposy
   set %_runex 138
   set %ymagie 180
rirecalldopofiz:
   set %runabloccata #false
   if %magie = 1
   {
   set %ymagie 145
   }
   set %_page 0
   set %_side 0
   ;pagina
   set %_page %_runenumber + 1
   set %_page %_page / 2
   ;side
    set %_num %_runenumber / 2
    set %_num %_num * 2
    if %_num = %_runenumber
       set %_side 1
    if %_side = 1
       set %_runex 298
   set %risp #true
   set %xc 0
   set %yc 0
   set %_pagexmod %_page * 34
   set %_pagex 104
   set %_pagex %_pagex + %_pagexmod
   if %_page > 4
      set %_pagex %_pagex + 31
   recallopenagain:
   set #LOBJECTID %bookid
   event macro 17 0
   set %error #scnt + 2
   gosub wait_gump generic_gump
   if ! #result
       goto recallopenagain
   set %bookx #CONTPOSX
   set %booky #CONTPOSY
   set %xc %bookx + %_pagex
   set %yc %booky + 195
   click %xc %yc
   gosub wait_gump generic_gump
   if ! #result
       goto recallopenagain
   set %bookx #contposx
   set %booky #contposy
   set %xc %bookx + %_runex
   set %yc %booky + %ymagie
   set !jindex #jindex
   click %xc %yc
   set !w4serr #scnt + 4
   while %_oldx = #charposx && %_oldy = #charposy && #scnt < !w4serr
   {
     if #scnt > !w4serr
        break
     sleep 3
   }
gosub AntiBlock
   if %_oldx = #charposx && %_oldy = #charposy
      {
         set %risp #false
         for %i !jindex #jindex
         {
            scanjournal %i
            if THAT_LOCATION_IS_BLOCKED in #journal && #jcolor = %sys_color
            {
                DELETEJOURNAL
                if %_runenumber <> 1
                   return %risp
            }
            if your_concentration in #journal || recovered in #journal
               goto rirecalldopofiz
            if mana in #journal && : notin #journal
                while #mana <= 11
                      {
                      sleep 5
                      if #mana > 9
                          goto rirecalldopofiz
                      }
         }
      }
wait 10
return %risp
;====================== Wait&check subs ==========================
sub wait_loot
   set !errwg #scnt2 + 50
   wlsubloop:
   wait 4
   gosub ScanForJournalMsg You_did_not_earn_the_right 1 10 4
   if #result = #true
      return ignora
   if #CONTID = %corpseid && #contsize = 144_212
     return #true
   if #scnt2 < !errwg
      goto wlsubloop
return #false
;================================================================
sub wait_gump
   set !gumpdaattendere %1
   set !errwg #scnt + 5
   wgsubloop:
   wait 2
   if #CONTNAME = !gumpdaattendere && #CONTSIZE = 452_236
     return #true
   if #scnt < !errwg
      goto wgsubloop
return #false
;================================================================
sub Edit_stato
    set %status %1
    menu set Editstato %status
return
;================================================================
sub inizializza_variabili
  if  <PersistentVarsString> notin * . ALF
      set * . ALF <PersistentVarsString>
  set %creata #false
  gosub getpersistentVar ALF creata
  if #result = #false
      {
        gosub putPersistentVar ALF creata
        gosub putPersistentVar ALF searchdistance
        gosub putPersistentVar ALF dropbag
        gosub putPersistentVar ALF bookid
        gosub putPersistentVar ALF numberofplaces
        gosub putPersistentVar ALF hitsctrl
        gosub putPersistentVar ALF pathback
        gosub putPersistentVar ALF autobandage
        gosub putPersistentVar ALF storebank
        gosub putPersistentVar ALF xcasa
        gosub putPersistentVar ALF ycasa
        gosub putPersistentVar ALF lootaleather
        gosub putPersistentVar ALF lootafeather
        gosub putPersistentVar ALF lootaossa
        gosub putPersistentVar ALF lootalana
        gosub putPersistentVar ALF lootafrecce
        gosub putPersistentVar ALF lootaScales
        gosub putPersistentVar ALF huntstyle
        gosub putPersistentVar ALF tot_feather
        gosub putPersistentVar ALF tot_ossa
        gosub putPersistentVar ALF tot_wool
        gosub putPersistentVar ALF tot_frecce
        gosub putPersistentVar ALF healmethod
        gosub putPersistentVar ALF tot_normalleather
        gosub putPersistentVar ALF tot_spinedleather
        gosub putPersistentVar ALF tot_hornedleather
        gosub putPersistentVar ALF tot_barbedleather
        gosub putPersistentVar ALF tot_redscale
        gosub putPersistentVar ALF tot_greenscale
        gosub putPersistentVar ALF tot_yellowscale
        gosub putPersistentVar ALF tot_blackscale
        gosub putPersistentVar ALF tot_bluescale
        gosub putPersistentVar ALF tot_whitescale
        gosub putPersistentVar ALF total_time
        set %creata #true
        gosub putpersistent ALF creata
      }
  else
      {
        gosub getPersistentVar ALF searchdistance
        gosub getPersistentVar ALF dropbag
        gosub getPersistentVar ALF bookid
        gosub getPersistentVar ALF numberofplaces
        gosub getPersistentVar ALF hitsctrl
        gosub getPersistentVar ALF pathback
        gosub getPersistentVar ALF autobandage
        gosub getPersistentVar ALF storebank
        gosub getPersistentVar ALF xcasa
        gosub getPersistentVar ALF ycasa
        gosub getPersistentVar ALF lootaleather
        gosub getPersistentVar ALF lootafeather
        gosub getPersistentVar ALF lootaossa
        gosub getPersistentVar ALF lootalana
        gosub getPersistentVar ALF lootafrecce
        gosub getPersistentVar ALF lootaScales
        gosub getPersistentVar ALF huntstyle
        gosub getPersistentVar ALF healmethod
        gosub getPersistentVar ALF tot_feather
        gosub getPersistentVar ALF tot_ossa
        gosub getPersistentVar ALF tot_wool
        gosub getPersistentVar ALF tot_frecce
        gosub getPersistentVar ALF tot_normalleather
        gosub getPersistentVar ALF tot_spinedleather
        gosub getPersistentVar ALF tot_hornedleather
        gosub getPersistentVar ALF tot_barbedleather
        gosub getPersistentVar ALF tot_redscale
        gosub getPersistentVar ALF tot_greenscale
        gosub getPersistentVar ALF tot_yellowscale
        gosub getPersistentVar ALF tot_blackscale
        gosub getPersistentVar ALF tot_bluescale
        gosub getPersistentVar ALF tot_whitescale
        gosub getPersistentVar ALF total_time
        set %start_time %total_time
      }
;dato che la variabile è stata introdotta in seguito, potrebbe non essere letto correttamente se si ha usato una versione
;precedente dello script
if %pathback = N/A
    {
    set %pathback #true
    gosub putPersistentVar ALF pathback
    }
if %autobandage = N/A
    {
    set %autobandage #false
    gosub putPersistentVar ALF autobandage
    }
return
;===================== Management functions =====================
Sub getPersistentVar
nameSpace push
nameSpace local #systime , _ , %2 , GET
set !lpc #lpc
set #lpc 1000
set !persistent * . %1
set !varName v , %2 , :
str pos !persistent !varName
set #result #strres <> 0
if #result
{
   set !varNamePos #strres
   str len !varName
   set !delString !varNamePos + #strres - 1
   str del !persistent 1 !delString
   set !persistent #strres
   str pos !persistent |
   set !varNamePos #strres - 1
   str left !persistent !varNamePos
   set % . %2 #strres
}
else
{
   set % . %2 N/A
}
set #lpc !lpc
nameSpace Clear
nameSpace Pop
return #result
;================================================================
Sub putPersistentVar
nameSpace push
nameSpace local #systime , _ , %2 , PUT
set !lpc #lpc
set #lpc 1000
set !persistent * . %1
set !varName v , %2 , :
str pos !persistent !varName
if #strres = 0
{
   if  <PersistentVarsString> notin !persistent
      set !persistent <PersistentVarsString>
   set * . %1 !persistent , !varName , % . %2 , |
   set #lpc !lpc
   nameSpace clear
   nameSpace pop
   return #true
}
set !varNamePos #strres
str len !varName
set !splitString !varNamePos + #strres - 1
str left !persistent !splitstring
set !persistentPart1 #strres
str del !persistent 1 !splitString
set !persistent #strres
str len !persistent
set !persistentLen #strres
str pos !persistent |
set !splitString !persistentLen - #strres + 1
str right !persistent !splitstring
set !persistent #strres
set * . %1 !persistentPart1 , % . %2 , !persistent
set #lpc !lpc
nameSpace clear
nameSpace pop
return #true
;================================================================
; Script Name: ScanForJournalMsg Sub
; Author: Jo Mac
; Version: 1.02
; Client Tested with: 6.0.1.8
; EUO version: V1.50 [Build 121]
; Shard: OSI
; Revision Date: 7/28/2007
; Public Release: 7/23/2007
; Global Variables Used: none
; Purpose: To simplify adding a journal scan to a script
;          Also can test to see if journal line is a system message
; Format: call ScanForJournalMsg.txt [message_to_check_for] [1 = no check , 2 = sysmsg check] [timeout default = 10] [n° of additional lines to scan (every line given is before the start of the sub), Algander]
;         call ScanForJournalMsg.txt message_to_check_for 1 20
;         if #result = #true
;            [some action]
; Change 7/28/2007  Changes made to speed up sub by reducing iterrations - False results still will go to user defined timeout.
; Nota: alcune modifiche, Algander.
;================================================================
sub scanforjournalmsg
if %0 = n/a || %0 <> 4
{
	display ok ScanForJournalMsg error - Halting
	halt
}
; store calling script's lpc setting
set %sfjm_lpc #lpc
; start with empty result
set #result n/a
; temporarily speed up processing
set #lpc 500
if %3 <> n/a
   set %sfjm_Timer #sCnt2 + %3 ; timeout
else
   set %sfjm_Timer #sCnt2 + 10 ; timeout
repeat
{
gosub Scan_ForJournalMsg %1 %2
}
until %sfjm_Timer < #sCnt2 || #result = #true
; restore calling script's lpc setting
set #lpc %sfjm_lpc
return #result
;================================================================
sub Scan_ForJournalMsg
{
 set %sfjm_jStart #jIndex - %4
 set %sfjm_ckmessage %1
 set %sfjm_cksysmsg %2

 for %iiJnl %sfjm_jStart #jIndex
 {
  scanjournal %iiJnl
  if ( %sfjm_ckmessage in #journal )
  {
   if ( %sfjm_cksysmsg = 2 )
   {
    ; check to make sure it is a system message
     gosub isSystemMsg #journal
     return #result
   }
   return #true
  }
 }
 return #false
}
; gosub isSystemMsg #journal
;==================================
sub isSystemMsg
{
; step through first part of message only
 set %sfjm_sysstr  %1
 str Len %sfjm_sysstr
 set %sfjm_jlen #strres
 if %sfjm_jlen > 25
   set %sfjm_jlen 25
 for %iiSys 5 %sfjm_jlen
 {
  str Left %sfjm_sysstr %iiSys
  if __ in #strres
  {
   if :__ in #strres
   {
     return #false
   }
   break
  }
 }
 return #true
}
;================================================================
sub TimeCalc
set %elapsed #scnt - %timetstart
set %Ttotal %start_time  +  %elapsed
set %total_time %Ttotal
gosub putPersistentVar ALF total_time
set %ehours %Ttotal / 3600
set %emins  ( %Ttotal / 60 ) - ( %ehours * 60 )
if %lastehours <> %ehours
{
	set %lastehours %ehours
}
if %lastemins <> %emins
{
	set %lastemins %emins
}
  menu set tot_timeedit %ehours , h , #spc , %emins , m
set %ehours %elapsed / 3600
set %emins  ( %elapsed / 60 ) - ( %ehours * 60 )
if %lastehours <> %ehours
{
	set %lastehours %ehours
}
if %lastemins <> %emins
{
	set %lastemins %emins
}
  menu set timedit %ehours , h , #spc , %emins , m
return

