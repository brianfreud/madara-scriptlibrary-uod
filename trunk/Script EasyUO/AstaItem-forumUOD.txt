gosub showEUOMenu1
gosub Inizialize
gosub MenuLoop
halt

sub MenuLoop
	while #true
	{
		menuloopstart:
		menu Get InLista
		if #menures <> %ItemCurrent && #menures <> 0
		{
			set %ItemCurrent #menures
			gosub string exp %itemproperty . %ItemCurrent $ CurrentArray
			set %CurrentArrayCnt #result - 1
			menu delete Corrente
			menu List Create Corrente 228 32 205 233
			for %k 1 %CurrentArrayCnt
			{
				menu List Add Corrente %CurrentArray . %k
			}
		}

		if #menubutton = CLOSED
		{
			set #menubutton N/A
			halt
		}
		if #menubutton = AGGIUNGIITEM
		{
			set #menubutton N/A
			Event ExMsg #charid 3 33 Scegliere l'item da aggiungere...
			set #ltargetkind 1
			set #targcurs 1
			while #targcurs = 1
			{
				wait 1
				onhotkey ESC
				{
					goto menuloopstart
				}
			}

			gosub GetProperty #ltargetid

			set %ItemCnt %ItemCnt + 1
			set %itemproperty . %ItemCnt #result

			str pos #result $
			set #strres #strres - 1
			str left #result #strres
			menu List Add InLista #strres
			menu Text OggettiCnt 8 8 Oggetti nella lista: %ItemCnt
			menu List Select Inlista %ItemCnt


		}

		if #menubutton = SACCA
		{
			set #menubutton N/A
			Event ExMsg #charid 3 63 Scegliere la sacca conetenete gli oggetti
			set #ltargetkind 1
			set #targcurs 1
			while #targcurs = 1
			{
				wait 1
				onhotkey ESC
				{
					goto menuloopstart
				}
			}
			set #lobjectid #ltargetid
			Event Macro 17 0
			wait 12
			finditem * C_ , #contid
			while #findkind <> -1 && #findindex <= #findcnt
			{
				gosub GetProperty #findid
				set %ItemCnt %ItemCnt + 1
				set %itemproperty . %ItemCnt #result
				str pos #result $
				set #strres #strres - 1
				str left #result #strres
				menu List Add InLista #strres
				menu Text OggettiCnt 8 8 Oggetti nella lista: %ItemCnt
				set #findindex #findindex + 1
			}

			menu List Select Inlista %ItemCnt
		}

		if #menubutton = STAMPA
		{
			set #menubutton N/A
			menu get NomeFile
			set %file #menures
			gosub showEUOMenu2

			gosub open 1 %file
			gosub wipe 1
			gosub write 1 %separator

			for %i 1 %ItemCnt
			{
				gosub write 1 Lotto , #SPC , numero , #SPC , %i
				gosub write 1 #dot
				gosub string exp %itemproperty . %i $ StringArray
				set %StringArrayCnt #result - 1
				for %j 1 %StringArrayCnt
				{
					gosub write 1 %StringArray . %j
				}
				gosub write 1 #dot
				gosub write 1 Base:
				gosub write 1 Rilanci:
				gosub write 1 Instant , #SPC , Win:
				gosub write 1 %separator

				menu set Completi Scritti %i di %ItemCnt oggetti
			}

			gosub dump 1
			set %ItemCnt 0
			gosub showEUOMenu1

		}

		if #menubutton = APRI
		{
			set #menubutton N/A
			menu get NomeFile

			execute #menures
		}
	}
return

sub Inizialize

	if 1_5 notin #euover
	{
		display ok Questo script funziona solo con EasyUO 1.5!
		halt
	}

	if exec notin #opts
	{
		display ok Non hai abilitato l'exec dalle funzioni!
		halt
	}

  set #menubutton N/A
  set %ItemCurrent 0
  set %ItemCnt 0
	set %Separator +------------------------------+

return

;==================
;**
;* @name GetProperty
;* @ver 1.0 15May05
;* @author  Boydon
;* @purpose Get the #property of a given item tring to avoid errors, null values and
;*					unexpected values.
;* @params %1 req Id of the item you want to EP
;* @returns #property of %1
;* @dependencies
;* @example gosub GetProperty #findid
;*						tis is the standard call and will EP #findid
;* @status Fully tested and working

sub GetProperty

	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub GetProperty: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	nameSpace Push
	nameSpace Local GetProperty , #time , #random , #scnt2

	__boy_gp_loop1:
	event property %1
	set !Property1 #property
	event property %1
	set !Property2 #property
	event property %1
	set !Property3 #property

	if ! ( !Property1 = !Property2 && !Property2 = !Property3 )
		goto __boy_gp_loop1

	nameSpace Clear
	nameSpace Pop

return #property
;--------- EasyUO Menu Designer Code Begin ---------
sub showEUOMenu1
	menu Clear
	menu Window Title Boydon UOD Auction Maker
	menu Window Color BtnFace
	menu Window Size 440 361
	menu Font Transparent #true
	menu Font Align Right
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color WindowText
	menu Font Transparent #false
	menu Font Align Left
	menu Text OggettiCnt 8 8 Oggetti nella lista: 0
	menu Text Ultimo 228 8 Oggetto corrente
	menu Button AggiungiItem 8 280 155 29 Aggiungi un oggetto alla lista
	menu Button Stampa 12 320 125 29 Stampa la lista
	menu Font BGColor Window
	menu Edit NomeFile 276 324 155 Asta.txt
	menu Font BGColor BtnFace
	menu Button Apri 144 320 126 29 Apri la lista
	menu Button Sacca 172 280 263 29 Aggiungi alla lista tutti gli oggetti in un contenitore
	menu Font BGColor Window
	menu List Create InLista 8 32 205 233
	menu Font BGColor Menu
	menu List Create Corrente 228 32 205 233
	menu Show 750 25
return

sub showEUOMenu2
	menu Clear
	menu Window Title Boydon UOD Auction Maker
	menu Window Color BtnFace
	menu Window Size 352 25
	menu Font Transparent #true
	menu Font Align Right
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color WindowText
	menu Font Transparent #false
	menu Font Align Left
	menu Text Completi 8 8 Scritti 0 di 0 items
	menu Show 750 25
return
;--------- EasyUO Menu Designer Code End ---------

;==================================
; Script Name: filesubs.txt (import version)
; Author: Kal In Ex
; Version: 1.00
; Client Tested with: 4.0.5b
; EUO version tested with: 1.42.009b
; Shard OSI / FS: OSI
; Revision Date: November 16, 2004
; Public Release: November 16, 2004
; Global Variables Used:
; Purpose: writing to files in EUO
; Copyright 2004 Kal In Ex
;==================================

; subs open, GetOSFileCmd, wipe, fwipe, write and dump
; are all a part of filesubs.txt only use this script
; in its entirety and do not modify it!

sub open ; <identifier> <filename>
	namespace push
	namespace local _filebuffers
	set !_filename %1 , _filename
	set !_buffer %1 , _buffer
	set !_dirop %1 , _dirop
	set ! . !_filename %2
	set ! . !_buffer
	set ! . !_dirop >>
	if !_filecmd = n/a
		{
		gosub GetOSFileCmd 1
		set !_filecmd %1
		}
	namespace pop
	return

;==================
;**
;* @name GetOSFileCmd
;* @ver 1.0 9May04
;* @author Roadkill
;* @purpose check the OS and set @%1 to cmd.exe or command.exe if win98/2000xp
;* @params %1 the varname to hold the return command
;* @returns @%1 and #result hold cmd.exe for win2k and xp, or command.exe for 98/me
;* @example call rksubs.txt GetOSFileCmd filecmd
;* @status done
sub GetOSFileCmd
	str Left #osver 1
	set % . %1 cmd.exe
	if #strRes = 1
		set % . %1 command.com
	return % . %1
;==================

sub wipe ; <identifier>
	namespace push
	namespace local _filebuffers
	set !_buffer %1 , _buffer
	set !_dirop %1 , _dirop
	set ! . !_buffer
	set ! . !_dirop >
	namespace pop
	return

sub fwipe ; <identifier>
	namespace push
	namespace local _filebuffers
	set !_filename %1 , _filename
	set !_buffer %1 , _buffer
	set ! . !_buffer
	execute !_filecmd type > ! . !_filename
	namespace pop
	return

sub write ; <identifier> <text> <text> <text...>
	namespace push
	namespace local _filebuffers
	if %0 > 2
		{
		for !_ 3 %0
			{
			set %2 %2 , #spc , % . !_
			}
		}
	set !_filename %1 , _filename
	set !_buffer %1 , _buffer
	set !_dirop %1 , _dirop

	str len ! . !_buffer
	set !_ #strres
	str len %2
	if !_ + #strres >= 1900
		{
		execute !_filecmd /c ! . !_buffer >> ! . !_filename
		set ! . !_buffer
		}
	str len ! . !_buffer
	if #strres = 0 || ! . !_dirop = >
		set ! . !_buffer echo , #spc , %2 , #spc , ! . !_dirop , #spc , ! . !_filename
	else
		set ! . !_buffer ! . !_buffer , #spc , && , #spc , echo , #spc , %2 , #spc , ! . !_dirop , #spc , ! . !_filename
	set ! . !_dirop >>
	namespace pop
	return

sub dump ; <identifier>
	namespace push
	namespace local _filebuffers
	set !_filename %1 , _filename
	set !_buffer %1 , _buffer
	str len ! . !_buffer
	if #strres > 0
		{
		execute !_filecmd /c ! . !_buffer
		set ! . !_buffer
		}
	namespace pop
	return
;==================================
; end of filesubs.txt
;==================================

;==================================
; Script Name: Gravisoft's String Implode/Explode SUB
; Author: Gravix
; Version: 1.1
; Client Tested with: 4.0.6a
; EUO version tested with: 1.42.009F
; Shard OSI / FS: Both
; Revision Date: 1/19/04
; Public Release: 1/01/04
; Global Variables Used: None
; Purpose: Implode: Take an array and link into a string separated by a value/char
; Explode: Take a string and break into array based on dividers
;==================================

;SUB string exp %str %div %arry
;SUB string imp %arry %div

SUB string
  SET !lpc #LPC
  SET #LPC 500
  IF %1 = exp
  {
  SET !c 0
  SET !s %2
break:
    IF %3 in !s
    {
      SET !c !c + 1
      STR POS !s %3
      SET !p0 #STRRES
      SET !p1 !p0 - 1
      STR LEFT !s !p1
      SET % . %4 , !c #STRRES
      STR DEL !s 1 !p0
      SET !s #STRRES
      GOTO break
    }
    ELSE
    {
      SET !c !c + 1
      SET % . %4 , !c !s
      SET #LPC !lpc
      RETURN !c
    }
  }

  IF %1 = imp
  {
  SET !p 0
  SET !t
build:
    SET !p !p + 1
    SET !p3 %2 , !p
    IF % . !p3 <> N/A
    {
      SET !t !t , %3 , % . !p3
      GOTO build
    }
    ELSE
    {
      STR LEN %3
      STR DEL !t 1 #STRRES
      SET #LPC !lpc
      RETURN #STRRES
    }
  }

RETURN #FALSE
