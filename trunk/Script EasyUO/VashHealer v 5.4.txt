;==========================================
; Vash Healer 5.4
;
; Autore originale: Vash (UODreams)
; Fix versione 5.4: MagnetoStaff (UODreams)
;
;
;==========================================
;
; IMPORTANTE:
; -----------
; 1- Tenere sempre zaino e status aperti.
; 2- Attivare il Targeting System con l'apposita macro client.
; 3- Disattivare l'auto-accoda azioni di Razor.
; 4- Compatibile solo con RunUO 2.0 e shard OSI-Style.
;
; Ecco le features dello script:
; ------------------------------
; 1) Avverte se le bende stanno per finire, e se finiscono
; è sufficiente rifornirsi, senza doverlo riavviare.
; 2) Controlla il journal per verificare che le bende siano
; state correttamente applicate, altrimenti riprova.
; 3) Mostra il tempo di bendata sulla testa del pg.
; 4) Potete precastare magie, e finchè c'è il target fuori,
; lo script non benderà.
; 5) Scarissima interferenza con i target delle spell.
; 6) Non benda da hiddati, per non venire revelati.
; 7) La bendata entrerà in azione subito dopo un mortal strike in modo da finire,
; se possibile, poco dopo la fine dell'effetto.
; 8) Auto cure e auto refresh.
;
; Fate il setup qui sotto, ricordando che vero è #true e falso è #false.
menu clear
menu Window Title Bende Akkarin
menu Window Size 150 35
menu show
menu Font Transparent #false
menu Font BGColor None
menu Font Align Right
menu Font Name MS Sans Serif
menu Font Size 14
menu Font Style
menu Font Color Lime
menu Font Transparent #false
menu Window Transparent 80
menu Window Color None
menu Text EUOLabel1 90 8
; SETUP
; -----

; Delay (in ventesimi di secondo) introdotto per evitare di incorrere nel messaggio "You must wait to perform another action"
set %nextactiondelay 10

; Settando counter a true, avrete il contatore nella finestra.
set %counter #true

; Settando headcounter a true, avrete il contatore sopra la testa del pg.
set %headcounter #true

; Volete il counter in decimi di secondo anzichè in secondi,
; come nel vecchio vash healer? Mettete #true qui:
set %oldStyle #false

; Attenzione: col contatore oldstyle di rischia di crashare.

; La prossima variabile indica il limite di hp al di sotto dei quali curare.
; Mettendo 5 ad esempio, se avete 100hp, benderà solo al di sotto di 95hp.
set %limit 5

; ANTIMORTAL
; ----------
; Se avete problemi con l'antimortal settato a 62, mettetelo a 64.
; Può essere utile in caso di pc vecchio, lag, ecc.
set %antimortal 64

; POZIONI
; --------
; Qui avete due variabili da settare #true o #false.
; La prima farà bere in automatico allo script le pozze cure.
; La seconda berrà in automatico pozze refresh.
set %cure #false
set %refresh #false
; Se avete settato l'auto-refresh, settate al di sotto di quale
; valore della stamina è necessario berle:
set %stamina 70

; Sconsiglio vivamente queste opzioni su pg arciere, in quanto
; potreste bere in automatico la pozza in un momento critico,
; e non è bello venire disarmati in momenti critici.

; Adesso, a seconda che utilizziate Razor o Injection e vogliate
; usare l'autocure o l'autorefresh, dovete farvi due macro.
; Una macro deve togliere scudo (o arma o libro) e bere la pozza cure,
; l'altra deve bere la pozza refresh.
; Dopodichè scrivete il nome della macro o della sub qui:
set %macroCure DrinkCure
set %macroRefresh Stam

; Qua sotto invece metti #true se utilizzi razor,
; altrimenti se utilizzi injection metti #false.

set %razor #true

; OPTIONAL
; --------
; Qui si può impostare i caratteri e il colore
; del contatore. I caratteri vanno da 0 a 7, provateli.
; I colori vanno da 0 a non so quanto. Esempio:
; Font normale, colore grigio: font 3 color 0
; Font grossa, colore viola: font 0 color 20
set %font 0
set %color 20
; Abbiamo finito il setup.
;==========================================

;==========================================
; Main Loop
; ---------
set #lpc 30
set %mortal #false

if %cure
{
   if %razor
      set %cureCmd -Macro , #spc , %macroCure
   else
      set %cureCmd , exec , #spc , %macroCure
}

if %refresh
{
   if %razor
      set %refCmd -Macro , #spc , %macroRefresh
   else
      set %refCmd ,exec , #spc , %macroRefresh
}

set %lastStamina #scnt

_mainloop:

if yes in #charghost
{
   wait 1s
   goto _mainloop
}

if ( ( ( #hits < ( #maxhits - %limit ) ) || C in #charstatus ) && H notin #charstatus )
{
   set %hasRefresh #false
   set %hasCure #false

   finditem NUF C_ , #backpackid
   if #findcnt > 0
   set %hasCure #true

   finditem ZUF C_ , #backpackid
   if #findcnt > 0
   set %hasRefresh #true

   GoSub CheckAids
   if #result = #true
   {
      if #targcurs = 1
      GoSub WaitCurs 0

      set %delay ( ( 11 - ( #dex / 20 ) ) * 10 )

      GoSub Apply
      if #result = #false
      goto _mainloop

      GoSub Waitnew
      wait 4
   }
}

goSub CheckStamina
sleep 10

goto _mainloop
;==========================================

;==========================================
; SUB WAITCURS
; ------------
; A questa sub si passano 1 o 2 argomenti.
; Il primo può essere 1 o 0. Sta ad indicare
; il valore di #targcurs desiderato.
; Il secondo, opzionale, indica un timeout in decimi
; di secondo. In ogni caso, per evitare che rimanga
; all'infinito, c'è un timeout di base di 100 secondi.

Sub WaitCurs

if %0 = 2
   set %waitTimeout #scnt2 + %2
else
   set %waitTimeout #scnt2 + 1000

while #targcurs <> %1
{
      if #scnt2 > %waitTimeout
      return #false

      sleep 5
}

if %1 = 0
   wait 2 ; per non far fizzare il target appena lanciato

return #true
;==========================================

;==========================================
; SUB CHECKAIDS
; -------------
; Controlla che ci siano bende nello zaino.
; Avverte se ne rimangono meno di 10.
; Mette lo script in attesa quando finiscono.
; Setta la variabile %aids.

Sub CheckAids

finditem ZLF CA_ , #BACKPACKID
if #findstack = 0
{
   menu delete EUOLabel1
   menu Font Color Lime
   menu Text EUOLabel1 125 8 Bende finite!
   wait 3s
   return #false
}

if #findstack < 10 && #findcnt < 2
   event sysmessage ATTENZIONE! Ti rimangono solo #findstack bende!

set %aids #findid

return #true
;==========================================

;==========================================
; SUB APPLY
; ---------
; NOTA: serve la variabile %aids.
; Questa sub benda il pg, facendo controlli
; di sicurezza per verificare che le bende siano state
; effettivamente applicate.

Sub Apply

_aidloop:
if yes in #charghost
   return #false

set %startIndex #jindex
wait %nextactiondelay
event macro 58
set %start #scnt2
wait 1
if you_begin_applying in #sysmsg
   return #true

GoSub WaitStartMsg 3
if #result <> 1
   return #false

return #true
;==========================================

;==========================================
; SUB WAITSTARTMSG
; ----------------
; Attende il messaggio di bendata.
; Vuole un argomento, il timeout in decimi di secondo.
; Restituisce 1 se benda, 0 se non è possibile bendare il pg,
; e -1 se le bende non entrano in azione completamente.

Sub WaitStartMsg

set %sysTimeout #scnt2 + %1

_waitsysmsgloop:
if #jindex > %startIndex
{
   set %startIndex %startIndex + 1
   scanjournal %startIndex

   if you_begin_applying in #journal
      return 1

   if that_being in #journal
      return 0

   goto _waitsysmsgloop
}

if #scnt2 < %sysTimeout
{
   sleep 5
   goto _waitsysmsgloop
}

return -1
;==========================================

;==========================================
; SUB WAITNEW
; ----------------
Sub WaitNew

set %keypressed 0
set %end %start + %delay
set %limitcure %end - 16
if %oldStyle
   set %oldremaining 140
else
   set %oldremaining 14
wait 2

set %scanindex #jindex

_waitloop:
if %counter
{
   if %oldStyle
   {
      set %remaining %end - #scnt2
      if %remaining < ( %oldremaining - 2 )
      {
         menu delete EUOLabel1
         menu Font Color Lime
         menu Text EUOLabel1 90 8 Bende: %remaining

         set %oldremaining %remaining
      }
   }
   else
   {
      set %remaining ( ( %end - #scnt2 ) / 10 )
      if %remaining <> %oldremaining
      {
         menu delete EUOLabel1
         menu Font Color Lime
         menu Text EUOLabel1 90 8 Tempo: %remaining
         set %oldremaining %remaining
         if %remaining = 0
         {
            menu delete EUOLabel1
            menu Font Color Lime
            menu Text EUOLabel1 90 8 Curato!
         }
      }
   }
   if %headcounter
   {
      if %remaining = 0
      {
          event ExMsg #charID 3 0 CURATO!
      }
      else
      {
          event ExMsg #charID 3 0 [Bendata: - , #spc , %remaining , ]
      }
   }
}

if D in #charstatus && %mortal = #false
{
   set %mortal #true
   set %mortend #scnt2 + %antimortal

   _mortloop:
   if ( ( %delay + #scnt2 ) > %mortend )
      return

   sleep 10
   goto _mortloop
}

wait 1

if C in #charstatus && %cure = #true && %hasCure = #true && H notin #charstatus
{
   if #scnt2 > %limitcure && %keypressed = 0
   {
   msg $
   wait 1
   msg %cureCmd $
   set %keypressed 1
   }
}

goSub CheckStamina

for %i #jindex %scanindex
{
    scanjournal %i
    if #scnt2 >= %end || You_finish_applying in #journal || You_apply_the in #journal || You_heal in #journal || the_bleeding in #sysmsg || You_have_failed in #sysmsg
    {
       if %mortal
          set %mortal #false
       return
    }
}
set %scanindex #jindex

wait 20
goto _waitloop

return ; giusto per essere sicuri
;==========================================

;==========================================
; SUB CHECKSTAMINA
; ----------------
Sub CheckStamina

if %refresh = #false || %hasRefresh = #false || H in #charstatus
   return

if ( #stamina < %stamina )
{
   if ( #scnt > ( %lastStamina + 3 ) )
   {
      set %lastStamina #scnt
      msg $
      wait 1
      msg %refCmd $
   }
}

return
;==========================================
