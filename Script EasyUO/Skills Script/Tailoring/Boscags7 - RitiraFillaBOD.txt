;========================================================
;* COME E' ORGANIZZATO LO SCRIPT
;*
;* Siccome questo è uno script piuttosto complesso, è necessario un minimo di progettazione delle varie sub.
;* Lo script si muove su vari livelli. I livelli superiori conoscono ed utilizzano quelli inferiori, ma non vice-versa.
;* Ciascuna funzione è identificata da un PREFISSO, che ne indica il livello di appartenenza.
;* Si può far finta che siano come dei package in Java.
;*
;* LIVELLI:
;* 1 - FUNZIONI ELEMENTARI (prefisso: Std)
;*     Sono sub che assolvono a compiti semplici e basilari, senza avere dipendenze da altre sub.
;*     Esso sono generalmente: "di basso livello", "riusabili", "rientranti" (non dipendono da variabili globali)
;* 2 - FUNZIONI LOGICHE (prefisso: Model)
;*     Implementano la logica dello script, senza curarsi di problemi di configurazione o simili.
;*     Obbediscono ad una logica "design by contract": pretendono delle pre-condizioni e garantiscono delle post-condizioni.
;*     Generalmente DIPENDONO da alcune variabili globali.
;*     Costituiscono la parte "model" di un'architettura Model-View-Controller.
;* 3 - FUNZIONI GRAFICHE (prefisso: View)
;*     Creano i menu e ne eseguono il loop.
;*     [...]
;* 4 - FUNZIONI ESECUTIVE (prefisso: Ctrl)
;*     Costituiscono il collegamento fra l'interfaccia grafica e le funzioni del livello logico.
;*     Spesso hanno nomi simili alle corrispondenti funzioni del livello logico, ma si collocano ad un livello più alto.
;*     Infatti, esse richiedono all'utente determinati parametri se ce n'è bisogno, e si occupano di avviare i loop.
;*     Si può pensare ad esse come a "TUTTO ciò che accade quando si preme un pulsante".
;*     Costituiscono la parte "controller" di un'architettura Model-View-Controller.
;*
;* Ci sono poi le FUNZIONI DI LIBRERIA, ovvero funzioni "importate" da altri script. Queste possono avere un qualsiasi
;* prefisso, ma generalmente si consiglia di assegnare loro un prefisso che ricordi la libreria da cui provengono.
;*
;*
;* IMPORTANTE!!! CONVENZIONE "SAFECALL" (chiamate sicure)
;* Tutto lo script segue la "convenzione safecall". "Safecall" è una sub che incapsula altre sub dentro dei namespace univoci.
;* Lo scopo di questa sub è quello di avvicinare lo scripting di easyuo ai tradizionali linguaggi di programmazione,
;* che prevedono uno scope distinto per ciascuna sub.
;*
;* Esempio: gosub safecall miaSub arg1 arg2 arg3
;* Questo tipo di chiamata si assicura che "miaSub" abbia uno spazio dei nomi riservato.
;* Di conseguenza, miaSub è sollevata dal noioso compito di dover dichiarare esplicitamente il suo namespace.
;*
;*
;* @version 2.0.1 final
;*
;* @todo Sostituire tutti i display/halt delle librerie di Boydon con diverso sistema di segnalazione errore.



;===========================================================================================
;* @name     Intestazione standard di inizio script.
;* @purpose  Si assicura che lo script possa essere richiamato anche dall'esterno,
;*           e che configuri correttamente i namespaces.
;*
;* @example  call NomeScript.txt           ; richiama lo script in modalità "standalone"
;*           call NomeScript.txt main      ; richiama la procedura principale dello script
;*           call NomeScript.txt nomesub   ; richiama una particolare sub dello script
;*                                         ; (per finalità di testing o di libreria)
;*
;* @warning  E' importante terminare lo script con gosub quit, anzichè con halt o exit!
;*

if %0 = !null
{
   namespace push
   namespace local ScriptName_standalone
   set !lpc #lpc
   set #lpc 500
   gosub _indirectInvokeEx 0 main
}
else
{
   namespace push
   namespace local ScriptName_reentrant
   set !lpc #lpc
   set #lpc 500
   if %0 = 0
   {
       gosub _indirectInvokeEx 0 main
   }
   else
   {
       set %0 ( %0 - 1 )
       gosub _indirectInvokeEx %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11
   }
}
gosub quit

sub quit
    while ( #nsname <> ScriptName_standalone ) && ( #nsname <> ScriptName_reentrant )
    {
        namespace clear
        namespace pop
    }
    if #nsname = ScriptName_standalone
    {
        halt
    }
    set #lpc !lpc
    namespace clear
    namespace pop
exit #result

;===============================================================================
;* @name     _indirectInvokeEx
;* @ver      1.0 (09/04/2009)
;* @author   AG
;* @purpose  Indirectly calls a specified sub, creating a namespace for it.
;*
;* @params   %1       req  number of arguments passed to the given sub
;* 				   %2       req  name of the sub to call
;* 				   %3...%12 opt  arguments to pass to the given sub (maximum of 10)
;* @returns                #result of the sub
;*
;* @example  gosub _indirectInvokeEx 3 mysub arg1 arg2 arg3
;* @status   Tested and working.
;*

sub _indirectInvokeEx ; %argc(of given sub) %subname %args[10]
    namespace push
    namespace local indirectInvoke_ , #systime , #random

    goto _indirectInvokeEx_ , %1

    ; si arriva qui solo se la label non è riconosciuta (numero args errato)
    event exmsg #charid 3 0 ATTENZIONE! Il numero degli argomenti di _indirectInvokeEx è errato ( %1 )! Lo script andrà in pausa.
    pause
    goto _indirectInvokeEx_out

    _indirectInvokeEx_0:
        gosub %2
        goto _indirectInvokeEx_out
    _indirectInvokeEx_1:
        gosub %2 %3
        goto _indirectInvokeEx_out
    _indirectInvokeEx_2:
        gosub %2 %3 %4
        goto _indirectInvokeEx_out
    _indirectInvokeEx_3:
        gosub %2 %3 %4 %5
        goto _indirectInvokeEx_out
    _indirectInvokeEx_4:
        gosub %2 %3 %4 %5 %6
        goto _indirectInvokeEx_out
    _indirectInvokeEx_5:
        gosub %2 %3 %4 %5 %6 %7
        goto _indirectInvokeEx_out
    _indirectInvokeEx_6:
        gosub %2 %3 %4 %5 %6 %7 %8
        goto _indirectInvokeEx_out
    _indirectInvokeEx_7:
        gosub %2 %3 %4 %5 %6 %7 %8 %9
        goto _indirectInvokeEx_out
    _indirectInvokeEx_8:
        gosub %2 %3 %4 %5 %6 %7 %8 %9 %10
        goto _indirectInvokeEx_out
    _indirectInvokeEx_9:
        gosub %2 %3 %4 %5 %6 %7 %8 %9 %10 %11
        goto _indirectInvokeEx_out
    _indirectInvokeEx_10:
        gosub %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12
        goto _indirectInvokeEx_out
    _indirectInvokeEx_out:

    namespace clear
    namespace pop
return #result

;===============================================================================
;* @name     _indirectCallEx
;* @ver      1.0 (05/04/2009)
;* @author   AG
;* @purpose  Indirectly calls a specified sub into the specified library, creating a namespace for it.
;*
;* @params   %1       req  number of arguments passed to the given sub
;* 				   %2       req  name of the library
;* 				   %3       req  name of the sub to call
;* 				   %4...%13 opt  arguments to pass to the given sub (maximum of 10)
;* @returns                #result of the sub
;*
;* @example  gosub _indirectCallEx 3 mylib mysub arg1 arg2 arg3
;* @status   Under testing.
;*

sub _indirectCallEx
    namespace push
    namespace local indirectCall_ , #systime , #random

    goto _indirectCallEx_ , %1

    ; si arriva qui solo se la label non è riconosciuta (numero args errato)
    event exmsg #charid 3 0 ATTENZIONE! Il numero degli argomenti di _indirectCallEx è errato! Lo script andrà in pausa.
    pause
    goto _indirectCallEx_out

    _indirectCallEx_0:
        call %2 %3
        goto _indirectCallEx_out
    _indirectCallEx_1:
        call %2 %3 %4
        goto _indirectCallEx_out
    _indirectCallEx_2:
        call %2 %3 %4 %5
        goto _indirectCallEx_out
    _indirectCallEx_3:
        call %2 %3 %4 %5 %6
        goto _indirectCallEx_out
    _indirectCallEx_4:
        call %2 %3 %4 %5 %6 %7
        goto _indirectCallEx_out
    _indirectCallEx_5:
        call %2 %3 %4 %5 %6 %7 %8
        goto _indirectCallEx_out
    _indirectCallEx_6:
        call %2 %3 %4 %5 %6 %7 %8 %9
        goto _indirectCallEx_out
    _indirectCallEx_7:
        call %2 %3 %4 %5 %6 %7 %8 %9 %10
        goto _indirectCallEx_out
    _indirectCallEx_8:
        call %2 %3 %4 %5 %6 %7 %8 %9 %10 %11
        goto _indirectCallEx_out
    _indirectCallEx_9:
        call %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12
        goto _indirectCallEx_out
    _indirectCallEx_10:
        call %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12 %13
        goto _indirectCallEx_out
    _indirectCallEx_out:

    namespace clear
    namespace pop
return #result

;==================================================================================
;* @name     safecall
;* @author   AG
;* @purpose  Simplified version of _indirectInvokeEx, for internal use by the script.
;*           Wraps a namespace around the given sub.
;*
;* @params   %1       req  name of the sub to call
;* 				   %2...%11 opt  arguments to pass to the given sub (maximum of 10)
;*
;* @returns  #result of the sub
;*
;* @example  gosub safecall mysub arg1 arg2 arg3
;* @status   Under testing.
;*

sub safecall
    set %0 %0 - 1
    gosub _indirectInvokeEx %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11
return #result

;==================================================================================
;* @name     libcall
;* @author   AG
;* @purpose  Indirectly invokes a library function.
;*           Can be modified to convert between statically and dynamically linked libraries,
;*           and also to convert symbolic library names into physical library names.
;* @params   %1       req  name of the library to call
;*           %2       req  name of the sub to call
;* 				   %3...%12 opt  arguments to pass to the given sub (maximum of 10)
;*
;* @returns  #result of the sub
;*
;* @example  gosub libcall mylib mysub arg1 arg2 arg3
;* @status   Tested and working.

sub libcall
    if %1 in BodFunctions.euo_CraftMenuFunctions.euo ; specify statically linked libraries
    {
       set %0 %0 - 2
       gosub _indirectInvokeEx %0 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11
       return #result
    }
    set %0 %0 - 2
    gosub _indirectCallEx %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 %11 %12
return #result



;==========================================================
;=
;=
;=    FUNZIONI ELEMENTARI (prefisso "Std")
;=
;=
;==========================================================

;===================================================================================
;* @name    DebugMessage
;* @author  AG
;* @purpose Displays a debug message if %debug = #true.
;* @params  The message to display (arguments will be concatenated, with a space between each couple).
;* @example gosub DebugMessage This is my message.
;*          DO NOT USE "SAFECALL" FOR THIS!!!
;* @status  Under testing.

sub DebugMessage
    namespace push
    namespace local DebugMessage , #systime , #random
    set %debug #true

    if %debug = #true
    {
        set !msg
        if %0 > 1
        {
           for !i 1 %0
           {
               set !arg % . !i
               set !msg !msg , !arg , #spc
           }
        }
        event exmsg #charid 3 1152 !msg
    }

    namespace clear
    namespace pop
return

;===================================================================================
;* @name    Std_OpenPaperdoll
;* @author  AG
;* @purpose Opens the paperdoll.
;* @example gosub safecall OpenPaperdoll
;* @status  Tested.

sub Std_OpenPaperdoll
	  event Macro 8 1 ; Open Paperdoll
	  set !timeout #systime + 5000
	  while #systime < !timeout && #contname <> paperdoll_gump
	  {
	  }
return #contname = paperdoll_gump

;===========================================================================
;* @name     Std_ReadProperty
;* @author   AG
;* @purpose  Legge in maniera sicura le proprietà di un item.
;*           Timeout di 1s.
;* @params   %1 req  ID dell'oggetto di cui leggere le proprietà.
;* @returns  Le proprietà dell'oggetto, oppure #false in caso di errore.
;* @example  gosub safecall Std_ReadProperty %item

sub Std_ReadProperty
    set !object %1
    set !timeout ( #systime + 1000 )

    set #property 0
    event property !object
    while #property = 0
    {
        if #systime > !timeout
           return #false
    }
return #property

;===========================================================================
;* @name     Std_MoveObject
;* @author   AG
;* @purpose  Sposta un oggetto da un contenitore ad un altro.
;*           Timeout di 2.5s.
;* @params   %1 req  ID dell'oggetto da spostare.
;*           %2 req  Contenitore di destinazione.
;*           %3 opt  Quantità da spostare. Se non specificato, sposta tutto.
;*           %4 opt  Coordinata x del punto in cui lasciare l'oggetto.
;*           %5 opt  Coordinata y del punto in cui lasciare l'oggetto.
;* @returns
;* @example  gosub safecall Std_MoveObject %object %destination %quantity %x %y

sub Std_MoveObject ; %id %dest %qty %x %y
    set !object %1
    set !dest %2
    if %0 < 3 || %3 = !null
        set !quantity all
    else
        set !quantity %3
    if %0 < 4 || !x = !null
        set !x random
    else
        set !x %4
    if %0 < 5 || !y = !null
        set !y random
    else
        set !y %5

    gosub safecall Std_ReadProperty !dest
    set !oldProperty #result
    
    if !quantity = all
       exEvent drag !object
    else
       exEvent drag !object !quantity

    if !x = random || !y = random
  	   exEvent dropc !dest
    else
       exEvent dropc !dest !x !y
    wait 10 ; minimum timeout

    set !timeout #systime + 2000
    while #systime < !timeout
    {
        gosub safecall Std_ReadProperty !dest
        if #result <> !oldProperty
           break
    }
return

;===========================================================================
;* @name     Std_UseObject
;* @author   AG
;* @purpose  Utilizza un oggetto, ed eventualmente seleziona un bersaglio per l'utilizzo.
;*           Timeout di 5s.
;* @params   %1 req  ID dell'oggetto da utilizzare.
;*           %2 opt  ID del bersaglio, oppure coordinata x del bersaglio.
;*           %3 opt  Coordinata y del bersaglio.
;*           %4 opt  Coordinata z del bersaglio.
;* @returns  #true se l'operazione va a buon fine, #false altrimenti.
;* @example  gosub safecall Std_UseObject %objectId %target_id
;*           gosub safecall Std_UseObject %objectId %target_x %target_y %target_z

sub Std_UseObject
    set !object %1
    if %0 < 2
       set !targetX !null
    else
       set !targetX %2
    if %0 < 3
       set !targetY !null
    else
       set !targetY %3
    if %0 < 4
       set !targetZ !null
    else
       set !targetZ %4

	  set #lobjectid !object
    event macro 17 ; LastObject
    if !targetId <> !null || !targetX <> !null
    {
        gosub safecall Std_SelectTarget !targetX !targetY !targetZ
    }
return #result

;===========================================================================
;* @name     Std_SelectTarget
;* @author   AG
;* @purpose  Seleziona in modo rapido un bersaglio.
;*           Timeout di 5s.
;* @params   %1 req  ID del bersaglio, oppure coordinata x del bersaglio.
;*           %2 opt  Coordinata y del bersaglio (obbligatoria se %1 specifica la coordinata x).
;*           %3 opt  Coordinata z del bersaglio.
;*           %4 opt  Override esplicito per #ltargetkind. @todo
;* @returns  #true se la selezione è riuscita correttamente. #false in caso di errore.
;* @example  gosub safecall Std_SelectTarget %target_id
;*           gosub safecall Std_SelectTarget %target_x %target_y %target_z

sub Std_SelectTarget ; %id_or_x %y %z
    set !type %0
    if !type >= 1 && %1 <> !null
    {
        if !type >= 2 && %2 <> !null
        {
            set #ltargetkind 2
            set #ltargetx %1
            set #ltargety %2
            if !type >= 3 && %3 <> !null
                set #ltargetz %3
        }
        else
        {
            set #ltargetkind 1
            set #ltargetid %1
        }
        set !timeout #systime + 5000
        while #systime < !timeout && #targcurs <> 1
        {
        }
        if #targcurs <> 1
           return #false
        event macro 22 ; LastTarget
           return  #true
    }
return #false

;=======================================
;* @name    Std_UseRunebook
;* @author  AG
;* @purpose Apre un runebook e lo utilizza.
;* @params  %1 req  ID del runebook.
;*          %2 req  Pulsante (recall, gate_travel, sacred_journey, drop_rune, set_default, use_scroll, rename_book, close)
;*          %3 req  Indice della runa (da 1 a 16)
;*
;* @example gosub safecall Std_UseRunebook %runebook recall 1
;*          gosub safecall Std_UseRunebook %runebook drop_rune 2
;*          gosub safecall Std_UseRunebook %runebook rename_book Casa

sub Std_UseRunebook ; %idRunebook, %pulsante, %indiceRuna
    set !timeout ( #systime + 5000 )
    set !idRunebook %1
    set !pulsante %2
    set !runa %3

    ; interpreta elasticamente il parametro pulsante
    if gate in !pulsante || travel in !pulsante
       set !pulsante gate_travel
    if journey in !pulsante || sacred in !pulsante
       set !pulsante sacred_journey
    if rename in !pulsante
       set !pulsante rename_book
    if drop in !pulsante || rune in !pulsante
       set !pulsante drop_rune
    if scroll in !pulsante || use in !pulsante
       set !pulsante use_scroll
    if default in !pulsante || set in !pulsante
       set !pulsante set_default

    ; chiudi runebook precedente se aperto
    while #contsize = 452_236
    {
        set !x #contposx + 200
        set !y #contposy + 50
        click !x !y r
        wait 2
    }

    ; apri il runebook
    set #lobjectid !idRunebook
    event macro 17    ; LastObject

    ; attendi apertura runebook
    while #systime < !timeout && #contsize <> 452_236
    {
    }
    if #contsize <> 452_236
       return #false

    ; gestisci ridenominazione runebook
    if !pulsante = rename_book
    {
        msg !runa , $
        return #true
    }
    
    ; cambia pagina
    set !page ( ( !runa - 1 ) / 2 ) + ( ( !runa - 1 ) / 8 )
    set !x ( #contposx + 140 + !page * 35 ) )
    set !y ( #contposy + 195 )
    click !x !y
    wait 1s ; sul mio pc va bene anche "wait 10"

    ; gestisci secondo click
    if ( !runa % 2 ) = 1            ; se la pagina è dispari
        set !x ( #contposx + 140 )  ;   setta x di conseguenza
    else                            ; altrimenti
        set !x ( #contposx + 300 )  ;   setta x di conseguenza
    if !pulsante = recall
        set !y ( #contposy + 145 )
    if !pulsante = gate_travel
        set !y ( #contposy + 162 )
    if !pulsante = sacred_journey
        set !y ( #contposy + 180 )
    if !pulsante = drop_rune
        set !y ( #contposy + 118 )
    if !pulsante = use_scroll
    {
        set !y ( #contposy + 70 )
        set !x ( !x - 5 )
    }
    if !pulsante = set_default
    {
        set !y ( #contposy + 25 )
        if ( !runa % 2 ) = 1
            set !x ( #contposx + 165 )
        else
            set !x ( #contposx + 305 )
    }
    click !x !y

    ; attendi eventuale spell
    if ( !pulsante = recall ) || ( !pulsante = gate_travel ) || ( !pulsante = sacred_journey ) || ( !pulsante = use_scroll ) || ( !pulsante = sacred_journey )
    {
        wait 2s
        wait 20
    }
    
    ; chiudi book se ancora aperto
    while #contsize = 452_236
    {
        set !x #contposx + 200
        set !y #contposy + 50
        click !x !y r
        wait 2
    }
return #true

;=======================================
;* @name    Std_SafeUseRunebook
;* @author  AG
;* @purpose Apre un runebook e lo utilizza. Se la posizione del PG non cambia, ripete il tentativo.
;* @params  %1 req  ID del runebook.
;*          %2 req  Pulsante (recall, gate_travel, sacred_journey, drop_rune, set_default, use_scroll, rename_book, close)
;*          %3 req  Indice della runa (da 1 a 16)
;*
;* @example gosub safecall Std_SafeUseRunebook %runebook recall 1

sub Std_SafeUseRunebook ; %idRunebook, %pulsante, %indiceRuna
    set !runebook %1
    set !mode %2
    set !index %3
    set !x #charposx
    set !y #charposy
    set !z #charposz
    set !timeout #systime + 10000
    gosub safecall Std_UseRunebook !runebook !mode !index ; per sicurezza, fai sempre almeno il primo
    while #systime < !timeout && !x = #charposx && !y = #charposy && !z = #charposz
    {
        gosub safecall Std_UseRunebook !runebook !mode !index
    }
return !x <> #charposx || !y <> #charposy || !z <> #charposz

;===========================================================================
;* @name     Std_CheckOverweight
;* @author   AG
;* @purpose  Verifica se il pg trasporta troppo peso (o troppi oggetti).
;* @params   %1 opt  Margine di sicurezza peso (default = 0)
;*                   La sub terrà conto di un margine di sicurezza ulteriore per determinare se il pg trasporta troppo peso.
;*           %2 opt  Margine di sicurezza numero di oggetti (default = 0)
;*                   La sub terrà conto di un margine di sicurezza ulteriore per determinare se il pg trasporta troppi oggetti.
;* @returns  #true se il pg trasporta troppo peso o troppi oggetti. #false altrimenti.
;* @example  gosub safecall Std_CheckOverweight 50 10

sub Std_CheckOverweight
    if %0 < 1 || %1 = !null
       set !weightMargin %1
    else
       set !weightMargin 0
    if %0 < 2 || %2 = !null
       set !itemsMargin %2
    else
       set !itemsMargin 0
       
    ; @todo aggiungere modificatore al peso per umani
    if #maxweight - #weight < !weightMargin
       return #true
       
    gosub safecall Std_ReadProperty #backpackid
    set !property #result
    str pos !property contents:
    set !index #strres + 9
    str del !property 1 !index
    set !property #strres
    str pos !property /
    set !index #strres - 1
    str left !property !index
    set !itemCount #strres
    if 125 - !itemCount < !itemsMargin
       return #true
return #false

;===========================================================================
;* @name     Std_GetObjectCount
;* @author   AG
;* @purpose  Conta il numero totale di oggetti rispetto ad un'istruzione finditem.
;* @params   %1 req  Istruzione finditem (esempi: "G_20" oppure "C_ , #backpackid").
;*           %2 req  Id dell'oggetto da cercare.
;*           %3 opt  Colore dell'oggetto da cercare.
;* @returns  Il numero totale di oggetti trovati.
;* @example  gosub safecall Std_GetObjectCount G_20 %objectType
;*           gosub safecall Std_GetObjectCount C_ , #backpackid %objectType %objectColor

sub Std_GetObjectCount
    set !findString %1
    set !id %2
    if %0 < 3 || %3 = !null
       set !color any
    else
       set !color %3
    
    set !count 0
    finditem !id !findString
    if #findkind <> -1
    {
        for #findindex 1 #findcnt
        {
            if !color <> any && !color <> #findcol
               continue
            set !count !count + #findstack
        }
    }
return !count

;===========================================================================
;* @name     Std_AskForTarget
;* @author   AG
;* @purpose  Richiede la selezione di un bersaglio all'utente.
;*           Timeout di 10s.
;* @params
;* @returns  ID del bersaglio selezionato, oppure #false se l'operazione fallisce.
;*           Le variabili #ltarget* restano riempite con informazioni sul bersaglio scelto.
;* @example  gosub safecall Std_AskForTarget
;*
sub Std_AskForTarget
    set !timeout #systime + 10000

    set #ltargetid 0
    set #targcurs 1
    while ( #systime < !timeout ) && ( #targcurs = 1 )
    {
    }
    if #systime >= !timeout
       return #false

    if ( #ltargetid <> YC ) && ( #ltargetid <> 0 ) && ( #ltargetid <> !null )
       return #ltargetid
return #false

;===========================================================================
;* @name     Std_ResetJournal
;* @author   AG
;* @purpose  Cancella il contenuto di un'istanza del journal.
;*           In termini pratici, determina l'istante di partenza da cui cominciare a monitorare il journal.
;* @params   %1 opt  Nome dell'istanza del journal da cancellare. Ciascuna istanza è indipendente dalle altre.
;* @example  Vedere la documentazione di Std_ScanJournal per un esempio di come usare congiuntamente le due sub.

sub Std_ResetJournal ; %instanceName
    namespace push
    namespace local Std_ScanJournal_Persistent
    if %0 < 1 || %1 = !null
        set !instance default
    else
        set !instance %1
    set !instances_ . !instance ( #jindex + 1 )
    namespace pop
return

sub Std_ClearJournal ; sinonimo
    if %0 < 1
       set %1 !null
    gosub Std_ResetJournal %1
return

;===========================================================================
;* @name     Std_ScanJournal
;* @author   AG
;* @purpose  Cerca un'insieme di stringhe in un'istanza del journal.
;* @params   %1      req  Nome dell'istanza del journal da cancellare. Ciascuna istanza è indipendente dalle altre.
;*           %2      req  Stringa da ricercare all'interno dell'istanza.
;*           %3...%n opt  Stringhe addizionali da ricercare all'interno dell'istanza.
;* @returns  La prima stringa che viene trovata nell'istanza, oppure #false se non ne viene trovata nessuna.
;*
;* @example  {
;*               gosub safecall Std_ResetJournal operation1
;*               <esegui l'operazione>
;*               gosub safecall Std_ScanJournal operation1 the_spell_fizzles
;*               if #result = the_spell_fizzles
;*                   <nel journal è comparsa la stringa the_spell_fizzles durante l'esecuzione dell'operazione>
;*           }

sub Std_ScanJournal ; %instanceName %string1 %string2 %string...
    namespace push
    namespace local Std_ScanJournal_Persistent
    if %0 < 1 || %1 = !null
        set !instance default
    else
        set !instance %1
    set !start !instances_ . !instance

    if !start <= #jindex
    {
        for !i !start #jindex
        {
            scanjournal !i
            for !j 2 %0
            {
                set !string % . !j
                if !string in #journal
                {
                   set #result !string
                   namespace pop
                   return #result
                }
            }
        }
    }
    namespace pop
return #false

;==================================================================================
;* @name     Std_GetWorldStatus
;* @author   AG
;* @purpose  Verifica se c'è un save o un cleaning in corso.
;* @returns  Uno dei seguenti valori:
;*           - cleaning:      Cleaning resources in corso.
;*           - saving:        Save in corso.
;*           - savewarning:   Sta per avvenire un save.
;*           - running:       Nessun save o clean in corso.
;* @example  gosub safecall Std_GetWorldStatus
;* @status   Tested and working.

sub Std_GetWorldStatus
    namespace push
    namespace local Std_GetWorldStatus_Persistent
    if !status = !null
    {
        set !jstart #jindex + 1
        set !status running
    }
    if !status = running
        set !restoreTime #systime + 60000

    set !jend #jindex
    if !jend >= !jstart
    {
        for !j !jend !jstart ; reverse scanning
        {
            scanjournal !j
            set !journal #journal
            set !newstate !null
            if world_will_save in !journal
                set !newstate savewarning
            if world_is_saving in !journal
                set !newstate saving
            if cleaning_resources in !journal
                set !newstate cleaning
            if world_save_complete in !journal
                set !newstate running
            if resources_cleaned in !journal
                set !newstate running
            if #systime > !restoreTime
            {
                event exmsg #charid 3 0 Il save sta durando troppo!
                set !newstate running
            }
            if !newstate <> !null
            {
                set !status !newstate
                break
            }
        }
        set !jstart !jend + 1
    }
    
    set #result !status
    namespace pop
return #result

;===========================================================================
;* @name     Std_OpenBankBox
;* @author   AG
;* @purpose  Semplice sub di utilità per aprire la bank-box.
;*           Timeout di 10s.
;* @params   %1 opt  ID di un banker nelle vicinanze.
;*                   Se viene specificato, si aprirà la bank usando "exevent popup" anzichè "msg bank$".
;* @returns  #true se l'operazione è andata a buon fine. #false altrimenti.
;* @example  gosub safecall Std_OpenBankBox

sub Std_OpenBankBox ; %banker
    if %0 < 1 || %1 = !null
       set !banker !null
    else
       set !banker %1

    if !banker = !null
       msg bank$
    else
       exevent popup !banker 2

    set !timeout #systime + 5000
    while #systime < !timeout && #contsize <> 180_240
    {
    }
return #contsize = 180_240

;===========================================================================
;* @name     Std_ClickGumpButton
;* @author   AG
;* @purpose  Clicca in maniera rapida e sicura sul bottone di un gump.
;*           Funziona con tutti quei gump che scompaiono brevemente quando si clicca su un pulsante
;*           (esempi: gump di crafting, gump di un bodbook).
;* @params   %1 req  Coordinata x del bottone rispetto al gump.
;*           %2 req  Coordinata y del bottone rispetto al gump.
;*           %3 opt  #contsize del gump. Se non specificata, si assume che sia la #contsize del gump corrente.
;* @returns  #true se l'operazione ha successo. #false altrimenti.
;* @example  gosub safecall Std_ClickGumpButton 10 20
;*           gosub safecall Std_ClickGumpButton 10 20 640_480
;* @status   Tested and working.

sub Std_ClickGumpButton ; %x %y %gump_size
    set !relX %1
    set !relY %2
    if %0 < 3 || %3 = !null
       set !contsize #contsize ; currently opened gump
    else
       set !contsize %3
    
    ; attendi comparsa del gump
    set !timeout #systime + 2000
    while #systime < !timeout && #contsize <> !contsize
    {
    }
    if #contsize <> !contsize
       return #false

    ; clicca
    set !x ( #contposx + !relX )
    set !y ( #contposy + !relY )
    click !x !y

    ; attendi scomparsa del gump
    set !timeout #systime + 1000 ; il gump sparisce anche in caso di lag
    while #systime < !timeout && #contsize = !contsize
    {
    }
    if #contsize = !contsize
       return #false
return #true

;===========================================================================
;* @name     Std_ExtractBod
;* @version  2.0
;* @author   AG
;* @purpose  Estrae in maniera sicura uno o più bod da un bodbook.
;* @params   %1 req  Bodbook da cui estrarre il bod.
;*           %2 opt  Numero di bod da estrarre. Disponibile dalla versione 2.0.
;*                   Si può specificare "all" per estrarli tutti. Il valore predefinito è 1.
;* @returns  Numero di bod estratti. Questo implica #false in caso di 0 bod estratti.
;*           La versione 1.0 restituiva l'id del singolo bod estratto.
;* @example  gosub safecall Std_ExtractBod %bodbookid
;*           gosub safecall Std_ExtractBod %bodbookid all

sub Std_ExtractBod
    set !clsBod EYM
    set !book %1
    if %0 < 2 || %2 = !null
       set !count 1
    else
       set !count %2
    if !count = all
       set !count 100000
    if !count <= 0
        return #false

    ; Apri il bodbook
    gosub safecall Std_UseObject !book
    set !timeout #systime + 3000
    while #contsize <> 615_454 && #systime < !timeout
    {
    }
    if #contsize <> 615_454 ; prova ancora
    {
        gosub safecall Std_UseObject !book
        set !timeout #systime + 3000
        while #contsize <> 615_454 && #systime < !timeout
        {
        }
        if #contsize <> 615_454
           return #false
    }

    ; Estrai per più volte il primo BOD della pagina
    for !i 1 !count
    {
        gosub safecall Std_ClickGumpButton 42 104 615_454
        if #result = #false ; try again
        {
            gosub safecall Std_ClickGumpButton 42 104 615_454
            if #result = #false
               break
        }
    }

    ; Chiudi il gump
    gosub safecall Std_ClickGumpButton 385 425 615_454
return !i - 1

;===========================================================================
;* @name     Std_AskNewBod
;* @author   AG
;* @purpose  Richiede un bod ad un vendor.
;*           Timeout di 5s.
;* @params   %1 req Vendor a cui chiedere il bod.
;* @returns  ID del bod chiesto al vendor, oppure #false se l'operazione non va a buon fine.
;* @example  gosub safecall Std_AskNewBod %vendorId

sub Std_AskNewBod ; %vendor
    set !vendor %1
    set !timeout ( #systime + 5000 )
    set !clsBod EYM

    gosub safecall Std_ResetJournal Std_AskNewBod
    exevent popup !vendor 4
    gosub safecall Std_CheckForBodRequestGump
    while ( #systime < !timeout ) && ( #result = #false )
    {
        ; fail-fast su "An offer may be available in..."
        gosub safecall Std_ScanJournal Std_AskNewBod offer_may_be_available
        if #result <> #false
           return #false

        gosub safecall Std_CheckForBodRequestGump
    }
    if #result = #false
       return #false

    set !x ( #contposx + 110 )
    str mid #contsize 5 3
    set !y ( #contposy + #strres - 25 )

    ignoreitem reset
    finditem !clsBod C_ , #backpackid
    if #findkind <> -1
    {
        for #findindex 1 #findcnt
        {
            ignoreitem #findid
        }
    }
    click !x !y

    set #result #false
    set !timeout #systime + 3000
    while #systime < !timeout
    {
        finditem !clsBod C_ , #backpackid
        if #findkind <> -1
        {
           set #result #findid
           break
        }
    }
    ignoreitem reset
return #result

;===========================================================================
;* @name     Std_RestockItem
;* @author   AG
;* @purpose  Cerca oggetti del tipo specificato nel container sorgente, e li sposta nel container di destinazione.
;*           Si ferma non appena nel container di destinazione si raggiunge una quantità di oggetti compresa fra min e max.
;* @params   %1 req  ID del tipo di oggetto da restockare.
;*           %2 req  Container sorgente (è possibile indicare anche containers multipli).
;*           %3 req  Container di destinazione.
;*           %4 req  Quantità minima da restockare.
;*           %5 opt  Quantità massima da restockare. Pari a %4 se non specificato.
;*           %6 opt  Colore dell'oggetto da cercare. Può essere "any" per indicare "qualsiasi colore".
;*           %7 opt  Settare a #true se si desidera lasciare sempre almeno 2 unità di un oggetto stackabile dentro il
;*                   container sorgente (così da non alterare eventuali posizionamenti definiti dall'utente).
;* @returns  #true se si riesce a restockare almeno la quantità minima (quindi anche se non si è riusciti a raggiungere
;*           la quantità massima).
;*           #false se l'operazione fallisce.
;* @example  gosub safecall Std_RestockItem %id %source %dest %reqQuantity %optQuantity %color
;* @depends  Std_MoveObject

sub Std_RestockItem ; %id %source %dest %reqQuantity %optQuantity %color %leave2
    set !id %1
    set !sources %2
    set !destination %3
    set !minQuantity %4
    if %0 < 5 || %5 = !null || %5 < !minQuantity
       set !maxQuantity !minQuantity
    else
       set !maxQuantity %5
    if %0 < 6 || %6 = !null
       set !color any
    else
       set !color %6
    set !preserveStack %0 >= 7 && %7 = #true

    ; conta items già a destinazione
    set !quantity 0
    finditem !id C_ , !destination
    if #findkind <> -1
    {
       for #findindex 1 #findcnt
       {
           if !color = any || !color = #findcol
           {
              set !quantity !quantity + #findstack
           }
       }
    }
    if !quantity >= !minQuantity
       return #true
       
    gosub safecall AG_Tokenize !sources _ Std_RestockItem_Array_
    if ! ( #result > 0 )
       return #false
    set !source_count #result

    for !i 1 !source_count
    {
        set !source %Std_RestockItem_Array_ . !i
        finditem !id C_ , !source
        if #findkind = -1
            continue

        for #findindex 1 #findcnt
        {
            if !quantity >= !maxQuantity
                return #true
            if !color <> any && !color <> #findcol
                continue

            set !item #findid
            set !stack #findstack
            if !preserveStack
            {
                if !stack >= 2
                   set !stack !stack - 2
                if !stack = 0
                   continue
            }
            if !stack > ( !maxQuantity - !quantity )
               set !stack ( !maxQuantity - !quantity )
            gosub safecall Std_MoveObject !item !destination !stack
            set !quantity !quantity + !stack
        }
        if !quantity >= !minQuantity
            return #true
    }
return !quantity >= !minQuantity

;=========================================================================
;* @name    Std_LoadPersistentVariables
;* @author  AG
;* @purpose Carica delle variabili rese persistenti in precedenza mediante Std_SavePersistentVariables.
;*          Le variabili vengono lette da CEO Filesystem, ed importate fra le variabili globali (%variabile).
;* @params  %1 req Lista variabili
;*          %2 opt Nome configurazione (default: current)
;*          %3 opt Separatore (default: |)
;* @example gosub safecall Std_LoadPersistentVariables variabile1|variabile2|variabile3
;*          gosub safecall Std_LoadPersistentVariables variabile1#variabile2#variabile3 #
;* @depends CEO_getGlobalVar, AG_Tokenize
;*
sub Std_LoadPersistentVariables
    set !list     %1
    set !scriptId Boscags7

    if %0 < 2 || %2 = !null
        set !config Current
    else
        set !config %2

    if %0 < 3 || %3 = !null
        set !sep |
    else
        set !sep %3

    gosub safecall AG_Tokenize !list !sep Temp_Array_
    set !count #result
    for !i 1 !count
    {
        set !localName %Temp_Array_ . !i
        set !outerName _ , #charid , _ , !config , _ , !localName
        gosub CEO_getGlobalVar !scriptId !outerName
        set % . !localName ( % . !outerName )
    }
return

;=========================================================
;* @name    Std_SavePersistentVariables
;* @author  AG
;* @purpose Rende persistenti una serie di variabili, di cui si forniscono i nomi.
;*          Le variabili vengono ricercate fra le variabili globali (%variabile) e salvate mediante CEO Filesystem.
;* @params  %1 req Lista variabili
;*          %2 opt Nome configurazione (default: current)
;*          %3 opt Separatore (default: |)
;* @example gosub safecall Std_SavePersistentVariables variabile1|variabile2|variabile3
;*          gosub safecall Std_SavePersistentVariables variabile1#variabile2#variabile3 #
;* @depends CEO_putGlobalVar, AG_Tokenize
;*
sub Std_SavePersistentVariables ; %list %configName %separator
    set !list     %1
    set !scriptId Boscags7

    if %0 < 2 || %2 = !null
        set !config Current
    else
        set !config %2

    if %0 < 3 || %3 = !null
        set !sep |
    else
        set !sep %3

    gosub safecall AG_Tokenize !list !sep Temp_Array_
    set !count #result
    for !i 1 !count
    {
        set !localName %Temp_Array_ . !i
        set !outerName _ , #charid , _ , !config , _ , !localName
        set % . !outerName ( % . !localName )
        gosub CEO_putGlobalVar !scriptId !outerName
    }
return

;=======================================
;* @name    Std_Pathfind
;* @author  AG (original code by Scorna)
;* @purpose Raggiunge la posizione specificata.
;*          Timeout di 10s. Comportamento fail-fast in caso di punto non raggiungibile.
;* @params  %1 req  Coordinata x del punto da raggiungere.
;*          %2 req  Coordinata y del punto da raggiungere.
;*          %3 opt  Coordinata z del punto da raggiungere. Se non indicata, il check avverrà solo su #charposx e #charposy.
;*          %4 opt  Tolleranza rispetto al punto da raggiungere.
;* @returns #true se il punto è stato raggiunto. #false altrimenti.
;*
;* @example gosub safecall Std_Pathfind !x !y !z 2

sub Std_Pathfind
    set !x %1
    set !y %2
    if %0 < 3 || %3 = !null
       set !z !null
    else
       set !z %3
    if %0 < 4 || %4 = !null
       set !tolerance 0
    else
       set !tolerance %4
    set !timeout ( #systime + 10000 )
    
    set !xmin !x - !tolerance
    set !xmax !x + !tolerance
    set !ymin !y - !tolerance
    set !ymax !y + !tolerance
    set !zmin !z - !tolerance
    set !zmax !z + !tolerance

    while #systime < !timeout
    {
        if ( #charposx >= !xmin && #charposx <= !xmax ) &&
         + ( #charposy >= !ymin && #charposy <= !ymax ) &&
         + ( !z = !null || ( #charposz >= !zmin && #charposz <= !zmax ) )
            return #true

        set !inizioj #jindex + 1
        if !z = !null
           event PathFind !x !y
        else
           event PathFind !x !y !z
        for !j !inizioj #jindex
        {
           scanjournal !j
           if Can't_get_there in #journal || That_location_is_blocked in #journal
           {
              deletejournal
              return #false
           }
        }
        wait 1s
    }
return #false

;=======================================
;* @name    Std_SmartPathfind
;* @author  AG (original code by Scorna)
;* @purpose Raggiunge la posizione specificata, eseguendo anche operazioni "intelligenti" (tipo aprire le porte).
;* @params  %1 req  Coordinata x del punto da raggiungere.
;*          %2 req  Coordinata y del punto da raggiungere.
;*          %3 opt  Coordinata z del punto da raggiungere. Se non indicata, il check avverrà solo su #charposx e #charposy.
;*          %4 opt  Tolleranza rispetto al punto da raggiungere.
;* @returns #true se il punto è stato raggiunto. #false altrimenti.
;*
;* @example gosub safecall Std_SmartPathfind !x !y !z 2

sub Std_SmartPathfind
;    vecchi id, correttamente funzionanti
;    set !clsDoor XG_ZG_TG_VG_FH_HH_BH_DH_AY_ZX_CY_BY_
;      +XGB_ZGB_JHB_LHB_FHB_HHB_RHB_THB_NHB_PHB_ZHB_BIB_VHB_XHB_HIB_JIB_DIB_FIB_PIB_RIB_LIB_NIB_ZDB_BEB_VDB_XDB_HEB_
;      +JEB_DEB_FEB_PEB_REB_LEB_NEB_XEB_ZEB_TEB_VEB_FFB_HFB_FJC_IJC_HJC_SJC_RJC_UJC_TJC_OJC_NJC_QJC_PJC_YOC_XOC_APC_
;      +ZOC_UOC_TOC_WOC_VOC_GPC_FPC_IPC_HPC_CPC_BPC_EPC_DPC_OPC_NPC_QPC_PPC_KPC_JPC_MPC_LPC_WPC_VPC_YPC_XPC_SPC_RPC_
;      +UPC_TPC_EQC_DQC_GQC_FQC_AQC_ZPC_CQC_BQC_MQC_LQC_OQC_NQC_IQC_HQC_KQC_JQC_UQC_TQC_WQC_VQC_QQC_PQC_SQC_RQC_CRC_
;      +BRC_ERC_DRC_YQC_XQC_ARC_ZQC_MMC_LMC_OMC_NMC_IMC_HMC_KMC_JMC_UMC_TMC_WMC_VMC_QMC_PMC_SMC_RMC_CNC_BNC_ENC_DNC_
;      +YMC_XMC_ANC_ZMC_KNC_JNC_MNC_LNC_GNC_FNC_INC_HNC_SNC_RNC_UNC_TNC_ONC_NNC_QNC_PNC_AOC_ZNC_COC_BOC_WNC_VNC_YNC_
;      +XNC_IOC_HOC_KOC_JOC_EOC_IPJ_HPJ_RPL_UPL_TPL_OPL_NPL_QPL_PPL_AQL_ZPL_CQL_BQL_WPL_VPL_YPL_XPL_IQL_HQL_KQL_JQL_
;      +EQL_DQL_GQL_FQL_QQL_PQL_SQL_RQL_MQL_LQL_OQL_NQL_YQL_XQL_ARL_ZQL_UQL_ZZL_CAM_BAM_MAM_LAM_OAM_NAM_IAM_HAM_KAM_
;      +JAM_UAM_TAM_WAM_VAM_QAM_FUN_QUN_PUN_SUN_RUN_MUN_GRO_IRO_EWP_DWP_KWP_JWP_HAQ_KAQ_JAQ_UAQ_TAQ_WAQ_VAQ_QAQ_PAQ_
;      +SAQ_RAQ_CBQ_BBQ_EBQ_DBQ_YAQ_XAQ_ABQ_ZAQ_KBQ_JBQ_MBQ_LBQ_GBQ_SCR_PCR_NXS_OXS_VCR_QCR_PXS_QXS_

;   nuovi id, non ancora testati
    set !clsDoor _
      +XG_ZG_TG_VG_FH_HH_BH_DH_AY_ZX_CY_BY_XGB_ZGB_JHB_LHB_FHB_HHB_RHB_
      +THB_NHB_PHB_ZHB_BIB_VHB_XHB_HIB_JIB_DIB_FIB_PIB_RIB_LIB_NIB_ZDB_
      +BEB_VDB_XDB_HEB_JEB_DEB_FEB_PEB_REB_LEB_NEB_XEB_ZEB_TEB_VEB_FFB_
      +HFB_FJC_IJC_HJC_SJC_RJC_UJC_TJC_OJC_NJC_QJC_PJC_YOC_XOC_APC_ZOC_
      +UOC_TOC_WOC_VOC_GPC_FPC_IPC_HPC_CPC_BPC_EPC_DPC_OPC_NPC_QPC_PPC_
      +KPC_JPC_MPC_LPC_WPC_VPC_YPC_XPC_SPC_RPC_UPC_TPC_EQC_DQC_GQC_FQC_
      +AQC_ZPC_CQC_BQC_MQC_LQC_OQC_NQC_IQC_HQC_KQC_JQC_UQC_TQC_WQC_VQC_
      +QQC_PQC_SQC_RQC_CRC_BRC_ERC_DRC_YQC_XQC_ARC_ZQC_MMC_LMC_OMC_NMC_
      +IMC_HMC_KMC_JMC_UMC_TMC_WMC_VMC_QMC_PMC_SMC_RMC_CNC_BNC_ENC_DNC_
      +YMC_XMC_ANC_ZMC_KNC_JNC_MNC_LNC_GNC_FNC_INC_HNC_SNC_RNC_UNC_TNC_
      +ONC_NNC_QNC_PNC_AOC_ZNC_COC_BOC_WNC_VNC_YNC_XNC_IOC_HOC_KOC_JOC_
      +EOC_IPJ_HPJ_RPL_UPL_TPL_OPL_NPL_QPL_PPL_AQL_ZPL_CQL_BQL_WPL_VPL_
      +YPL_XPL_IQL_HQL_KQL_JQL_EQL_DQL_GQL_FQL_QQL_PQL_SQL_RQL_MQL_LQL_
      +OQL_NQL_YQL_XQL_ARL_ZQL_UQL_ZZL_CAM_BAM_MAM_LAM_OAM_NAM_IAM_HAM_
      +KAM_JAM_UAM_TAM_WAM_VAM_QAM_FUN_QUN_PUN_SUN_RUN_MUN_GRO_IRO_EWP_
      +DWP_KWP_JWP_HAQ_KAQ_JAQ_UAQ_TAQ_WAQ_VAQ_QAQ_PAQ_SAQ_RAQ_CBQ_BBQ_
      +EBQ_DBQ_YAQ_XAQ_ABQ_ZAQ_KBQ_JBQ_MBQ_LBQ_GBQ_SCR_PCR_NXS_OXS_VCR_
      +QCR_PXS_QXS_WBD_YBD_KBD_MBD_SBD_UBD_ECD_GCD_RFD_TFD_VFD_XFD_FBD_
      +HBD_BBD_DBD_GFD_IFD_UED_WED_CFD_EFD_OFD_QFD_GBS_CXS_MBS_EXS_XCR_
      +YXS_DDR_WXS_RCR_MXS_BDR_KXS_UXS_SXS_WBR_MBR_YEB_AFB_MEB_OEB_UEB_
      +WEB_GFB_IFB_IEB_KEB_WDB_YDB_EEB_GEB_QEB_SEB_QIB_SIB_EIB_GIB_MIB_
      +OIB_AEB_CEB_AIB_CIB_OHB_QHB_WHB_YHB_IIB_KIB_WCD_QCD_KCD_UCD_SCD_
      +CDD_EDD_YCD_TTU_DUU_XTU_RTU_FUU_ZTU_BUU_LUU_VTU_LTU_JTU_PTU_DOU_
      +JOU_NTU_FOU_

    set !x %1
    set !y %2
    if %0 < 3 || %3 = !null
       set !z !null
    else
       set !z %3
    if %0 < 4 || %4 = !null
       set !tolerance 0
    else
       set !tolerance %4
    set !timeout ( #systime + 20000 )

    ignoreitem reset
    while #systime < !timeout
    {
        gosub safecall Std_Pathfind !x !y !z !tolerance
        if #result = #true
        {
           ignoreitem reset
           return #true
        }

        ; fallimento: tenta operazioni intelligenti
        finditem !clsDoor G_15
        if #findkind = -1
           break ; fallimento completo

        set !door_dist 1000
        for #findindex 1 #findcnt
        {
            if #finddist >= !door_dist
               continue
            set !door_dist #finddist
            set !door_id #findid
            set !door_x #findx
            set !door_y #findy
            set !door_z #findz
        }

        gosub safecall Std_Pathfind !door_x !door_y !door_z 1
        if #result = #false
           break
           
        gosub safecall Std_UseObject !door_id
        wait 1s
        
        finditem !clsDoor G_2 ; escludi le door nelle vicinanze (presumibilmente aperte)
        for #findindex 1 #findcnt
        {
            ignoreitem #findid
        }
    }
    
    ignoreitem reset
return #false

;====================================================================
;* @name    Std_RecycleItems
;* @author  AG
;* @purpose Ricicla un gruppo di oggetti. Gli oggetti vengono riciclati tutti secondo UNO STESSO METODO.
;*          La sub ignora tutti gli oggetti insured o blessed.
;*          La sub ignora gli oggetti di tipo cloth nel caso in cui il metodo sia cut (si produrrebbero bandages).
;*
;* @params  %1 req  Specifica gli oggetti da riciclare.
;*                  Nella stessa lista, si possono specificare sia ID di oggetti che ID di tipi di oggetto.
;*          %2 req  Metodo di riciclaggio (smelt|cut|combine).
;*                  Se si specifica un metodo non valido, non verrà effettuato nessun riciclaggio, e verrà semplicemente
;*                  restituita la lista di tutti gli item, filtrata in base ai criteri di sicurezza (esclusione di oggetti
;*                  blessed e insured, eccetera).
;*          %3 opt  Restringe la ricerca di item da riciclare al solo container specificato.
;* @returns Elenco degli oggetti che NON si è riusciti a riciclare.
;*          Se l'elenco è vuoto, il risultato è pari a "_".
;*
;* @example gosub safecall Std_RecycleItems !items smelt
;* @depends CraftMenuFunctions.euo

sub Std_RecycleItems ; %list %method %container
    set !list %1
    set !method %2
    if %0 < 3 || %3 = !null
        set !searchString C
    else
        set !searchString C_ , %3
    set !cloth BUI
    set !cutUpCloth CUI
    set !craftContSize 530_437    ;530_437
    set !result _
    
    gosub safecall AG_Tokenize !list _ Std_RecycleItems_Array_
    set !count #result
    if !count < 1
       return !result

    set !itemCount 0
    set !items _
    for !i 1 !count
    {
        set !item_or_type %Std_RecycleItems_Array_ . !i
        finditem !item_or_type !searchString
        if #findkind = -1
           continue
           
        for #findindex 1 #findcnt
        {
            set !item #findid
            
            ; check di sicurezza
            gosub safecall Std_ReadProperty !item
            set !property #result
            if blessed in !property || insured in !property
               continue
            if ( !method = cut ) && ( #findtype = !cloth || #findtype = !cutUpCloth )
               continue

            set !itemCount !itemCount + 1
            set !item . !itemCount !item
            set !items !items , !item , _
        }
    }
    if !itemCount < 1
       return !result
    ; le liste vengono riempite correttamente (già testate)

    if !method = cut
    {
        finditem KAG C_ , #backpackid
        if #findkind = -1
        {
           finditem KTL C_ , #backpackid
           if #findkind = -1
              return !items
           set !tinkersTools #findid
           
           gosub safecall Std_CraftItem !tinkersTools iron 2 1
           finditem KAG C_ , #backpackid
           if #findkind = -1
              return !items
        }
        set !scissors #findid
        
        for !i 1 !itemCount
        {
            set !item !item . !i
            gosub safecall Std_UseObject !scissors !item
            wait 10
        }
    }
    if !method = smelt
    {
       ; Lo smeltaggio non consuma cariche del tool! Basta un tool solo!
       if #contsize = !craftContSize
           gosub safecall Std_ClickGumpButton 25 415 !craftContSize ; exit
		   gosub libcall CraftMenuFunctions.euo BringUpCraftMenu smith #false
		   if #result = x
          return !items
          
       for !i 1 !itemCount
       {
           set !item !item . !i
           gosub safecall Std_ClickGumpButton 25 355 !craftContSize ; smelt
           gosub safecall Std_SelectTarget !item
       }
       set !closeCraftGump #true
    }
    if !method = combine ; cut-up cloth (@todo includere check per colori multipli?)
    {
       if #contsize = !craftContSize
           gosub safecall Std_ClickGumpButton 25 415 !craftContSize ; exit
		   gosub libcall CraftMenuFunctions.euo BringUpCraftMenu tailor #false
		   if #result = x
          return !items
       gosub libcall CraftMenuFunctions.euo CraftAnything 1 2
       set !closeCraftGump #true
    }

    if !closeCraftGump = #true
        gosub safecall Std_ClickGumpButton 25 415 !craftContSize ; exit

    ; verifica quali elementi NON sono stati riciclati
    for !i 1 !itemCount
    {
        set !item !item . !i
        finditem !item !searchString
        if #findkind <> -1
           set !result !result , !item , _
    }
return !result

;=======================================
;* @name    Std_CraftItem
;* @author  AG
;* @purpose Crafta un oggetto a partire da un tool, un materiale, e due pulsanti da premere.
;*          Per ogni parametro è possibile specificare il valore "last" (che è il predefinito).
;*          In quel caso, le operazioni collegate a quel parametro verranno saltate.
;* @params  %1 opt  ID del tool da usare.
;*                  @todo: Si può specificare un tool in particolare, oppure solo il tipo di tool.
;*                  @todo: E' anche possibile specificare soltanto il nome della skill correlata (smith, tailoring, etc)
;*                  Se si specifica "last", si assume che il menu di crafting sia già attivo e si procede solo a premere i pulsanti.
;*          %2 opt  Materiale da utilizzare. E' possibile specificare un valore di colore, oppure un nome di materiale a scelta tra:
;*                  iron, dull, shadow, copper, bronze, gold, agapite, verite, valorite, leather, spined, horned, barbed.
;*                  Se si specifica "last", si assume che il materiale corretto sia già selezionato.
;*          %3 opt  Primo pulsante da premere per craftare l'oggetto. E' il pulsante che indica la "categoria" dell'oggetto
;*                  (in pratica, uno dei pulsanti sulla sinistra).
;*                  Se si specifica "last", lo script premerà semplicemente "Make Last".
;*          %4 opt  Secondo pulsante da premere per craftare l'oggetto. E' il pulsante che indica l'oggetto all'interno della
;*                  sua categoria (in pratica, uno dei pulsanti sulla destra).
;*                  Se si specificano valori maggiori di 10, lo script premerà automaticamente "Next Page" tutte le volte necessarie.
;* @returns #true se l'operazione va a buon fine (non indica necessariamente un craft riuscito).
;*          #false se si verificano malfunzionamenti.
;*
;* @example gosub safecall Std_CraftItem !smithTool !materialColor 2 3  ; apre il gump, seleziona il materiale e crafta l'oggetto
;*          gosub safecall Std_CraftItem !sewingKit last last last      ; preme "Make Last" dopo aver aperto il gump
;*          gosub safecall Std_CraftItem last last last last            ; preme semplicemente "Make Last" su un gump già aperto
;*
;* @depends CraftMenuFunctions.euo
;* @status  Incompleta. Ciò che è già implementato funziona correttamente.

sub Std_CraftItem ; %tool %material %button1 %button2 (valori predefiniti: last)
    if %0 < 1 || %1 = !null || %1 = current
       set !tool last
    else
       set !tool %1

    if %0 < 2 || %2 = !null || %2 = current
       set !material last
    else
       set !material %2

    if %0 < 3 || %3 = !null || %3 = current
       set !button1 last
    else
       set !button1 %3

    if %0 < 4 || %4 = !null || %4 = current
       set !button2 last
    else
       set !button2 %4

    if %0 < 5 || %5 <> #true
       set !checked #false
    else
       set !checked #true

    if !tool <> last
    {
       finditem !tool C
       if #findkind = -1
          return #false
       set !tool #findid

       gosub safecall Std_OpenPaperdoll
       wait 10
       set !timeout #systime + 5000
       gosub safecall Std_UseObject !tool
       while #systime < !timeout && #contsize <> 530_437 ; 530_437 attendi il nuovo gump
       {
       }
    }

    if #contsize <> 530_437    ; 530_437
       return #false

    if !material <> last
    {
       gosub libcall CraftMenuFunctions.euo ChooseMaterial !material
    }

    set !jStart #jIndex + 1
    if !button1 <> last && !button2 <> last
        gosub libcall CraftMenuFunctions.euo CraftAnything !button1 !button2
    else
        gosub libcall CraftMenuFunctions.euo ClickMakeLast

    ; attendi il ritorno del gump dopo il craft
    set !timeout #systime + 5000
    while #systime < !timeout && #contsize <> 530_437   ; 530_437
    {
        if !jStart <= #jindex
        {
           scanjournal !jStart
           if you_have_worn_out_your_tool in #journal
              break
           set !jStart !jStart + 1
        }
    }
return #true

;====================================================================
;* @name    Std_SearchForCraftedItems
;* @author  AG
;* @purpose Routine di supporto per Std_FillSmallBod

sub Std_SearchForCraftedItems ; %type %color %exceptional %listName
    set !type %1
    if %0 < 2 || %2 = !null
       set !color any
    else
       set !color %2
    if %0 < 3 || %3 = !null
       set !exceptional #false
    else
       set !exceptional %3
    if %0 < 4 || %4 = !null
       set !listName !null
    else
       set !listName %4

    set !count 0
    finditem !type C_ , #backpackid
    if #findkind <> -1
    {
        for #findindex 1 #findcnt
        {
            gosub safecall Std_ReadProperty #findid
            set !property #property
            if Blessed in !property || Insured in !property || Arcane in !property
               continue
            if !exceptional && Exceptional notin !property
               continue
               
            if !color <> any
            {
                if !type in PPH_WPH_QPH_BQH_AQH_VPH_ZPH_YPH_CQH
                {
                    if !color = 0 && ( Spined in !property || Horned in !property || Barbed in !property )
                       continue
                    if !color = 2220 && Spined notin !property
                       continue
                    if !color = 2117 && Horned notin !property
                       continue
                    if !color = 2129 && Barbed notin !property
                       continue
                }
                else
                {
                    if !color <> #findcol
                       continue
                }
            }

            set !count !count + 1
            if !listName <> !null
            {
               set !temp !listName , !count
               set % . !temp #findid
            }
        }
    }
return !count

;====================================================================
;* @name    Std_FillSmallBod
;* @author  AG
;* @purpose Tenta di riempire uno small bod, utilizzando SOLO le risorse all'interno del backpack.
;*          Se alcuni item sono già disponibili, evita di craftarne in eccesso.
;*          Se non si può proseguire, inserisce gli item craftati dentro il bod e ritorna un codice di errore.
;*
;* @params  %1 req  ID del bod per il quale craftare oggetti.
;*          %2 opt  ID di un dying tub nelle vicinanze, o nel backpack, in caso di cloth colorati.
;*
;* @returns #true se TUTTI gli oggetti vengono craftati ed inseriti con successo.
;*          Un codice di errore tra i seguenti se il riempimento fallisce:
;*          - bod_is_large        se il bod è large
;*          - not_enough_material se non ci sono abbastanza risorse
;*          - not_enough_bones    se non ci sono abbastanza ossa
;*          - not_enough_tools    se sono stati consumati tutti i tool per craftare
;*          - unexpected_error    se avviene un errore non previsto
;*
;* @example gosub safecall Std_FillSmallBod !bod
;* @depends Numerosissime dipendenze...
;* @status  Partially tested

sub Std_FillSmallBod
    set !bod %1
    set !tub %2
    set !bones_id GUF
    set !tailorTools HAG
    set !smithTools TLH_FBG_GBG_OLH_OBG_TBG

    ;--------------------------------------
    ; Fase 1: analisi e configurazione
    ;--------------------------------------

    gosub libcall BodFunctions.euo analyzeBod !bod Std_FillSmallBod_Bod_ obmqc
    if #result <> #true
       return unexpected_error

    set !large %Std_FillSmallBod_Bod_Large
    if !large
       return bod_is_large

    set !tailor %Std_FillSmallBod_Bod_Tailor
    set !exceptional %Std_FillSmallBod_Bod_Exceptional
    set !material_name %Std_FillSmallBod_Bod_MaterialName
    set !material_id %Std_FillSmallBod_Bod_MaterialId
    set !material_color %Std_FillSmallBod_Bod_MaterialColor
    set !items_id %Std_FillSmallBod_Bod_ItemId
    set !items_color !material_color
    set !items_required %Std_FillSmallBod_Bod_Quantity - %Std_FillSmallBod_Bod_FillCount
    set !craftButton1 %Std_FillSmallBod_Bod_CraftButton1
    set !craftButton2 %Std_FillSmallBod_Bod_CraftButton2

    if !tailor
    {
        if !material_name = cloth
        {
            set !material_required %Std_FillSmallBod_Bod_Cloth
            set !material_id !material_id , _CUI              ; aggiungi cut cloth
        }
        else
        {
            set !material_required %Std_FillSmallBod_Bod_Hides
        }
        set !bones_required %Std_FillSmallBod_Bod_Bones
        set !tools_id !tailorTools
    }
    else
    {
        set !material_required %Std_FillSmallBod_Bod_Ingots
        set !tools_id !smithTools
    }

    ;--------------------------------------
    ; Fase 2: Creazione degli items
    ;--------------------------------------

    while #true
    {
        ; cerca items già pronti
        gosub safecall Std_SearchForCraftedItems !items_id !material_color !exceptional
        set !items_available #result
        if !items_available >= !items_required
        {
            set !result #true
            break
        }

        ; procedura di sicurezza contro colored cloths
        if !material_name = cloth
        {
            finditem !material_id C_ , #backpackid
            if #findkind <> -1
            {
                for #findindex 1 #findcnt
                {
                    if #findcol <> 0
                    {
                        gosub safecall Yeld ; @note: teoricamente non si dovrebbe fare da dentro il livello Std
                        if !tub <> !null
                            gosub Std_UseObject !tub #findid
                        else
                            set !result cannot_dye_cloth
                    }
                }
            }
            if !result = cannot_dye_cloth
               break
        }
        
        ; cerca materiale
        gosub safecall Std_GetObjectCount C_ , #backpackid !material_id !material_color
        set !material_available #result
        if !material_available < !material_required
        {
           set !result not_enough_material
           break
        }

        ; cerca ossa
        if !bones_required <> 0
        {
            gosub safecall Std_GetObjectCount C_ , #backpackid !bones_id
            set !bones_available #result
            if !bones_available < !bones_required
            {
               set !result not_enough_bones
               break
            }
        }

        ; cerca tool
        set !currentTool !null
        finditem !tools_id C_ , #backpackid
        if #findkind <> -1
        {
            for #findindex 1 #findcnt
            {
                if #findcol <> 0 ; ignora kit runici
                    continue
                set !currentTool #findid
                break
            }
        }
        if !currentTool = !null
        {
            set !result not_enough_tools
            break
        }
        
        ; Crafting degli items
        gosub safecall Yeld ; @note: teoricamente non si dovrebbe fare da dentro il livello Std
        gosub safecall Std_CraftItem !currentTool !material_color !craftButton1 !craftButton2
        set !loopCount ( !items_required - !items_available - 1 )
        if !loopCount < 1
           continue

        for !i 1 !loopCount
        {
            gosub safecall Yeld ; @note: teoricamente non si dovrebbe fare da dentro il livello Std
            gosub safecall Std_CraftItem last last last last
        }
    }
    
    ; dismiss gump
    set !timeout #systime + 2000
    while #systime < !timeout && #contsize = 530_437  ; 530_437
    {
        gosub safecall Std_ClickGumpButton 25 415 530_437   ; 530_437
    }

    ;--------------------------------------
    ; Fase 3: Inserimento items nel bod
    ;--------------------------------------

    gosub safecall Std_SearchForCraftedItems !items_id !items_color !exceptional Temp_Array_
    set !items_available #result
    if !items_available > !items_required
       set !items_available !items_required
    if !items_available > 0
    {
        gosub safecall Yeld ; @note: teoricamente non si dovrebbe fare da dentro il livello Std
        gosub safecall Std_UseObject !bod
        gosub safecall Std_WaitForBodGump
        if #result = #false
           return #false
        gosub safecall Std_ClickBodGumpButton fill ; 135 205

        ; insert all the items
        gosub safecall Yeld ; @note: teoricamente non si dovrebbe fare da dentro il livello Std
        for !i 1 !items_available
        {
            set !item %Temp_Array_ . !i
            gosub safecall Std_SelectTarget !item
        }
        
        ; dismiss gump
        set !timeout #systime + 2000
        gosub safecall Std_CheckForBodGump
        while #systime < !timeout && #result = #true
        {
            gosub safecall Std_ClickBodGumpButton exit
            gosub safecall Std_CheckForBodGump
        }
        if #targcurs = 1
            set #targcurs 0
    }
return !result

;=======================================
;* @name    Bod Gump functions
;* @author  AG
;* @purpose Varie sub per gestire i gump dei BOD.
;* @todo    Descrizioni individuali.

sub Std_CheckForBodGump
return 510_ in #contsize || 524_ in #contsize || 499_ in #contsize || 467_ in #contsize

sub Std_CheckForBodRequestGump
return 460_ in #contsize || 524_ in #contsize || 499_ in #contsize || 467_ in #contsize

sub Std_WaitForBodGump
    set !timeout #systime + 5000
    gosub safecall Std_CheckForBodGump
    while #systime < !timeout && #result = #false
    {
        gosub safecall Std_CheckForBodGump
    }
return #result

sub Std_ClickBodGumpButton ; %button
    set !offsetY -20
    if %0 >= 1 && %1 = fill
       set !offsetY 0
    if %0 >= 1 && %1 = exit
       set !offsetY 20

    gosub safecall Std_WaitForBodGump
    if #result = #false
       return #false

    str right #contsize 3
    set !height #strres
    set !y !height - 70 + !offsetY
    gosub safecall Std_ClickGumpButton 140 !y
return #result

;=======================================
;* @name    Std_SetBodbookFilter
;* @author  AG
;* @purpose Imposta il filtro di un bodbook.
;*          Questa implementazione richiama semplicemente la sub SetBodbookFilter di BodFunctions.euo.
;* @params  %1 opt  Identificatore del bodbook.
;*          %2 opt  Filtro per dimensione (all, small, large, last).
;*          %3 opt  Filtro per qualità (all, normal, exceptional, last).
;*          %4 opt  Filtro per materiale (all, clear, tailor, smithy, iron, dull, ..., cloth, leather, ..., last).
;*          %5 opt  Filtro per quantità (all, 10, 15, 20).
;* @returns #true se tutte le operazioni vanno a buon fine, #false altrimenti.
;* @example gosub safecall Std_SetBodbookFilter %bodbook %size %quality %material %quantity
;* @see     SetBodBookFilter in BodFunctions.euo

sub Std_SetBodbookFilter ; %bodbook %size %quality %material %quantity
    set !nullArg %0 + 1
    for !i !nullArg 6
    {
        set % . !i !null
    }
    gosub libcall BodFunctions.euo SetBodbookFilter %1 %2 %3 %4 %5
return #true

;=======================================
;* @name    Std_IdentifyObject
;* @author  AG
;* @purpose Assegna un identificatore univoco ad un determinato oggetto.
;*          Si preoccupa di distinguere fra loro oggetti molto rilevanti ai fini dello script.
;* @params  %1 req  Oggetto da analizzare.
;* @returns Identificatore univoco dell'oggetto. Il risultato è imprevedibile se l'oggetto non è un premio o una risorsa.
;* @example gosub safecall Std_IdentifyObject !object
;* @status  Partially tested

sub Std_IdentifyObject ; %object
    set !object %1
    set !clsDeed EWH_TVH ; t5, t10, t15, t20, s5, s10, s15, s20, b, msh, lsh, lft, dft, bbh, pbh
    set !clsAncient OLH ; a10, a15, a30, a60
    set !clsPickaxe QPF ; 2419, g
    set !clsAnvil ZAG_KBG
    set !clsGloves KKH_XKH_BMH ; m1, m3, m5

    finditem !object C
    if #findkind = -1
       return #false
    set !type #findtype
    set !color #findcol

    if !type in !clsDeed ; sop, bless deeds, furniture
    {
        gosub safecall Std_ReadProperty !object
        set !property #result
        if bear , #spc , rug , #spc , deed in !property
        {
           if brown in !property
              return EWH:bbr
           if polar in !property
              return EWH:pbr
        }
        if flower , #spc , tapestry , #spc , deed in !property
        {
           if dark in !property
              return EWH:dft
           return EWH:lft
        }
        if stretched , #spc , hide , #spc , deed in !property
        {
           if large in !property
              return EWH:lsh
           return EWH:msh
        }
        if Clothing , #spc , Bless , #spc , Deed in !property
        {
           return EWH:b
        }
        if 105 in !property
           set !skill 5
        if 110 in !property
           set !skill 10
        if 115 in !property
           set !skill 15
        if 120 in !property
           set !skill 20
        if Scroll , #spc , of , #spc , Tailoring in !property
           return !type , :t , !skill
        if Scroll , #spc , of , #spc , Blacksmith in !property ; include sia "blacksmithy" che "blacksmithing"
           return !type , :s , !skill
        return #false
    }
    if !type in !clsGloves
    {
        gosub safecall Std_ReadProperty !object
        set !property #result
        if Blacksmith , #spc , Gloves , #spc , of , #spc , Mining notin !property
           return #false
        str right !property 2
        str left #strres 1
        set !bonus #strres
        if !bonus <> 1 && !bonus <> 3 && !bonus <> 5
           return #false
        return !type , :m , !bonus
    }
    if !type in !clsAncient ; ancient hammers
    {
        gosub safecall Std_ReadProperty !object
        set !property #result
        if Ancient , #spc , Smithy , #spc , Hammer notin !property
           return #false
        str right !property 3
        str left #strres 2
        set !bonus #strres
        if !bonus <> 10 && !bonus <> 15 && !bonus <> 30 && !bonus <> 60
           return #false
        return !type , :a , !bonus
    }
    if !type in !clsPickaxe ; gargoyle's pickaxe
    {
        gosub safecall Std_ReadProperty !object
        set !property #result
        if Gargoyle's in !property
           return !type , :g
    }
    if !type in !clsAnvil ; Colored Anvils
    {
        set !type ZAG
    }
return !type , : , !color

;=======================================
;* @name    Std_GetContainerAffinity
;* @author  AG
;* @purpose Calcola l'affinità di un contenitore rispetto ad un premio o ad una risorsa.
;* @params  %1 req  Contenitore di cui calcolare l'affinità.
;*          %2 req  Codice dell'oggetto rispetto al quale calcolare l'affinità (oppure id dell'oggetto stesso).
;* @returns Un livello di affinità fra i seguenti:
;*          0 - Nessuna affinità
;*          5 - Oggetti dello stesso tipo
;*          10 - Affinità completa
;*          Restituisce unknown_object in caso l'oggetto indicato in %2 non sia un premio valido.
;* @example gosub safecall Model_GetContainerAffinity %container %code
;* @status  Under development
;* @deprecated

sub Std_GetContainerAffinity ; %container %code
    set !container %1
    set !code %2

    if : notin !code
    {
        gosub safecall Std_IdentifyObject !code
        if #result = #false
           return unknown_object
        set !code #result
    }
    str pos !code :
    set !len #strres
    str del !code 1 !len
    set !postfix #strres
    set !len !len - 1
    str left !code !len
    set !prefix #strres

    set !type !prefix
    set !result 0
    ignoreitem reset StdGetContainerAffinity
    while #true
    {
        finditem !type C_ , !container StdGetContainerAffinity
        if #findkind = -1
           break
        set !result 5
        
        gosub safecall Std_IdentifyObject #findid
        if #result = !code
        {
           set !result 10
           break
        }
        ignoreitem #findid StdGetContainerAffinity
    }
    ignoreitem reset StdGetContainerAffinity
return !result

;=======================================
;* @name    Std_GetMostAffineContainer
;* @author  AG
;* @purpose Valuta una lista di contenitori per determinare qual'è il più idoneo ad ospitare un determinato oggetto.
;*          L'idoneità, anche detta "affinità", viene calcolata in base a quanto l'oggetto dato è simile ad eventuali
;*          altri oggetti già contenuti in ciascun contenitore.
;*          In particolare, si valutano i seguenti parametri:
;*          - Affinità 0: Nulla
;*          - Affinità 1: Stesso tipo di oggetto
;*          - Affinità 2: Stesso tipo di oggetto + Stesso colore dell'oggetto
;*          - Affinità 3: Stesso tipo di oggetto + Stesso colore dell'oggetto + Stesso nome dell'oggetto
;*          A parità di affinità fra più contenitori, la sub restituisce il contenitore che, fra questi, è stato
;*          specificato per primo nella lista.
;* @params  %1 req  Lista di contenitori fra i quali scegliere il più affine.
;*          %2 req  Oggetto o tipo di oggetto rispetto al quale calcolare l'affinità.
;*                  Se questo parametro è un oggetto, i parametri %3 e %4 vengono ignorati.
;*                  Se questo parametro è un tipo, i parametri %3 e %4 sono obbligatori.
;*          %3 opt  Colore dell'oggetto rispetto al quale calcolare l'affinità.
;*          %4 opt  #property dell'oggetto rispetto al quale calcolare l'affinità.
;* @returns Il contenitore più affine fra tutti quelli trovati.
;* @example gosub safecall Std_GetMostAffineContainer !iron ABCDEFG_HIJKLMN_OPQRSTU
;* @status  Tested and working

sub Std_GetMostAffineContainer ; %containers %object_or_type %color %header
    set !containers %1
    set !object %2
    
    str len !object
    if #strres <= 3
    {
        set !type !object
        set !color %3
        set !property %4
    }
    else
    {
        finditem !object C
        if #findkind = -1
        {
            finditem !object G
            if #findkind = -1
               return #false
        }
        set !type #findtype
        set !color #findcol
        gosub safecall Std_ReadProperty !object
        set !property #result
    }
    
    str pos !property $
    if #strres > 0
    {
        str left !property #strres
        set !header #strres
    }
    else
    {
        set !header !null
    }

    gosub safecall AG_Tokenize !containers _ Std_PlaceObject_Array_
    set !count #result
    if ! ( !count > 0 )
       return #false

    set !bestContainer !null
    set !bestAffinity -1
    for !i 1 !count
    {
        set !container %Std_PlaceObject_Array_ . !i
        set !affinity 0
        finditem !type C_ , !container
        if #findkind <> -1
        {
            set !affinity 1 ; stesso tipo
            for #findindex 1 #findcnt
            {
                if #findcol = !color
                {
                    set !affinity 2 ; stesso colore
                    if !header = !null
                    {
                       set !affinity 3 ; ignora il confronto sull'header
                       break
                    }
                    
                    gosub safecall Std_ReadProperty #findid
                    str pos #result $
                    str left #result #strres
                    if #strres = !header
                    {
                       set !affinity 3 ; stessa intestazione
                       break
                    }
                }
            }
        }
        if !affinity > !bestAffinity
        {
           set !bestAffinity !affinity
           set !bestContainer !container
        }
        if !bestAffinity >= 3
           break
    }
return !bestContainer

;=======================================
;* @name    Std_GetObjectWeight
;* @author  AG
;* @purpose Restituisce il peso di UN SINGOLO elemento di un certo tipo.
;*          E' necessario che il tipo di oggetto in questione sia visibile dal giocatore.
;* @params  %1 req  Tipo di oggetto del quale calcolare il peso.
;*                  E' anche possibile specificare un oggetto, anziché un tipo. Ricordarsi, in questo caso, che la funzione
;*                  calcola il peso di UN SINGOLO elemento, anche se l'oggetto è di tipo stackable.
;* @returns Il peso di UN SINGOLO elemento del tipo specificato, in MILLESIMI di Stones (un #result di 1000 indica 1 Stone).
;*          La stima è esatta se:
;*          - L'oggetto pesa più di 1 stone.
;*          - L'oggetto pesa meno di 1 stone (quindi è stackable) ma è stackato in quantità sufficientemente elevata.
;*          Negli altri casi, la stima soffre di una leggera approssimazione per eccesso.
;* @example gosub safecall Std_GetObjectWeight !goldType
;* @status  Tested and working

sub Std_GetObjectWeight ; %id
    set !type %1
    finditem !type C
    if #findkind = -1
    {
        finditem !type G
        if #findkind = -1
           return 0
    }
    set !object #findid
    set !count #findstack

    gosub safecall Std_ReadProperty !object
    set !property #result
    str pos !property weight:
    set !index #strres + 7
    str del !property 1 !index
    set !property #strres
    str pos !property #spc
    set !index #strres - 1
    str left !property !index
    set !fullWeight #strres
    if ! ( !fullWeight > 0 )
       return 0
return !fullWeight * 1000 / !count

;==============================================================================================================================
;* @name    Std_RunMenu
;* @author  AG
;* @purpose Esegue un menu in maniera "guidata dagli eventi".
;*          Questa sub implementa un semplice framework per l'esecuzione di menu secondo una filosofia event-driven.
;*          Occorre specificare un prefisso comune per tutte le variabili e le sub collegate al menu in esecuzione.
;*
;*          Ogni volta che si agirà su un determinato componente (premendolo se si tratta di un pulsante, oppure alterandone
;*          il valore se si tratta di un altro componente), Std_RunMenu provvederà a:
;*          - Aggiornare la variabile %[prefisso]_[nomeComponente] con il valore corrente del componente
;*            (se si tratta di un pulsante, verrà aggiornata la variabile %[prefisso]_MenuButton)
;*          - Notificare l'evento alla sub [prefisso]_[nomeComponente], se esiste.
;*
;*          Se invece si vuole modificare il valore di un componente direttamente da script, si può procedere in due modi:
;*          - Procedere in maniera "classica", cioè usare il comando "menu set".
;*            Questo ha lo stesso effetto di quando un utente altera il valore del componente, e quindi fa scattare le notifiche.
;*          - Settare il valore della variabile %[prefisso]_[nomeComponente].
;*            In questo caso, sarà Std_RunMenu ad aggiornare "silenziosamente" il componente, evitando di far scattare notifiche.
;*
;*          Inoltre, Std_RunMenu richiama anche le seguenti sub:
;*          - [prefisso]_Init: Prima esecuzione del menu. Utile per creare il menu stesso.
;*          - [prefisso]_Idle: Il menu non presenta eventi da eseguire. Utile per aggiornare menu dinamici.
;*          - [prefisso]_Over: Il ciclo del menu è terminato.
;*
;*          Il ciclo del menu continua fintanto che la variabile [prefisso]_Result = !null.
;*          Un modo veloce per impostare tale variabile è richiamare la sub Std_CloseMenu [menu_name] [menu_result].
;*
;* @params  %1 req  Nome del menu. Esso costituirà il prefisso comune a tutte le variabili e sub collegate a questo menu.
;*          %2 opt  Lista di componenti "passivi" (non pulsanti) di cui notificare i cambiamenti.
;*                  Necessario anche per quei componenti che si desidera aggiornare tramite modifica della relativa variabile.
;*                  Il separatore per questa lista è il carattere | (pipe).
;*                  NOTA: Questa lista può essere fornita anche come valore di ritorno della sub [prefisso]_Init.
;*          %3 opt  Modalità di esecuzione del ciclo (@todo). Può essere:
;*                  - cycle (predefinito): La sub esegue l'intero ciclo del menu, e ritorna solo quando il menu viene dismesso.
;*                  - step: Viene eseguito un singolo passo del ciclo di menu. Utile per simulare il multithreading.
;* @returns Il valore della variabile [prefisso]_Result.
;* @example gosub safecall Std_RunMenu MioMenu |CheckBox1|ListBox1|EditBox3|
;* @depends AG_Tokenize, safecall

sub Std_RunMenu
    if %0 >= 3 && %3 = step
    {
        namespace push
        namespace local Std_RunMenu_Persistent_ , %1
        gosub Std_RunMenu_Core %1 %2 #true
        namespace pop
    }
    else
    {
        if %0 >= 2
            gosub Std_RunMenu_Core %1 %2
        else
            gosub Std_RunMenu_Core %1
    }
return #result

sub Std_RunMenu_Core ; %menuName %observableComponents %singleStep
    set !menuName %1
    set !singleStep %0 >= 3 && %3 = #true

    ; initialization
    if !initSub = !null
    {
        if %0 >= 2 && %2 <> !null
           set !observableComponents %2
        else
           set !observableComponents |

        set !initSub !menuName , _Init
        set !idleSub !menuName , _Idle
        set !clearSub !menuName , _Over
        set !quitVar !menuName , _Result
        set !buttonVar !menuName , _MenuButton

        gosub safecall !initSub
        if #result <> !null
           set !observableComponents !observableComponents , | , #result

        gosub safecall AG_Tokenize !observableComponents | Std_RunMenu_Components_
        set !Components_Count #result
        if !Components_Count > 0
        {
            set !insertedComponents |
            set !j 0
            for !i 1 !Components_Count
            {
                set !component %Std_RunMenu_Components_ . !i
                if | , !component , | in !insertedComponents
                   continue
                set !j !j + 1
                set !Components_ . !j !component
                set !insertedComponents !insertedComponents , !component , |
            }
            set !Components_Count !j
        }

        set % . !quitVar !null
        set % . !buttonVar !null
        set #menubutton !null
    }
    
    ; loop
    while #true
    {
        set !button #menubutton
        if !button <> !null
        {
            set % . !buttonVar !button
            set #menubutton !null
            gosub safecall !menuName , _ , !button
        }

        if % . !quitVar <> !null
        {
            set !result % . !quitVar
            break
        }

        if ! ( !Components_Count < 1 )
        {
            for !i 1 !Components_Count
            {
                set !component !Components_ . !i
                set !varname !menuName , _ , !component

                if ( % . !varname ) <> ( ! . !varname ) ; global <> local
                {
                    set !value % . !varname
                    set ! . !varname !value    ; set local global
                    menu set !component !value ; update menu
                    menu list select !component !value
                    menu combo select !component !value
                }

                menu get !component ; pesante!!! @todo: esiste altro metodo?
                if #menures <> ( ! . !varname ) ; menu <> local
                {
                    set ! . !varname #menures ; set local menu
                    set % . !varname #menures ; set global menu
                    gosub safecall !varName   ; notify
                }
            }
        }

        gosub safecall !idleSub
        
        if !singleStep = #true
           return ; @todo return what value?
    }
    
    ; destruction
    gosub safecall !clearSub
    set #result !result
    namespace clear
return #result

;=======================================
;* @name    Std_CloseMenu
;* @author  AG
;* @purpose Funzione helper per chiudere correttamente un menu avviato con Std_RunMenu.
;* @params  %1 req  Nome del menu. Esso costituisce il prefisso comune a tutte le variabili e sub collegate a questo menu.
;*          %2 opt  Valore di ritorno. Valore da restituire alla fine della sub Std_RunMenu.
;* @example gosub safecall Std_CloseMenu MioMenu #false
;* @status  Tested and working

sub Std_CloseMenu ; %menuName %menuReturnVal
    set !menuName %1
    if %0 < 2 || %2 = !null
        set !result 0
    else
        set !result %2

    set !quitVar !menuName , _Result
    set % . !quitVar !result
return

;=======================================
;* @name    Std_FillLargeBods
;* @author  AG
;* @purpose Tenta di riempire un gruppo di bod large, utilizzando tutti i bod che si trovano in un bodbook.
;* @params  %1 req  Lista di large bods da riempire. Devono trovarsi già nel backpack.
;*          %2 req  Bodbook da cui estrarre i bod small. Si suppone che eventuali filtri siano già impostati correttamente.
;* @returns Numero di bod inseriti con successo.
;*          Implicitamente, questo significa che la sub restituisce #false (cioè 0) se non inserisce nessun bod.
;* @example gosub safecall Std_FillLargeBods !largebod !bodbook
;*          gosub safecall Std_FillLargeBods ABCDEFG_HIJKLMN !bodbook
;* @status  Under development (incompleto poiché deprecato)
;* @depends AG_Tokenize, altre
;* @deprecated

sub Std_FillLargeBods ; %bodlist %bodbook
    set !bodlist %1
    set !bodbook %2
    set !clsBod EYM

    gosub safecall AG_Tokenize Std_FillLargeBods_ _ !bodlist
    if #result = 0
       return #false

    ignoreitem reset
    for !i 1 %Std_FillLargeBods_Count
    {
        set !bod %Std_FillLargeBods_ . !i
        ignoreitem !bod
    }

    while #true
    {
        gosub safecall Std_ExtractBod !bodbook
        if #result = #false
           break
        finditem !clsBod C_ , #backpackid
        if #findkind = -1 ; should never happen
           break
        set !bod #findid

        for !i 1 %Std_FillLargeBods_Count
        {
            set !largebod %Std_FillLargeBods_ . !i
            if _ignore in !largebod
               continue

            gosub safecall Std_UseObject !largebod
            gosub safecall Std_WaitForBodGump
            if #result = #false
               continue

            gosub safecall Std_ClickBodGumpButton fill
            gosub safecall Std_SelectTarget !bod

            if #result = #false ; mirino non visualizzato: probabilmente il large bod è pieno - @todo Ottimizzare
            {
               set !largebod !largebod , _ignore
               set %Std_FillLargeBods_ . !i !largebod
               continue
            }

            finditem !bod C_ , #backpackid
            if #findkind = -1 ; bod inserito. passa al successivo.
               break
        }

        finditem !bod C_ , #backpackid
        if #findkind <> -1 ; bod non inserito. inserisci in lista ignore, e poi in bodbook.
        {
            ; @todo ?
        }
    }

    gosub safecall Std_CheckForBodGump
    while #result = #true
    {
        gosub safecall Std_ClickBodGumpButton exit
    }

    finditem !clsBod C_ , #backpackid
    set !newcount #findcnt
return !oldcount - !newcount




;==========================================================
;=
;=
;=    FUNZIONI LOGICHE (prefisso "Model")
;=
;=
;==========================================================

;==========================================================
;= SEZIONE 1: Funzioni di configurazione
;==========================================================

;=======================================
;* @name    Model_Init
;* @author  AG
;* @purpose Inizializza tutte le variabili dello script.
;*          Si occupa di richiamare Model_InitConstants, nonché la funzione di tipo "Model_LoadConfig" più appropriata.
;* @example gosub safecall Model_Init

sub Model_Init
    gosub safecall Model_InitConstants
    gosub safecall Model_LoadConfig
    gosub safecall Model_AutoConfig
return

;=======================================
;* @name    Model_InitConstants
;* @author  AG
;* @purpose Inizializza tutte le costanti dello script.
;*          Tutte le costanti hanno prefisso "Constants_", per evitare conflitti di nomi con altre variabili globali.
;* @example gosub safecall Model_InitConstants

sub Model_InitConstants
    ; Colors
    ;set %Constants_Color_Normal        0
    ;set %Constants_Color_Regular       0
    ;set %Constants_Color_Leather       0
    ;set %Constants_Color_Spined        2220
    ;set %Constants_Color_Horned        2117
    ;set %Constants_Color_Barbed        2129
    ;set %Constants_Color_Iron          0
    ;set %Constants_Color_Dull          2419
    ;set %Constants_Color_Shadow        2406
    ;set %Constants_Color_Copper        2413
    ;set %Constants_Color_Bronze        2418
    ;set %Constants_Color_Gold          2213
    ;set %Constants_Color_Agapite       2425
    ;set %Constants_Color_Verite        2207
    ;set %Constants_Color_Valorite      2219
    ;set %Constants_Color_Green         1155
    ;set %Constants_Color_GreenBlue     1164
    ;set %Constants_Color_DarkTurquoise 1160
    ;set %Constants_Color_AquaGreen     1162
    ;set %Constants_Color_Torquoise     1173
    ;set %Constants_Color_Purple        1163
    ;set %Constants_Color_DarkPurple    1158
    ;set %Constants_Color_BloodRed      1157
    ;set %Constants_Color_NeonBlue      1165
    ;set %Constants_Color_NeonPurple    1168
    ;set %Constants_Color_NeonPink      1166
    ;set %Constants_Color_NeonYellow    1169
    ;set %Constants_Color_NeonGreen     1167 ; anche sandals
    ;set %Constants_Color_RedBlue       1172 ; anche sandals
    ;set %Constants_Color_DarkBlue      1156 ; anche sandals
    ;set %Constants_Color_Charcoal      1175 ; anche sandals
    ;set %Constants_Color_Fire          1161 ; anche sandals
    ;set %Constants_Color_IceGreen      1151 ; anche sandals
    ;set %Constants_Color_IceBlue       1154 ; anche sandals
    ;set %Constants_Color_IceWhite      1150 ; anche sandals
    ;set %Constants_Color_SopWhite      1153

    ; tipi di oggetto
    set %Constants_TinkersTools        KTL
    set %Constants_SewingKit           HAG ; normal/runic
    set %Constants_Tongs               OBG
    set %Constants_Hammer              TLH ; normal/runic
    set %Constants_Scissors            KAG
    set %Constants_SmithTools          TLH_FBG_GBG_OLH_OBG_TBG
    set %Constants_Ingots              ENK
    set %Constants_Cloth               BUI ; normal/colored
    set %Constants_CutUpCloth          CUI
    set %Constants_Leather             JJG
    set %Constants_Bones               GUF
    set %Constants_Sandals             NVI ; normal/colored
    set %Constants_Deed                EWH ; SOP, Bless Deed, other
    set %Constants_AncientHammer       OLH
    set %Constants_POF                 KEG
    set %Constants_Pickaxe             QPF ; normal/sturdy/gargoyle
    set %Constants_Shovel              TWF ; normal/sturdy
    set %Constants_ProspectorsTools    GBG
    set %Constants_Gloves              KKH_XKH_BMH
    set %Constants_Vendor              IS_HS
    set %Constants_Bod                 EYM
    set %Constants_Bodbook             DYM
    set %Constants_TrashBarrel         BKF
    set %Constants_Runebook            ZBN
  	set %Constants_Forges              JBG_SOJ_ROJ_AUJ_ZTJ_CUJ_BUJ_WTJ_VTJ_KUJ_JUJ_EUJ_DUJ_
  			                               +GUJ_FUJ_QUJ_PUJ_OUJ_NUJ_YUJ_XUJ_AVJ_ZUJ_UUJ_TUJ_IVJ_
  			                               +HVJ_CVJ_BVJ_EVJ_DVJ_OVJ_NVJ_KHR
  	set %Constants_Anvils              ZAG_KBG_AHR
  	set %Constants_DyingTub            DBG
  	set %Constants_BoneItems           CQH_VPH_PPH_ZPH_BQH
  	
    set %Constants_Resources_Types     _ENK_JJG_BUI_GUF_
    set %Constants_Resources_Tailor    _JJG:0_JJG:2220_JJG:2117_JJG:2129_BUI:0_GUF:0_
    set %Constants_Resources_Smith     _ENK:0_ENK:2419_ENK:2406_ENK:2413_ENK:2418_ENK:2213_ENK:2425_ENK:2207_ENK:2219_
    set %Constants_Resources_All       %Constants_Resources_Smith , %Constants_Resources_Tailor
    set %Constants_Resources_Light     _BUI_ENK_
    set %Constants_Resources_Heavy     _JJG_GUF_

    ; Categorie di Rewards (per interfaccia grafica)
    set %Constants_Rewards_Types           BUI_NVI_EWH_HAG_ZAG_KBG_TLH_OLH_TWF_QPF_GBG_BMH_KKH_XKH_TVH_KEG
    set %Constants_Rewards_Cloth           _BUI:1155_BUI:1164_BUI:1160_BUI:1162_BUI:1173_BUI:1163_BUI:1158_BUI:1157_BUI:1165_BUI:1168_
                                           +BUI:1166_BUI:1169_BUI:1167_BUI:1172_BUI:1156_BUI:1175_BUI:1161_BUI:1151_BUI:1154_BUI:1150_
    set %Constants_Rewards_Sandals         _NVI:1167_NVI:1172_NVI:1156_NVI:1175_NVI:1161_NVI:1151_NVI:1154_NVI:1150_
    set %Constants_Rewards_Tailor          _EWH:msh_EWH:lsh_EWH:lft_EWH:dft_EWH:bbr_EWH:pbr_EWH:t5_EWH:t10_EWH:t15_EWH:t20_EWH:b_HAG:2220_HAG:2117_HAG:2129_
    set %Constants_Rewards_Anvils          _ZAG:2419_ZAG:2406_ZAG:2413_ZAG:2418_ZAG:2213_ZAG:2425_ZAG:2207_ZAG:2219_
    set %Constants_Rewards_Hammers         _TLH:2419_TLH:2406_TLH:2413_TLH:2418_TLH:2213_TLH:2425_TLH:2207_TLH:2219_OLH:a10_OLH:a15_OLH:a30_OLH:a60_
    set %Constants_Rewards_Smith           _TWF:2419_QPF:2419_GBG:2419_QPF:g_KEG:2419_KKH:m1_XKH:m3_BMH:m5_EWH:s5_EWH:s10_EWH:s15_EWH:s20_
    set %Constants_Rewards_All             %Constants_Rewards_Cloth , %Constants_Rewards_Sandals , %Constants_Rewards_Tailor ,
                                           + %Constants_Rewards_Anvils , %Constants_Rewards_Hammers , %Constants_Rewards_Smith
                                           
    set %Constants_LargeRewards_Tailor     _MediumStretchedHide_LargeStretchedHide_LightTapestry_DarkTapestry_BrownBearRug_PolarBearRug_
                                           +Tailoring5_Tailoring10_Tailoring15_Tailoring20_BlessDeed_SpinedKit_HornedKit_BarbedKit_
    set %Constants_LargeRewards_Smith      _MiningGloves1_MiningGloves3_MiningGloves5_ProspectorsTools_GargoylesPickaxe_POF_ColoredAnvil_
                                           +Smith5_Smith10_Smith15_Smith20_
                                           +DullHammer_ShadowHammer_CopperHammer_BronzeHammer_GoldHammer_AgapiteHammer_VeriteHammer_ValoriteHammer_
                                           +AncientHammer10_AncientHammer15_AncientHammer30_AncientHammer60_

    set %Constants_Tools                   |FillSmallBod|FillLargeBod|DeliverBod|PlaceObject|BankRestock|AnalyzeObject|MoveObject|

    ; tutte le variabili indicate in questa lista verranno rese persistenti. utilizzare un segno di "|" come separatore
    set %Constants_PersistentVars |
        +Config_Runebooks_Tailor|Config_Runebooks_Smith|Config_Runebooks_Home|Config_Runebooks_Bank|
        +Config_Chests_Work|Config_Chests_Bank|Config_Chests_Rewards|
        +Config_BodFilter_Rewards|Config_BodFilter_TrashBoneBods|Config_RewardFilter_Rewards|
        +Config_Home_PosX|Config_Home_PosY|Config_Home_PosZ|
        +Config_Home_DyingTub|Config_Home_Forge|Config_Home_Anvil|Config_Home_Trash|
return

sub Model_GetHumanName ; %varname
    set !name %1
    while : in !name ; elimina i ":" dai nomi di variabile
    {
        str pos !name :
        str del !name #strres 1
        set !name #strres
    }

    goto Boscags7_HumanNamesDb_ , !name
        return !null
        
    ; Premi tailoring (large reward id)
    Boscags7_HumanNamesDb_MediumStretchedHide:
        return Medium , #spc , Stretched , #spc , Hide
    Boscags7_HumanNamesDb_LargeStretchedHide:
        return Large , #spc , Stretched , #spc , Hide
    Boscags7_HumanNamesDb_LightTapestry:
        return Light , #spc , Wall , #spc , Tapestry
    Boscags7_HumanNamesDb_DarkTapestry:
        return Dark , #spc , Wall , #spc , Tapestry
    Boscags7_HumanNamesDb_BrownBearRug:
        return Brown , #spc , Bear , #spc , Rug
    Boscags7_HumanNamesDb_PolarBearRug:
        return Polar , #spc , Bear , #spc , Rug
    Boscags7_HumanNamesDb_Tailoring5:
        return SOP , #spc , +5 , #spc , Tailoring
    Boscags7_HumanNamesDb_Tailoring10:
        return SOP , #spc , +10 , #spc , Tailoring
    Boscags7_HumanNamesDb_Tailoring15:
        return SOP , #spc , +15 , #spc , Tailoring
    Boscags7_HumanNamesDb_Tailoring20:
        return SOP , #spc , +20 , #spc , Tailoring
    Boscags7_HumanNamesDb_BlessDeed:
        return Bless , #spc , Deed
    Boscags7_HumanNamesDb_SpinedKit:
        return Spined , #spc , Kit
    Boscags7_HumanNamesDb_HornedKit:
        return Horned , #spc , Kit
    Boscags7_HumanNamesDb_BarbedKit:
        return Barbed , #spc , Kit
        
    ; Premi blacksmith (large reward id)
    Boscags7_HumanNamesDb_MiningGloves1:
        return Gloves , #spc , of , #spc , Mining , #spc , +1
    Boscags7_HumanNamesDb_MiningGloves3:
        return Gloves , #spc , of , #spc , Mining , #spc , +3
    Boscags7_HumanNamesDb_MiningGloves5:
        return Gloves , #spc , of , #spc , Mining , #spc , +5
    Boscags7_HumanNamesDb_ProspectorsTools:
        return Prospector's , #spc , Tools
    Boscags7_HumanNamesDb_GargoylesPickaxe:
        return Gargoyle's , #spc , Pickaxe
    Boscags7_HumanNamesDb_POF:
        return Powder , #spc , of , #spc , Fortifying
    Boscags7_HumanNamesDb_ColoredAnvil:
        return Colored , #spc , Anvil
    Boscags7_HumanNamesDb_Smith5:
        return SOP , #spc , +5 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_Smith10:
        return SOP , #spc , +10 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_Smith15:
        return SOP , #spc , +15 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_Smith20:
        return SOP , #spc , +20 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_DullHammer:
        return Dull , #spc , Copper , #spc , Hammer
    Boscags7_HumanNamesDb_ShadowHammer:
        return Shadow , #spc , Hammer
    Boscags7_HumanNamesDb_CopperHammer:
        return Copper , #spc , Hammer
    Boscags7_HumanNamesDb_BronzeHammer:
        return Bronze , #spc , Hammer
    Boscags7_HumanNamesDb_GoldHammer:
        return Gold , #spc , Hammer
    Boscags7_HumanNamesDb_AgapiteHammer:
        return Agapite , #spc , Hammer
    Boscags7_HumanNamesDb_VeriteHammer:
        return Verite , #spc , Hammer
    Boscags7_HumanNamesDb_ValoriteHammer:
        return Valorite , #spc , Hammer
    Boscags7_HumanNamesDb_AncientHammer10:
        return Ancient , #spc , Hammer , #spc , +10
    Boscags7_HumanNamesDb_AncientHammer15:
        return Ancient , #spc , Hammer , #spc , +15
    Boscags7_HumanNamesDb_AncientHammer30:
        return Ancient , #spc , Hammer , #spc , +30
    Boscags7_HumanNamesDb_AncientHammer60:
        return Ancient , #spc , Hammer , #spc , +60

    ; Stoffe
    Boscags7_HumanNamesDb_BUI1155:
        return 1: , #spc , Green , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1164:
        return 1: , #spc , Green/Blue , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1160:
        return 1: , #spc , Dark , #spc , Turquoise , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1162:
        return 1: , #spc , Aqua , #spc , Green , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1173:
        return 2: , #spc , Torquoise , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1163:
        return 2: , #spc , Purple , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1158:
        return 2: , #spc , Dark , #spc , Purple , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1157:
        return 2: , #spc , Blood , #spc , Red , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1165:
        return 3: , #spc , Neon , #spc , Blue , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1168:
        return 3: , #spc , Neon , #spc , Purple , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1166:
        return 3: , #spc , Neon , #spc , Pink , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1169:
        return 3: , #spc , Neon , #spc , Yellow , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1167:
        return 4: , #spc , Neon , #spc , Green , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1172:
        return 4: , #spc , Red/Blue , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1156:
        return 4: , #spc , Dark , #spc , Blue , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1175:
        return 4: , #spc , Charcoal , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1161:
        return 5: , #spc , Fire , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1151:
        return 5: , #spc , Ice , #spc , Green , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1154:
        return 5: , #spc , Ice , #spc , Blue , #spc , Cloth
    Boscags7_HumanNamesDb_BUI1150:
        return 5: , #spc , Ice , #spc , White , #spc , Cloth

    ; Sandali
    Boscags7_HumanNamesDb_NVI1167:
        return Neon , #spc , Green , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1172:
        return Red/Blue , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1156:
        return Dark , #spc , Blue , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1175:
        return Charcoal , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1161:
        return Fire , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1151:
        return Ice , #spc , Green , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1154:
        return Ice , #spc , Blue , #spc , Sandals
    Boscags7_HumanNamesDb_NVI1150:
        return Ice , #spc , White , #spc , Sandals
        
    ; Altri premi tailoring
    Boscags7_HumanNamesDb_EWHmsh:
        return Medium , #spc , Stretched , #spc , Hide
    Boscags7_HumanNamesDb_EWHlsh:
        return Large , #spc , Stretched , #spc , Hide
    Boscags7_HumanNamesDb_EWHdft:
        return Dark , #spc , Flower , #spc , Tapestry
    Boscags7_HumanNamesDb_EWHlft:
        return Light , #spc , Flower , #spc , Tapestry
    Boscags7_HumanNamesDb_EWHbbr:
        return Brown , #spc , Bear , #spc , Rug
    Boscags7_HumanNamesDb_EWHpbr:
        return Polar , #spc , Bear , #spc , Rug
    Boscags7_HumanNamesDb_EWHt5:
        return SOP , #spc , +5 , #spc , Tailoring
    Boscags7_HumanNamesDb_EWHt10:
        return SOP , #spc , +10 , #spc , Tailoring
    Boscags7_HumanNamesDb_EWHt15:
        return SOP , #spc , +15 , #spc , Tailoring
    Boscags7_HumanNamesDb_EWHt20:
        return SOP , #spc , +20 , #spc , Tailoring
    Boscags7_HumanNamesDb_EWHb:
        return Bless , #spc , Deed
    Boscags7_HumanNamesDb_HAG2220:
        return Spined , #spc , Kit
    Boscags7_HumanNamesDb_HAG2117:
        return Horned , #spc , Kit
    Boscags7_HumanNamesDb_HAG2129:
        return Barbed , #spc , Kit

    ; Anvils
    Boscags7_HumanNamesDb_ZAG2419:
        return Dull , #spc , Copper , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2406:
        return Shadow , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2413:
        return Copper , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2418:
        return Bronze , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2213:
        return Gold , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2425:
        return Agapite , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2207:
        return Verite , #spc , Anvil
    Boscags7_HumanNamesDb_ZAG2219:
        return Valorite , #spc , Anvil

    ; Hammers
    Boscags7_HumanNamesDb_TLH2419:
        return Dull , #spc , Copper , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2406:
        return Shadow , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2413:
        return Copper , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2418:
        return Bronze , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2213:
        return Gold , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2425:
        return Agapite , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2207:
        return Verite , #spc , Hammer
    Boscags7_HumanNamesDb_TLH2219:
        return Valorite , #spc , Hammer

    ; Altri blacksmith
    Boscags7_HumanNamesDb_TWF2419:
        return Sturdy , #spc , Shovel
    Boscags7_HumanNamesDb_QPF2419:
        return Sturdy , #spc , Pickaxe
    Boscags7_HumanNamesDb_GBG2419:
        return Prospector's , #spc , Tools
    Boscags7_HumanNamesDb_QPFg:
        return Gargoyle's , #spc , Pickaxe
    Boscags7_HumanNamesDb_KEG2419:
        return Powder , #spc , of , #spc , Fortifying
    Boscags7_HumanNamesDb_KKHm1:
        return Gloves , #spc , of , #spc , Mining , #spc , +1
    Boscags7_HumanNamesDb_XKHm3:
        return Gloves , #spc , of , #spc , Mining , #spc , +3
    Boscags7_HumanNamesDb_BMHm5:
        return Gloves , #spc , of , #spc , Mining , #spc , +5
    Boscags7_HumanNamesDb_EWHs5:
        return SOP , #spc , +5 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_EWHs10:
        return SOP , #spc , +10 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_EWHs15:
        return SOP , #spc , +15 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_EWHs20:
        return SOP , #spc , +20 , #spc , Blacksmithy
    Boscags7_HumanNamesDb_OLHa10:
        return Ancient , #spc , Hammer , #spc , +10
    Boscags7_HumanNamesDb_OLHa15:
        return Ancient , #spc , Hammer , #spc , +15
    Boscags7_HumanNamesDb_OLHa30:
        return Ancient , #spc , Hammer , #spc , +30
    Boscags7_HumanNamesDb_OLHa60:
        return Ancient , #spc , Hammer , #spc , +60

    ; Resources
    Boscags7_HumanNamesDb_JJG0:
        return Normal , #spc , Leather
    Boscags7_HumanNamesDb_JJG2220:
        return Spined , #spc , Leather
    Boscags7_HumanNamesDb_JJG2117:
        return Horned , #spc , Leather
    Boscags7_HumanNamesDb_JJG2129:
        return Barbed , #spc , Leather
    Boscags7_HumanNamesDb_BUI0:
        return Cloth
    Boscags7_HumanNamesDb_GUF0:
        return Bones
    Boscags7_HumanNamesDb_ENK0:
        return Iron , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2419:
        return Dull , #spc , Copper , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2406:
        return Shadow , #spc , Iron , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2413:
        return Copper , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2418:
        return Bronze , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2213:
        return Gold , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2425:
        return Agapite , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2207:
        return Verite , #spc , Ingots
    Boscags7_HumanNamesDb_ENK2219:
        return Valorite , #spc , Ingots

    ; Tools
    Boscags7_HumanNamesDb_FillSmallBod:
        return Riempi , #spc , Small , #spc , BOD
    Boscags7_HumanNamesDb_FillLargeBod:
        return Riempi , #spc , Large , #spc , BOD
    Boscags7_HumanNamesDb_DeliverBod:
        return Consegna , #spc , BOD
    Boscags7_HumanNamesDb_PlaceObject:
        return Sistema , #spc , oggetto
    Boscags7_HumanNamesDb_BankRestock:
        return Restock , #spc , da , #spc , banca
    Boscags7_HumanNamesDb_AnalyzeObject:
        return Analizza , #spc , oggetto
    Boscags7_HumanNamesDb_MoveObject:
        return Sposta , #spc , oggetti
return

;=======================================
;* @name    Model_LoadDefaultConfig
;* @author  AG
;* @purpose Inizializza tutte le variabili di configurazione (prefisso "Config_") al loro valore predefinito.
;*          Questa funzione può essere usata come riferimento da nuovi scripters per conoscere le variabili usate dallo script.
;*          Per garantire maggiore flessibilità, spesso alcune variabili sono ridondanti rispetto alle opzioni di menu.
;* @params
;* @returns
;* @example gosub safecall Model_LoadDefaultConfig

sub Model_LoadDefaultConfig
    set %Config_Runebooks_Home          !null   ; _runebook:runa_ ; esempio: _EASYDNV:3_EASYDNV:4_
    set %Config_Runebooks_Bank          !null   ; _runebook:runa_ ; esempio: _EASYDNV:3_EASYDNV:4_
    set %Config_Runebooks_Tailor        !null   ; _runebook:runa_ ; esempio: _EASYDNV:3_EASYDNV:4_
    set %Config_Runebooks_Smith         !null   ; _runebook:runa_ ; esempio: _EASYDNV:3_EASYDNV:4_
    set %Config_RecallMode              !null   ; "recall" oppure "journey"
    set %Config_RecallAsWraith          !null   ; #true / #false
    set %Config_Chests_Work             !null   ; elenco chests - esempio: _IGJDCND_PZHCCND_
    set %Config_Chests_Bank             !null
    set %Config_Chests_Rewards          !null
    set %Config_Bodbooks_Fill           !null   ; id di un bodbook
    set %Config_Bodbooks_Keep           !null
    set %Config_Bodbooks_Deliver        !null
    set %Config_Bodbooks_Trash          !null
    set %Config_Bodbooks_Failed         !null
    set %Config_Home_PosX               !null
    set %Config_Home_PosY               !null
    set %Config_Home_PosZ               !null
    set %Config_BodFilter_TrashBoneBods #false  ; #true o #false
    set %Config_BodFilter_Rewards       _BlessDeed_BarbedKit_Tailoring20_
                                        +GoldHammer_AgapiteHammer_VeriteHammer_ValoriteHammer_
                                        +AncientHammer30_AncientHammer60_Blacksmithy20_
    set %Config_RewardFilter_Rewards    _BUI:1161_BUI:1151_BUI:1154_BUI:1150_BUI:1167_BUI:1172_BUI:1156_BUI:1175_
                                        +NVI:1167_NVI:1172_NVI:1156_NVI:1175_NVI:1161_NVI:1151_NVI:1154_NVI:1150_
                                        +EWH:msh_EWH:lsh_EWH:lft_EWH:dft_EWH:bbr_EWH:pbr_EWH:t20_EWH:b_HAG:2220_
                                        +HAG:2117_HAG:2129_EWH:t5_EWH:t10_
                                        +EWH:t15_ZAG:2419_ZAG:2406_ZAG:2413_ZAG:2418_ZAG:2213_ZAG:2425_ZAG:2207_
                                        +ZAG:2219_TLH:2413_TLH:2418_TLH:2213_TLH:2425_TLH:2207_TLH:2219_OLH:a10_
                                        +OLH:a15_OLH:a30_OLH:a60_TLH:2419_TLH:2406_GBG:2419_QPF:g_BMH:m5_EWH:s5_
                                        +EWH:s10_EWH:s15_EWH:s20_KEG:2419_
return

;=======================================
;* @name    Model_LoadConfig
;* @author  AG
;* @purpose Carica la configurazione avente il nome richiesto.
;*          Se si specifica "Default", o se la configurazione specificata non esiste, la funzione richiamerà Model_LoadDefaultConfig.
;* @params  %1 opt Nome della configurazione da caricare. Il valore predefinito è "Current".
;* @returns
;* @example gosub safecall Model_LoadConfig Configuration1

sub Model_LoadConfig ; %configName
    if %0 < 1 || %1 = !null
        set !configName Current
    else
        set !configName %1
    gosub safecall Model_LoadDefaultConfig
    if !configName <> Default
    {
        gosub safecall Std_LoadPersistentVariables |Config_Initialized| !configName
        if %Config_Initialized = #true
        {
            gosub safecall Std_LoadPersistentVariables %Constants_PersistentVars !configName
        }
    }
    gosub safecall Model_OverrideConfig
    set %Config_Initialized #true
return

;=======================================
;* @name    Model_AutoConfig
;* @author  AG
;* @purpose Determina parametri di configurazione on-the-fly.
;* @example gosub safecall Model_AutoConfig

sub Model_AutoConfig
    gosub safecall Model_FindBodbooks
    ;gosub safecall Model_InitRails
    
    chooseskill mage
    set !magery #skill
    chooseskill necr
    set !necro #skill
    chooseskill chiv
    set !chivalry #skill

    set %Config_RecallAsWraith ( !necro > !chivalry && !necro > !magery )
    if !magery >= !chivalry || %Config_RecallAsWraith
       set %Config_RecallMode recall
    else
       set %Config_RecallMode sacred_journey
return

;=======================================
;* @name    Model_OverrideConfig
;* @author  AG
;* @purpose Forza il settaggio di determinati valori di configurazione.
;*          Usato sia per settaggi automatici che per settaggi manuali.
;* @returns
;* @example gosub safecall Model_OverrideConfig

sub Model_OverrideConfig
    set %Config_CharNumber 4
return

;=======================================
;* @name    Model_SaveConfig
;* @author  AG
;* @purpose Salva la configurazione corrente con il nome richiesto.
;* @params  %1 opt Nome con cui salvare la configurazione corrente.
;*                 Il valore predefinito è "Current". Il valore "Default" non è ammesso.
;* @returns
;* @example gosub safecall Model_SaveConfig Configuration1

sub Model_SaveConfig ; %configName
    if %0 < 1 || %1 = !null
        set !configName Current
    else
        set !configName %1

    if !configName = Default
       return
       
    set %Config_Initialized #true
    gosub safecall Std_SavePersistentVariables |Config_Initialized| !configName
    gosub safecall Std_SavePersistentVariables %Constants_PersistentVars !configName
return


;==========================================================
;= SEZIONE 2: Funzioni esecutive (livello Model)
;==========================================================

;=======================================
;* @name    Yeld
;* @author  AG
;* @purpose Funzione speciale di livello Model, richiamata da ogni sub ogniqualvota è possibile fermarsi
;*          per eseguire check di sicurezza (tipo Std_WaitForSave).
;*          Dovrebbe essere richiamata ad intervalli anche irregolari di 2-5 secondi.
;* @example gosub safecall Yeld

sub Yeld
    if #systime < %Yeld_DelayTime
       return
    set %Yeld_DelayTime #systime + 1000
    
    ; attesa durante save/cleaning
    gosub safecall Model_WaitForSave
    
    ; check for connection lost
    gosub safecall Model_CheckConnection
return

;=======================================
;* @name    DoTasks
;* @author  AG
;* @purpose Funzione speciale di livello Model, richiamata da ogni sub ogniqualvota è possibile fermarsi
;*          per eseguire task complementari definiti dall'utente.
;*          Questa funzione può essere personalizzata dagli utenti per effettuare task anche molto complessi
;*          (tipo la raccolta di nuovi bod).
;*          Si consiglia di utilizzare istruzioni call anzichè implementare tutto in loco.
;* @example gosub safecall DoTasks

sub DoTasks
    ; aggiungi collegamenti ai tuoi script qui.
return

;=======================================
;* @name    Model_WaitForSave
;* @author  AG
;* @purpose Attende il termine di una fase di save o cleaning.
;* @example gosub safecall Model_WaitForSave

sub Model_WaitForSave
    gosub safecall Std_GetWorldStatus
    if #result = saving || #result = cleaning || #result = savewarning
    {
        if #result = saving || #result = savewarning
        {
           event exmsg #charid 3 0 Save in corso!
           set !timeout #systime + 60000
        }
        else
        {
           event exmsg #charid 3 0 Cleaning in corso!
           set !timeout #systime + 15000
        }
        gosub safecall Std_GetWorldStatus
        while #systime < !timeout && #result <> running
        {
            gosub safecall Std_GetWorldStatus
        }
        event exmsg #charid 3 0 Riprendo a lavorare.
    }
return

;=======================================
;* @name    Model_CheckConnection
;* @author  AG
;* @purpose In caso di connection lost, ristabilisce la connessione.
;* @example gosub safecall Model_CheckConnection

sub Model_CheckConnection
    gosub safecall Std_CheckConnection
    if #result = #false && ! ( #time >= 065000 && #time < 075000 )
       gosub safecall Model_Login %Config_CharNumber
return

;=======================================
;* @name    Model_Login
;* @author  AG
;* @purpose Effettua il login con il personaggio specificato.
;*          Incapsula tutte le operazioni di login in una sub centralizzata.
;* @params  %1 req Indice del personaggio da loggare.
;* @example gosub safecall Model_Login
;* @login   Bookmark per trovare velocemente questa sub.

sub Model_Login ; %charnum
    set !charnum %1
    
    set !username !null    ; inserite qui il vostro username; usate !null per indicare l'account predefinito.
    set !password password ; inserite qui la vostra password.
    set !charnum  1        ; PROVVISORIO: inserite qui l'indice del vostro pg worker nella lista personaggi.
    
    call LoginData.txt     ; questa riga potete anche cancellarla
    gosub safecall Std_Login !username !password !charnum
    set !username !null
    set !password !null
return

;=======================================
;* @name    Model_DetectLocation
;* @author  AG
;* @purpose Determina in maniera automatica il luogo in cui ci si trova (casa, banca, sarto, fabbro).
;* @params
;* @returns Uno di questi valori: home, bank, tailor, smith. Oppure #false se il luogo è sconosciuto.
;*          Inoltre, NEI SOLI CASI DI bank, tailor e smith, salva all'interno delle variabili di tipo #find*
;*          informazioni sul vendor relativo a quel luogo.
;* @example gosub safecall Model_DetectLocation
;* @status  Tested and working

sub Model_DetectLocation
    ; Quanto siamo vicini alla home position?
    set !distX #charposx - %Config_Home_PosX
    set !distY #charposy - %Config_Home_PosY
    if ( !distX * !distX ) <= 400 && ( !distY * !distY ) <= 400
    {
        set %Location_Name home
        set %Location_X %Config_Home_PosX
        set %Location_Y %Config_Home_PosY
        set %Location_Z %Config_Home_PosZ
        set %Location_Vendor !null
        return %Location_Name
    }

    set !vendor !null
    set !vendorType unknown
    set !clsVendors %Constants_Vendor
    finditem !clsVendors G_25
    if #findkind <> -1
    {
        set !strBanker1 #spc , Banker , #spc
        set !strBanker2 #spc , Minter , #spc
        set !strTailor1 #spc , Tailor , #spc
        set !strTailor2 #spc , Weaver , #spc
        set !strSmith1  #spc , Blacksmith , #spc
        set !strSmith2  #spc , Blacksmith , #spc
        set !strGuildMaster #spc , GuildMaster , #spc
        
        set !distance 1000
        for #findindex 1 #findcnt
        {
            gosub safecall Std_ReadProperty #findid
            set !property #result
            str pos !property $
            set !length #strres - 1
            str left !property !length
            set !property #strres , #spc
            
            if !strGuildmaster in !property || #finddist >= !distance
            {
               continue
            }
            if !strBanker1 in !property || !strBanker2 in !property
            {
               set !vendorType bank
               set !distance #finddist
               set !vendor #findid
            }
            if !strTailor1 in !property || !strTailor2 in !property
            {
               set !vendorType tailor
               set !distance #finddist
               set !vendor #findid
            }
            if !strSmith1 in !property || !strSmith2 in !property
            {
               set !vendorType smith
               set !distance #finddist
               set !vendor #findid
            }
        }
    }
    
    if !vendorType = unknown
    {
        set %Location_Name unknown
        set %Location_Vendor !null
        set %Location_X !null
        set %Location_Y !null
        set %Location_Z !null
    }
    else
    {
        finditem !vendor G_25
        set %Location_Name !vendorType
        set %Location_Vendor #findid
        set %Location_X #findx
        set %Location_Y #findy
        set %Location_Z #findz
    }
return %Location_Name

;=======================================
;* @name    Model_ChangeLocation
;* @author  AG
;* @purpose Recalla il PG nel tipo di luogo specificato (banca, casa, sarto, fabbro) e gli fa raggiungere la posizione
;*          più opportuna (la "posizione a casa", oppure una posizione vicina al vendor).
;*          Sia la fase di recall che quella di pathfinding sono evitate se non necessarie.
;* @params  %1 req Tipo di luogo in cui si desidera spostarsi.
;* @returns #true se la destinazione viene raggiunta con successo. #false altrimenti.
;*          Inoltre, NEI SOLI CASI DI bank, tailor e smith, salva all'interno delle variabili di tipo #find*
;*          informazioni sul vendor relativo a quel luogo.
;* @example gosub safecall Model_ChangeLocation tailor
;* @status  Tested and working.

sub Model_ChangeLocation ; %destination (home|bank|tailor|smith)
    set !destination %1
    set !recallMode %Config_RecallMode
    set !runes_home %Config_Runebooks_Home
    set !runes_tailor %Config_Runebooks_Tailor
    set !runes_smith %Config_Runebooks_Smith
    set !runes_bank %Config_Runebooks_Bank

    set !runes !runes_ . !destination
    gosub safecall AG_Tokenize !runes _ Temp_Array_
    set !count #result

    for !i 0 !count ; parti da 0 per consentire il pathfind iniziale
    {
        gosub safecall Yeld
        if !i = 0
        {
            gosub safecall Model_DetectLocation
        }
        else
        {
            set !runeCode %Temp_Array_ . !i ; esempio runecode: ABCDEF:3
            gosub safecall AG_Tokenize !runeCode : Temp_Array2_
            set !runebook %Temp_Array2_1
            set !runeindex %Temp_Array2_2
            if !runebook = !null || !runeindex = !null
                continue

            if %Config_RecallAsWraith
                gosub safecall Std_EnsureWraithForm
            gosub safecall Std_SafeUseRunebook !runebook !recallMode !runeindex
            gosub safecall Model_DetectLocation
        }
        if %Location_Name <> !destination
           continue
           
        if %Location_Name = home
        {
            gosub safecall Model_CustomHomePathfind
            gosub safecall Std_SmartPathfind %Location_X %Location_Y %Location_Z 0
        }
        if %Location_Name = bank
            gosub safecall Std_SmartPathfind %Location_X %Location_Y !null 11
        if %Location_Name = tailor || %Location_Name = smith
            gosub safecall Std_SmartPathfind %Location_X %Location_Y %Location_Z 1
        if #result <> #true
            continue ; next rune!
        return #true
    }
return #false

;=======================================
;* @name    Model_CustomHomePathfind
;* @author  AG
;* @purpose Questa sub può essere personalizzata manualmente per consentire il pathfind anche all'interno di case molto complesse.
;*          La versione che fornisco è personalizzata per casa mia, e scatta solo se i #charid sono quelli dei miei personaggi.
;* @returns #true se la destinazione viene raggiunta con successo. #false altrimenti.
;* @example gosub safecall Model_CustomHomePathfind
;* @status  Tested and working.

sub Model_CustomHomePathfind
    call AG_Routines.txt agUseHomeTeleport
return #true

;=======================================
;* @name    Std_EnsureWraithForm
;* @author  AG
;* @purpose Questa sub si assicura che il pg sia trasformato in wraith.
;* @example gosub safecall Std_EnsureWraithForm

sub Std_EnsureWraithForm
    while #true ; @todo inserire timeout
    {
        finditem #charid G_0
        if _ , #findtype , _ in _RAB_MAB_
           return
        event macro 15 116 ; CastSpell Wraith Form
        wait 4s
    }
return

;=======================================
;* @name    Model_FindBodbooks
;* @author  AG
;* @purpose Ricerca i bodbook all'interno del backpack e li riconosce in base al nome.
;* @example gosub safecall Model_FindBodbooks
;* @status  Under development.

sub Model_FindBodbooks
    set %Config_Bodbooks_Fill !null
    set %Config_Bodbooks_Keep !null
    set %Config_Bodbooks_Deliver !null
    set %Config_Bodbooks_Failed !null
    set %Config_Bodbooks_Trash !null
    finditem %Constants_Bodbook C_ , #backpackid
    if #findcnt > 0
    {
        for #findindex 1 #findcnt
        {
            set !book #findid
            gosub safecall Std_ReadProperty !book
            set !property #result
            if scarta in !property || trash in !property
                set %Config_Bodbooks_Trash !book
            if falliti in !property || riprova in !property || retry in !property || failed in !property
                set %Config_Bodbooks_Failed !book
            if consegna in !property || deliver in !property
                set %Config_Bodbooks_Deliver !book
            if conserva in !property || keep in !property
                set %Config_Bodbooks_Keep !book
            if riempi in !property || fill in !property || vuot in !property || empt in !property
                set %Config_Bodbooks_Fill !book
        }
    }
return

;=======================================
;* @name    Model_AnalyzeBod
;* @author  AG
;* @purpose Analizza un bod e riempie correttamente tutti i campi della struttura CurrentBod_.
;*          I campi sono numerosissimi:
;*          - Tutti i campi restituiti dalla sub analyzeBod di BodFunctions.euo
;*          - Campi addizionali riguardanti RequiredItems, RequiredMaterial, RequiredBones, RequiredTools, ecc.
;*          - Informazioni di filtering (%CurrentBod_Filter_Fill, %CurrentBod_Filter_Keep).
;*          - Informazioni sull'azione da intraprendere con il BOD (%CurrentBod_Action)
;*          La funzione è ottimizzata in maniera da evitare il ricalcolo inutile di informazioni già calcolate.
;* @params  %1 req  Il BOD da analizzare
;* @returns #true se l'operazione termina con successo. #false altrimenti.
;* @example gosub safecall Model_AnalyzeBod %bod

sub Model_AnalyzeBod ; %bod
    set !bod %1
    set !bones_id %Constants_Bones
    set !tailorTools %Constants_SewingKit
    set !smithTools %Constants_SmithTools

    ;-----------------
    ; Dati di base
    ;-----------------

    if !bod = %CurrentBod_Id
        gosub libcall BodFunctions.euo analyzeBod !bod CurrentBod_ q ; aggiorna solo le quantità (unico elemento variabile)
    else
        gosub libcall BodFunctions.euo analyzeBod !bod CurrentBod_ ; aggiorna tutto
    if #result <> #true
    {
       set %CurrentBod_Id !null ; evita ottimizzazione
       return #false
    }

    ;----------------------
    ; Dati di crafting
    ;----------------------
    
    if %CurrentBod_Large = #false
    {
        set %CurrentBod_RequiredItems_Id %CurrentBod_ItemId
        set %CurrentBod_RequiredItems_Color %CurrentBod_MaterialColor
        set %CurrentBod_RequiredItems_Count %CurrentBod_Quantity - %CurrentBod_FillCount
        set %CurrentBod_RequiredBones_Id !bones_id
        set %CurrentBod_RequiredBones_Color 0
        set %CurrentBod_RequiredBones_Count %CurrentBod_Bones
        set %CurrentBod_RequiredMaterial_Id %CurrentBod_MaterialId
        set %CurrentBod_RequiredMaterial_Color %CurrentBod_MaterialColor

        if %CurrentBod_Tailor
        {
            if %CurrentBod_MaterialName = cloth
            {
                set %CurrentBod_RequiredMaterial_Count %CurrentBod_Cloth
                set %CurrentBod_RequiredMaterial_Id %CurrentBod_MaterialId , _ , %Constants_CutUpCloth
            }
            else
            {
                set %CurrentBod_RequiredMaterial_Count %CurrentBod_Hides
            }
            set %CurrentBod_RequiredTools !tailorTools
        }
        else
        {
            set %CurrentBod_RequiredMaterial_Count %CurrentBod_Ingots
            set %CurrentBod_RequiredTools !smithTools
        }
    }
    
    ;--------------------------
    ; Dati di filtering
    ;--------------------------
    
    gosub safecall Model_MainBodFilter
    set %CurrentBod_Filter_Keep ( keep in #result )
    set %CurrentBod_Filter_Fill ( fill in #result )

    ;----------------
    ; Action
    ;----------------
    
    set !keep %CurrentBod_Filter_Keep
    set !fill %CurrentBod_Filter_Fill
    set !large %CurrentBod_Large
    set !filled %CurrentBod_Filled
    
    set !action fill
    if !keep
    {
        if !filled || !large || ! !fill
            set !action keep
        if !large && !filled
            set !action deliver
    }
    else
    {
        if !filled
        {
            set !action deliver
        }
        else
        {
            if !large || ! !fill
                set !action trash
        }
    }
    set %CurrentBod_Action !action
return #true

;=======================================
;* @name    Model_MainBodFilter
;* @author  AG
;* @purpose Implementa il filtro BOD principale dello script.
;*          Il filtro è configurabile per mezzo delle variabili:
;*          %Config_BodFilter_Rewards: elenco di tutti i rewards per i quali conservare large bods.
;*          %Config_BodFilter_TrashBoneBods: se #true, tutti i bod che richiedono ossa verranno trashati.
;* @returns Una stringa contenente "fill" se il bod è da riempire e "keep" se il bod è da conservare
;*          (può quindi restituire: fill, keep, fill_keep, N/A).
;* @pre     Si aspetta che i dati riguardanti il bod siano già presenti nelle variabili %CurrentBod_*.
;* @example gosub safecall Model_MainBodFilter

sub Model_MainBodFilter
    set !goodRewards %Config_BodFilter_Rewards
    set !trashBoneBods %Config_BodFilter_TrashBoneBods
    set !fill #true
    set !keep #false

    gosub safecall AG_Tokenize %CurrentBod_LargeRewards _ Temp_Array_
    set !count #result
    if !count > 0
    {
        for !i 1 !count
        {
            set !entry %Temp_Array_ . !i
            str pos !entry :
            set !len #strres - 1
            str left !entry !len
            set !reward #strres
            if !reward in !goodRewards
            {
               set !keep #true
               break
            }
        }
    }

    if !trashBoneBods && %CurrentBod_Bones > 0
    {
       set !fill #false
    }
    
    set !result !null
    if !fill
       set !result fill
    if !keep
       set !result keep
    if !fill && !keep
       set !result fill_keep
return !result

;=======================================
;* @name    Model_FillSmallBod
;* @author  AG
;* @purpose Ciclo per riempire uno small BOD, eseguendo anche operazioni ausiliarie, del tipo:
;*          - spostamento del PG nella posizione di lavoro
;*          - restockaggio risorse
;*          - restockaggio tools (o crafting)
;*          - riciclaggio item non exceptional quando necessario
;* @params  %1 req  Il BOD da riempire.
;* @returns #true se l'operazione termina con successo. Altrimenti, un codice di errore fra i seguenti:
;*          - cannot_open_work_chests
;*          - cannot_restock_material
;*          - cannot_restock_bones
;*          - cannot_restock_tools
;*          - too_many_attempts
;*          - unexpected_error
;*          - bod_is_large
;* @example gosub safecall Model_FillSmallBod %bod

sub Model_FillSmallBod ; %bod
    set !bod %1
    gosub Model_FillSmallBod_Core !bod
    set !result #result
    gosub safecall Model_RecycleItems
    if ( %Config_Bodbooks_Failed <> !null ) && ( cannot_restock in !result || too_many_attempts in !result )
    {
        gosub safecall Std_MoveObject !bod %Config_Bodbooks_Failed
    }
return !result

sub Model_FillSmallBod_Core ; %bod
    set !bod %1
    set !multiplier 1
    set !i 0
    while #true
    {
        gosub safecall Yeld
        set !i !i + 1
        gosub safecall Model_AnalyzeBod !bod
        if #result <> #true
           return unexpected_error
        if %CurrentBod_Large
           return bod_is_large
        if %CurrentBod_Filled
           return #true
        if !i > 5
        {
           if !lastResult = not_enough_material || !lastResult = not_enough_bones
              event exmsg #charid 3 0 Risorse insufficienti!
           if !lastResult = not_enough_tools
              event exmsg #charid 3 0 Crafting Tools insufficienti!
           return !lastResult
        }

        gosub safecall Model_Restock !multiplier
        if #result <> #true
        {
            if !chestsOpened = !null
            {
                set !chestsOpened #true
                gosub safecall Model_OpenChests work
                if #result <> #true
                   return cannot_open_work_chests
                continue
            }
            return #result
        }

        gosub safecall Yeld
        gosub safecall Std_FillSmallBod !bod %Config_Home_DyingTub
        set !lastResult #result
        if #result = #true || #result = not_enough_tools
           continue
        if #result = not_enough_material || #result = not_enough_bones
        {
           set !multiplier 2
           continue
        }
        return #result
    }
return too_many_attempts

;=======================================
;* @name    Model_Restock
;* @author  AG
;* @purpose Rifornisce il backpack di tutto il necessario per fillare il bod corrente.
;* @params  %1 opt  Multiplier: utilizzato per aumentare la quantità di materiale restockata (per bod difficili).
;* @returns #true se l'operazione termina con successo. #false altrimenti.
;* @pre     Bod corrente analizzato con Model_AnalyzeBod.
;* @example gosub safecall Model_Restock
;* @status  Partially tested

sub Model_Restock ; %multiplier
    if %0 < 1 || %1 = !null
       set !multiplier 1
    else
       set !multiplier %1
       
    set !source         %Config_Chests_Work
    set !material_id    %CurrentBod_RequiredMaterial_Id
    set !material_color %CurrentBod_RequiredMaterial_Color
    set !material_min   %CurrentBod_RequiredMaterial_Count * %CurrentBod_RequiredItems_Count
    set !material_max   !material_min * !multiplier
    set !bones_id       %CurrentBod_RequiredBones_Id
    set !bones_min      %CurrentBod_RequiredBones_Count * %CurrentBod_RequiredItems_Count
    set !bones_max      !bones_min * !multiplier
    set !button1        2
    if %CurrentBod_Tailor
    {
        set !tool_id %Constants_SewingKit
        set !button2 7
    }
    else
    {
        set !tool_id %Constants_Tongs
        set !button2 13
    }

    ; Restock materiali
    gosub safecall Yeld
    gosub safecall Std_RestockItem !bones_id !source #backpackid !bones_min !bones_max 0 #true
    if #result = #false
       return cannot_restock_bones

    gosub safecall Yeld
    gosub safecall Std_RestockItem !material_id !source #backpackid !material_min !material_max !material_color #true
    if #result = #false
       return cannot_restock_material

    ; Restock tools (da container)
    gosub safecall Yeld
    gosub safecall Std_RestockItem !tool_id !source #backpackid 2 2 0
    if #result = #true
       return #true

    ; Craft needed tools (5 attempts)
    chooseskill Tink
    if #skill < 350
       return cannot_restock_tools
    if !material_id = %Constants_Ingots && !material_color = 0
    {
        set !minIngots !material_min + 10
        set !maxIngots !material_max + 40
    }
    else
    {
        set !minIngots 10
        set !maxIngots 40
    }
    for !i 1 5
    {
        gosub safecall Yeld
        
        ; best-effort ingots restock (do not fail if error)
        gosub safecall Std_RestockItem %Constants_Ingots !source #backpackid !minIngots !maxIngots 0 #true

        gosub safecall Std_RestockItem %Constants_TinkersTools !source #backpackid 2 2 0
        set !craftTinkersTools ! #result

        finditem %Constants_TinkersTools C_ , #backpackid
        if #findkind = -1
           return cannot_restock_tools
        set !tinkersTools #findid
        
        if !craftTinkersTools
           gosub safecall Std_CraftItem !tinkersTools last !button1 4
        gosub safecall Std_CraftItem !tinkersTools last !button1 !button2
        
        finditem !tool_id C_ , #backpackid
        if #findkind <> -1 && #findcnt >= 2
           return #true
    }
    
    finditem !tool_id C_ , #backpackid
    if #findkind = -1
        return cannot_restock_tools
return #true

;=======================================
;* @name    Model_OpenChests
;* @version 2.0
;* @author  AG (thanks to TakilianRueshin for finding a bug)
;* @purpose Apre il gruppo di contenitori specificato (work|bank|rewards).
;* @params  %1 req  Gruppo di contenitori da aprire. Può essere: work, bank, rewards.
;*                  version 2.0: Può essere un elenco di contenitori del tipo: _location_container1_container2_location2_container3_
;*                               le location valide sono: home, bank, tailor, smith
;* @returns #true se l'operazione termina con successo. #false altrimenti.
;* @example gosub safecall Model_OpenChests work
;*          gosub safecall Model_OpenChests home_ABCDEFG_HIJKLMN
;* @status  tested

sub Model_OpenChests ; %type (work|bank|rewards)
    set !input %1
    if !input <> work && !input <> bank && !input <> rewards
       set !chests !input
    if !input = work
       set !chests home , _ , %Config_Chests_Work
    if !input = rewards
       set !chests home , _ , %Config_Chests_Rewards
    if !input = bank
       set !chests bank , _ , %Config_Chests_Bank

    gosub safecall AG_Tokenize !chests _ Model_OpenChests_Array_
    if #result <= 0
       return #false
    set !count #result

    for !i 1 !count
    {
        set !chest %Model_OpenChests_Array_ . !i
        if !chest = bank || !chest = home || !chest = smith || !chest = tailor
        {
            gosub safecall Model_ChangeLocation !chest
            if #result <> #true
               return #false
               
            if !chest = bank
               gosub safecall Std_OpenBankBox %Location_Vendor
        }
        else
        {
            gosub safecall Yeld
            set !contposx #contposx
            set !contposy #contposy
            set !contsize #contsize
            gosub safecall Std_UseObject !chest
            set !timeout #systime + 3000
            set !minTimeout #systime + 500
            while #systime < !timeout && #contposx = !contposx && #contposy = !contposy && !contsize = #contsize
            {
            }
            while #systime < !minTimeout
            {
            }
        }
    }
return #true

;=======================================
;* @name    Model_RecycleItems
;* @author  AG
;* @purpose Ricicla tutti gli item inutilizzati nel backpack, aventi tipo di oggetto uguale a quello necessario
;*          per fillare il bod corrente.
;*          Esclude a priori tutti gli item blessed ed insured.
;*          Tenta di riciclare ciò che può. Se delle operazioni falliscono, gli errori vengono ignorati.
;* @returns #true, sempre e comunque.
;* @example gosub safecall Model_RecycleItems
;* @status  Partially tested

sub Model_RecycleItems
    set !cutUpCloth %Constants_CutUpCloth
    set !trash %Config_Home_Trash
    set !type %CurrentBod_ItemID
    set !uncuttables %Constants_BoneItems
    if %CurrentBod_Tailor
        set !method cut
    else
        set !method smelt
        
    gosub safecall Yeld

    ; Ottimizzazione per uncuttables: si imposta un metodo di riciclaggio sconosciuto (trash),
    ; in modo da causare la semplice restituzione della lista di oggetti, filtrata secondo le politiche di sicurezza.
    if !type in !uncuttables
        gosub safecall Std_RecycleItems !type trash #backpackid
    else
        gosub safecall Std_RecycleItems !type !method #backpackid
    set !notRecycled #result
    
    gosub safecall Yeld
    if !method = cut
       gosub safecall Std_RecycleItems !cutUpCloth combine #backpackid

    gosub safecall AG_Tokenize !notRecycled _ Temp_Array_
    set !count #result
    if !count > 0
    {
        for !i 1 !count
        {
            set !item %Temp_Array_ . !i
            gosub safecall Std_MoveObject !item !trash
            gosub safecall Yeld
        }
    }
return #true

;=======================================
;* @name    Model_PlaceCurrentBod
;* @author  AG
;* @purpose Sposta il BOD corrente in maniera intelligente, a seconda del luogo in cui ci si trova.
;* @returns
;* @example gosub safecall Model_PlaceCurrentBod
;* @status  Partially tested

;=======================================
;* @name    Model_PlaceCurrentBod
;* @author  AG, fixed by TakilianRueshin
;* @purpose Sposta il BOD corrente in maniera intelligente, a seconda del luogo in cui ci si trova.
;* @returns
;* @example gosub safecall Model_PlaceCurrentBod
;* @status  Partially tested

sub Model_PlaceCurrentBod
    set !bod %CurrentBod_Id
    set !clsTrash %Constants_TrashBarrel
    set !location %Location_Name
    set !tailor %CurrentBod_Tailor
    set !action %CurrentBod_Action
    set !dismissBodbook #false

    gosub safecall Yeld
    if !action = keep
    {
        gosub safecall Std_MoveObject !bod %Config_Bodbooks_Keep
        set !dismissBodbook #true
    }
    if !action = trash
    {
        if %Config_Bodbooks_Trash <> !null
        {
            gosub safecall Std_MoveObject !bod %Config_Bodbooks_Trash
            set !dismissBodbook #true
        }
        else
        {
            finditem !clsTrash G_2
            if #findkind <> -1
            {
                gosub safecall Std_MoveObject !bod #findid
            }
            else
            {
                gosub safecall Std_MoveObject !bod %Config_Bodbooks_Fill
                set !dismissBodbook #true
            }
        }
    }
    if !action = deliver
    {
       if ( !tailor && !location = tailor ) || ( ! !tailor && !location = smith )
       {
           gosub safecall Std_Pathfind %Location_X %Location_Y %Location_Z
           gosub safecall Std_MoveObject !bod %Location_Vendor
       }
       else
       {
           gosub safecall Std_MoveObject !bod %Config_Bodbooks_Deliver
           set !dismissBodbook #true
       }
    }
    if !action = fill
    {
        gosub safecall Std_MoveObject !bod %Config_Bodbooks_Fill
        set !dismissBodbook #true
    }
    if !dismissBodbook
    {
        set !timeout #systime + 3000
        while #systime < !timeout && #contsize <> 615_454 ; dismiss bodbook
        {
        }
        if #contsize = 615_454
        {
            set !x #contposx + 50
            set !y #contposy + 50
            click !x !y r
        }
    }
return

sub Model_PlaceCurrentBod_old ; before Takilian's fix
    set !bod %CurrentBod_Id
    set !clsTrash %Constants_TrashBarrel
    set !location %Location_Name
    set !tailor %CurrentBod_Tailor
    set !action %CurrentBod_Action
    set !dismissBodbook #false

    gosub safecall Yeld
    if !action = keep
    {
        gosub safecall Std_MoveObject !bod %Config_Bodbooks_Keep
        set !dismissBodbook #true
    }
    if !action = trash
    {
        if %Config_Bodbooks_Trash <> !null
        {
            gosub safecall Std_MoveObject !bod %Config_Bodbooks_Trash
        }
        else
        {
            finditem !clsTrash G_2
            if #findkind <> -1
            {
                gosub safecall Std_MoveObject !bod #findid
            }
            else
            {
                gosub safecall Std_MoveObject !bod %Config_Bodbooks_Fill
                set !dismissBodbook #true
            }
        }
    }
    if !action = deliver
    {
       if ( !tailor && !location = tailor ) || ( ! !tailor && !location = smith )
       {
           gosub safecall Std_Pathfind %Location_X %Location_Y %Location_Z
           gosub safecall Std_MoveObject !bod %Location_Vendor
       }
       else
       {
           gosub safecall Std_MoveObject !bod %Config_Bodbooks_Deliver
           set !dismissBodbook #true
       }
    }
    if !action = fill
    {
        gosub safecall Std_MoveObject !bod %Config_Bodbooks_Fill
        set !dismissBodbook #true
    }
    if !dismissBodbook
    {
        set !timeout #systime + 3000
        while #systime < !timeout && #contsize <> 615_454 ; dismiss bodbook
        {
        }
        if #contsize = 615_454
        {
            set !x #contposx + 50
            set !y #contposy + 50
            click !x !y r
        }
    }
return

;=======================================
;* @name    Model_FillSmallBodCycle
;* @author  AG
;* @purpose Riempie small bods a ripetizione, estraendoli dai bodbooks.
;* @params  %1 opt  Numero di iterazioni da eseguire. Se non specificato, si itera all'infinito.
;* @returns #true se tutte le iterazioni sono terminate. Un codice di errore in caso contrario.
;* @example gosub safecall Model_FillSmallBodCycle 20
;* @status  Under development

sub Model_FillSmallBodCycle
    if %0 < 1 || ! ( %1 > 0 )
       set !iterations 10000
    else
       set !iterations %1

    ; @todo: Eliminare algoritmo di alternanza (deprecato)
    set !bodbook1 %Config_Bodbooks_Fill
    set !bodbook2 %Config_Bodbooks_Fill
    set !bodbook !bodbook1
    set !alternate !bodbook1 <> !bodbook2

    set !i 1
    while #true
    {
        if !i > !iterations
           break
           
        gosub safecall DoTasks
        gosub safecall Model_ChangeLocation home
        if #result = #false
           return cannot_change_location
        if h notin #charstatus
           event macro 13 21 ; Useskill Hiding
           
        finditem %Constants_Bod C_ , #backpackid
        if #findkind = -1
        {
            if !alternate
            {
               if !bodbook = !bodbook1
                  set !bodbook !bodbook2
               else
                  set !bodbook !bodbook1
            }

            gosub safecall Std_ExtractBod !bodbook
            if #result = #false
            {
               set !alternate #false ; smettila di alternare se uno dei due bodbook è vuoto!
               if !bodbook = !bodbook1
                  set !bodbook !bodbook2
               else
                  set !bodbook !bodbook1

               gosub safecall Std_ExtractBod !bodbook
               if #result = #false
                  return empty_bodbooks
            }
            continue
        }
        set !bod #findid

        gosub safecall Model_AnalyzeBod !bod

        if %CurrentBod_Action = fill
        {
           gosub safecall Model_FillSmallBod !bod
           if #result = cannot_restock_tools
           {
               return #result
           }
           ; @todo aggiornare statistiche
           set !i !i + 1
           gosub safecall Model_AnalyzeBod !bod
        }

        gosub safecall Model_PlaceCurrentBod
        ; @todo aggiornare statistiche
    }
return #true

;=======================================
;* @name    Model_DeliverBodCycle
;* @author  AG
;* @purpose Consegna small bods a ripetizione, estraendoli dai bodbooks.
;*          Richiede nuovi bod al vendor man mano che consegna.
;*          Si ferma se il peso è eccessivo a causa dei troppi premi ricevuti.
;* @params  %1 req  A chi consegnare? Può essere: tailor, smith.
;*          %2 opt  Numero di iterazioni da eseguire. Se non specificato, si itera all'infinito.
;* @returns #true se tutte le iterazioni sono terminate. Un codice di errore in caso contrario.
;* @example gosub safecall Model_DeliverBodCycle tailor 20
;* @status  Under development

sub Model_DeliverBodCycle ; %location %iterations
    if %0 < 1 || ( %1 <> tailor && %1 <> smith )
    {
        event exmsg #charid 3 0 Unexpected value for location: %1
        return invalid_params
    }
    set !location %1
    set !tailor !location = tailor
    if %0 < 2 || ! ( %2 > 0 )
       set !iterations 10000
    else
       set !iterations %2
    set !bodbook %Config_Bodbooks_Deliver
    set !clsBod %Constants_Bod
    
    gosub safecall Yeld
    event exmsg #charid 3 0 Vado a consegnare i BOD !location , #dot
    gosub safecall Std_SetBodbookFilter !bodbook all all !location all

    set !delivered 0
    while #true
    {
        if !delivered > !iterations
           return #true
           
        gosub safecall DoTasks
        gosub safecall Yeld
        gosub safecall Std_CheckOverweight 50 15
        if #result <> #false
           return overweight

        ; cerca bod nel backpack
        finditem !clsBod C_ , #backpackid
        if #findkind = -1
        {
            gosub safecall Std_ExtractBod !bodbook
            if #result = #false
                return no_more_bods
            continue
        }
        set !bod #findid

        gosub safecall Model_AnalyzeBod !bod
        if #result <> #true
            continue

        if %CurrentBod_Tailor <> !tailor
        {
            gosub safecall Model_PlaceCurrentBod
            gosub safecall Yeld
            gosub safecall Std_SetBodbookFilter !bodbook small all !location all
            continue
        }
        if %CurrentBod_Action <> deliver
        {
            gosub safecall Model_PlaceCurrentBod
            continue
        }
        
        gosub safecall Model_DetectLocation ; extra check for stability
        if %Location_Name <> !location
        {
            gosub safecall Model_ChangeLocation !location
            if #result = #false
               return cannot_change_location
        }
        set !vendor %Location_Vendor
        
        if !delivered = 0
           gosub safecall Std_AskNewBod !vendor
        gosub safecall Model_PlaceCurrentBod !bod
        gosub safecall Yeld
        gosub safecall Std_AskNewBod !vendor
        set !delivered !delivered + 1
    }
return #true

sub Model_AnalyzeRunebook ; %runebook
    set !runebook %1
    set !recallMode %Config_RecallMode

    set !result
    for !i 1 16
    {
        if !no_more_runes = #true
        {
           set !result !result , x
           continue
        }
        while #mana < 20
        {
           gosub safecall Yeld
           event exmsg #charid 3 0 Troppo poco mana! 15 secondi di meditazione.
           event macro 13 46 ; UseSkill Meditation
           wait 15s
        }
        gosub safecall Yeld
        gosub safecall Std_SafeUseRunebook !runebook !recallMode !i
        if #result = #false
        {
           event exmsg #charid 3 0 Runebook terminato.
           set !no_more_runes #true
           set !result !result , x
           continue
        }
        gosub safecall Model_DetectLocation
        if %Location_Name = unknown
           event exmsg #charid 3 0 Non riconosco questo luogo.
        if %Location_Name = smith
           event exmsg #charid 3 0 Ho trovato un fabbro!
        if %Location_Name = tailor
           event exmsg #charid 3 0 Ho trovato un sarto!
        if %Location_Name = bank
           event exmsg #charid 3 0 Ho trovato una banca!
        if %Location_Name = home
           event exmsg #charid 3 0 Ho trovato casa!
        str left %Location_Name 1
        set !result !result , #strres
    }
return !result

sub Model_PlaceObjects ; %customList
    set !objectTypes %Constants_Resources_Types , _ , %Constants_Rewards_Types , _ , %Constants_Bod

    if %0 < 1 || %1 = !null
    {
        finditem !objectTypes C_ , #backpackid
        if #findkind = -1
            return #true
        set !objects_count #findcnt
        if !objects_count > 0
        {
            for #findindex 1 #findcnt
            {
                set !objects_ . #findindex #findid
            }
        }
    }
    else
    {
        gosub safecall AG_Tokenize %1 _ Temp_Array_
        set !objects_count #result
        if !objects_count <= 0
            return #true
        if !objects_count > 0
        {
            for !i 1 !objects_count
            {
                set !objects_ . !i %Temp_Array_ . !i
            }
        }
    }
    
    gosub safecall Model_ChangeLocation home

    for !i 1 !objects_count
    {
        set !object !objects_ . !i
        finditem !object C_ , #backpackid
        if #findkind = -1
            continue
        set !type #findtype
        set !quantity #findstack
        
        if !type = %Constants_Bod
        {
            gosub safecall Model_AnalyzeBod !object
            gosub safecall Model_PlaceCurrentBod
            continue
        }

        gosub safecall Std_IdentifyObject !object
        if #result = #false
            set !code !null
        else
            set !code #result
        set !chestType !null
        if !code in %Constants_Rewards_All
        {
            if !code notin %Config_RewardFilter_Rewards ; trash or recycle
            {
                gosub safecall Yeld
                if !type = %Constants_Cloth
                    gosub safecall Std_UseObject %Config_Home_DyingTub !object
                else
                    gosub safecall Std_MoveObject !object %Config_Home_Trash !quantity
                continue
            }
            set !chestType rewards
        }
        if !code in %Constants_Resources_All
        {
            set !chestType work
        }
        if !chestType = !null ; unrecognized object
        {
            continue
        }

        if !chests_ . !chestType = !null
        {
            gosub safecall Model_OpenChests !chestType
            if #result = #false
               set !chests_ . !chestType #false
            else
               set !chests_ . !chestType %Config_Chests_ . !chestType
        }
        if !chests_ . !chestType = #false
        {
            continue
        }

        gosub safecall Yeld
        set !containers !chests_ . !chestType
        gosub safecall Std_GetMostAffineContainer !containers !object ; @todo ottimizzare con caching risultati
        set !destination #result
        gosub safecall Std_MoveObject !object !destination !quantity
    }
return #true

;=======================================
;* @name    Model_RecallingRestock
;* @author  AG
;* @purpose Effettua il restock di oggetti anche da containers che si trovano in luoghi diversi.
;*          Gli unici luoghi supportati al momento sono quelli definiti per lo script: home, bank, tailor, smith.
;* @params  %1 req  Lista di contenitori sorgente. E' possibile specificare una location all'inizio della lista.
;*          %2 req  Lista di contenitori destinazione. E' possibile specificare una location all'inizio della lista.
;*          %3 req  ID del tipo di oggetto da restockare.
;*          %4 opt  Colore del tipo di oggetti da restockare. Default = 0.
;*          %5 opt  Peso di un singolo oggetto del tipo da restockare. Se non specificato, la sub lo calcolerà automaticamente.
;* @returns #true se l'operazione va a buon fine. #false altrimenti.
;* @example gosub safecall Model_RecallingRestock %source %dest %materialId %materialColor %materialWeight
;* @status  Under development

sub Model_RecallingRestock ; %source %dest %materialId %materialColor %materialWeight %maxRestock
    set !source %1
    set !dest %2
    set !materialId %3
    if %0 < 4 || %4 = !null
        set !materialColor 0
    else
        set !materialColor %4
    if %0 < 5
        set !materialWeight !null
    else
        set !materialWeight %5
    if %0 < 6
        set !maxRestock 60000
    else
        set !maxRestock %6

    if !materialWeight = !null
    {
        gosub safecall Std_GetObjectWeight !materialId
        if ! ( #result > 0 )
        {
            gosub safecall Model_OpenChests !source
            gosub safecall Std_GetObjectWeight !materialId
            if ! ( #result > 0 )
                return #false
        }
        set !materialWeight #result
    }

    gosub safecall Helper_StripLocation !source
    set !sourceChests #result
    gosub safecall Helper_StripLocation !dest
    set !destChests #result
    set !minQuantity 1

    while #true
    {
        set !maxQuantity ( #maxweight - #weight - 20 ) * 1000 / !materialWeight
        gosub safecall Std_GetObjectCount C_ , #backpackid !materialId !materialColor
        set !maxQuantity !maxQuantity + #result

        gosub safecall Model_OpenChests !source
        if #result = #false
            break

        gosub safecall Yeld
        gosub safecall Std_RestockItem !materialId !sourceChests #backpackid !minQuantity !maxQuantity !materialColor #true
        if #result = #false
            break

        gosub safecall Model_OpenChests !dest
        if #result = #false
            break

        gosub safecall Std_GetMostAffineContainer !destChests !materialId !materialColor !null
        set !destChest #result
        gosub safecall Yeld
        gosub safecall Std_RestockItem !materialId #backpackid !destChest !maxRestock !maxRestock !materialColor #false
        if #result = #true
            break
    }
return #true

sub Helper_StripLocation ; %input
    set !input %1
    set !location !null
    if home_ in !input
       set !location home_
    if bank_ in !input
       set !location bank_
    if tailor_ in !input
       set !location tailor_
    if smith_ in !input
       set !location smith_
    if !location = !null
       return !input

    str pos !input !location
    set !index #strres
    str len !location
    set !index !index + #strres - 1
    str del !input 1 !index
return #strres

;=======================================
;* @name    Model_BankRestock
;* @author  AG
;* @purpose Effettua il restock di oggetti dalla banca verso i containers a casa.
;* @params  %1 req  Lista di risorse da restockare, nella forma _id:color_id:color_.
;* @example gosub safecall Model_BankRestock %Constants_Resources_All

sub Model_BankRestock ; %resourceList
    set !resources %1
    gosub safecall AG_Tokenize !resources _ Model_BankRestock_List_
    set !count #result
    if !count <= 0
        return

    set !source bank_ , %Config_Chests_Bank
    set !dest home_ , %Config_Chests_Work
    for !i 1 !count
    {
        set !code %Model_BankRestock_List_ . !i
        gosub safecall Model_GetHumanName !code
        if #result = !null
           set #result Item
        event exmsg #charid 3 0 Restocking #result , #dot
        
        gosub safecall AG_Tokenize !code : Temp_Array_
        set !type %Temp_Array_1
        set !color %Temp_Array_2
        set !weight !null
        if !type in %Constants_Resources_Light
           set !weight 100
        if !type in %Constants_Resources_Heavy
           set !weight 1000
        gosub safecall Model_RecallingRestock !source !dest !type !color !weight
    }
return

;=======================================
;* @name    Model_FillLargeBodCycle
;* @author  AG
;* @purpose Ciclo per riempire tutti i bod large che si trovano nel bodbook "da conservare".
;* @example gosub safecall Model_FillLargeBodCycle
;* @status  Under development

sub Model_FillLargeBodCycle
    set !book %Config_Bodbooks_Keep
    set !clsBod %Constants_Bod
    
    while #true
    {
        ;---------------------------------
        ; Fase 1: Estrazione large BODs
        ;---------------------------------

        if !moreSmall <> #true
        {
            ; rimetti a posto tutti i bod nel backpack
            gosub safecall Model_PlaceObjects

            ; estrai un bod large
            gosub safecall Yeld
            gosub safecall Std_SetBodbookFilter !book large all all all
            gosub safecall Std_ExtractBod !book
            if #result = #false
                break
            finditem !clsBod C_ , #backpackid
            if #findkind = -1 ; should never happen
                break
            set !largebod #findid

            ; analizza il bod corrente
            set !timeout #systime + 3000
            repeat
                gosub libcall BodFunctions.euo AnalyzeBod !largebod Model_FillLargeBod_ obmq
            until #result = #true || #systime > !timeout
            if #result = #false
                continue ; error

            set !material %Model_FillLargeBod_MaterialName
            set !quantity %Model_FillLargeBod_Quantity
            if %Model_FillLargeBod_Exceptional
               set !exceptional exceptional
            else
               set !exceptional normal

            ; salva la tipologia di filtro, in maniera da non ripeterla in seguito
            set !filterId !exceptional , _ , !material , _ , !quantity
            if !firstFilterId = !null
            {
                set !firstFilterId !filterId
            }
            else
            {
                if !firstFilterId = !filterId
                {
                    event exmsg #charid 3 0 Ho analizzato l'intero libro.
                    break
                }
            }

            ; estrai i bod simili a quello corrente (solo large)
            gosub safecall Yeld
            gosub safecall Std_SetBodbookFilter !book large !exceptional !material !quantity
            gosub safecall Std_ExtractBod !book all
        }
        
        ;-----------------------------
        ; Fase 2: Analisi large BODs
        ;-----------------------------

        event exmsg #charid 3 0 Sto analizzando i large BOD nel backpack.

        ; salva tutti i large bod estratti in !listLarge
        set !listLarge_count 0
        set !listLarge_string _
        finditem !clsBod C_ , #backpackid
        if #findkind <> -1
        {
            for #findindex 1 #findcnt
            {
                set !listLarge_count !listLarge_count + 1
                set !listLarge_ . !listLarge_count #findid
                set !listLarge_string !listLarge_string , #findid , _
            }
        }
        if !listLarge_count = 0
        {
            event exmsg #charid 3 0 Comportamento inatteso...
            continue
        }

        ; riempi le liste list0...list6 in base al valore di Quantity - FillCount
        set !list0_count 0
        set !list1_count 0
        set !list2_count 0
        set !list3_count 0
        set !list4_count 0
        set !list5_count 0
        set !list6_count 0
        for !i 1 !listLarge_count
        {
            set !bod !listLarge_ . !i
            set !timeout #systime + 3000
            repeat
                gosub libcall BodFunctions.euo AnalyzeBod !bod Model_FillLargeBod_ obmq
            until #result = #true || #systime > !timeout
            if #result = #false
                continue

            set !leftCount %Model_FillLargeBod_Cardinality - %Model_FillLargeBod_FillCount
            set !listname list , !leftCount , _
            
            ; aggiorna list[i]_count
            set !varname !listname , count
            set !count ! . !varname
            set !count !count + 1
            set ! . !varname !count
            
            ; aggiungi a list[i]
            set !varname !listname , !count
            set ! . !varname !bod
        }

        ;----------------------------------
        ; Fase 3: Estrazione small BODs
        ;----------------------------------

        ; estrai i bod simili a quello corrente (solo small)
        gosub safecall Yeld
        gosub safecall Std_SetBodbookFilter !book small !exceptional !material !quantity
        gosub safecall Std_ExtractBod !book 25

        ; salva gli small bod estratti dentro !listSmall
        set !listSmall_string _
        set !listSmall_count 0
        finditem !clsBod C_ , #backpackid
        if #findkind <> -1
        {
            for #findindex 1 #findcnt
            {
                if #findid in !listLarge_string ; ignora i bod large
                   continue
                set !listSmall_count !listSmall_count + 1
                set !listSmall_ . !listSmall_count #findid
                set !listSmall_string !listSmall_string , #findid , _
            }
        }
        
        ;----------------------------------
        ; Fase 4: Fillaggio
        ;----------------------------------

        if !listSmall_count > 0
        {
            for !i 1 6 ; itera attraverso le liste
            {
                set !listname list , !i , _
                set !varname !listname , count
                set !list_count ! . !varname
                if !list_count = 0
                   continue

                for !j 1 !list_count ; itera nella lista corrente
                {
                    set !varname !listname , !j
                    set !largebod ! . !varname

                    gosub safecall Yeld
                    gosub safecall Std_UseObject !largebod
                    gosub safecall Std_WaitForBodGump
                    if #result = #false
                       continue ; fallimento

                    for !k 1 !listSmall_count ; itera fra gli small bods
                    {
                        set !smallbod !listSmall_ . !k

                        finditem !smallbod C_ , #backpackid
                        if #findkind = -1
                            continue

                        gosub safecall Yeld
                        gosub safecall Std_ClickBodGumpButton fill
                        gosub safecall Std_SelectTarget !smallbod
                        if #result = #false ; mirino non visualizzato: probabilmente il large bod è pieno
                            break
                    }

                    ; dismiss gump if opened
                    gosub safecall Std_CheckForBodGump
                    if #result = #true
                        gosub safecall Std_ClickBodGumpButton exit
                    if #targcurs = 1
                        set #targcurs 0
                }
            }
        }
        
        ; ci sono ancora small da estrarre se "ne erano stati estratti 25 o più" e "ne è stato inserito almeno uno" (evita cicli)
        finditem !listSmall_string C_ , #backpackid
        set !smallbod_count #findcnt
        set !moreSmall ( !listSmall_count >= 25 ) && ( !smallbod_count < !listSmall_count )

        ; piccolo trucco per "ingannare" lo script nel caso di bod misti cloth + leather
        if ( !material = cloth ) && ( !moreSmall = #false )
        {
            set !material leather
            set !moreSmall #true
        }

        gosub safecall Model_PlaceObjects !listSmall_string ; sposta solo i bod small
    }
    
    gosub safecall Model_PlaceObjects
return

sub Model_FullCycle
    while #true
    {
        gosub safecall Model_PlaceObjects
        gosub safecall Model_FillSmallBodCycle 20
        gosub safecall Model_DeliverBodCycle tailor
        gosub safecall Model_PlaceObjects
        gosub safecall Model_DeliverBodCycle smith
    }
return



;==========================================================
;=
;=
;=    FUNZIONI DI INTERFACCIA GRAFICA (prefisso "View")
;=
;=
;==========================================================

;=======================================
;* @name    View_MenuLoop
;* @author  AG
;* @purpose Loop che cicla da un menu all'altro a seconda del valore di %Menu_Name.
;*          Se %Menu_Name viene impostato su un valore non valido, la funzione ritorna (usare questo sistama per uscire).
;* @params  %1 req  Menu di partenza. I valori ammessi sono: View_GeneralMenu, View_BodFilterMenu, View_RewardFilterMenu, ecc.
;* @example gosub safecall View_MenuLoop View_GeneralMenu

sub View_MenuLoop
    set %Menu_Name %1
    while #true
    {
        if ( | , %Menu_Name , | ) notin |View_GeneralMenu|View_BodFilterMenu|View_RewardFilterMenu|
           break
        gosub safecall Std_RunMenu %Menu_Name
        set %Menu_Name #result
    }
return

;=======================================
;* @name    View_SetStatusMessage
;* @author  AG
;* @purpose Routine generica per impostare il messaggio di stato della GUI corrente.
;*          La GUI deve essere dotata di una label chiamata LblStatus.
;* @params  Tutti i parametri forniti vengono fusi in un testo di messaggio, usando #spc come separatore.
;* @note    La sub può essere utilizzata anche senza safecall.
;*          In particolare, se gli argomenti sono troppi (più di 10), safecall NON PUO' essere utilizzato.
;* @example gosub View_SetStatusMessage Questo è un messaggio.

sub View_SetStatusMessage ; %1...->
    namespace push
    namespace local View_SetStatusMessage , #systime , #random
    set !msg
    if %0 > 0
    {
        for !i 1 %0
        {
            set !arg % . !i
            set !msg !msg , !arg , #spc
        }
    }
    menu set LblStatus !msg
    namespace pop
    namespace clear
return

;=======================================
;* @name    View_GeneralMenu_Init
;* @author  AG (using EasyUO Menu Designer)
;* @purpose Crea il menu generale.
;* @example gosub safecall View_GeneralMenu_Init

sub View_GeneralMenu_Init
	menu Clear
	menu Window Title Boscags7
	menu Window Color Black
	menu Window Size 305 455
	menu Font Transparent #true
	menu Font Align Right
	menu Shape EUOShape1 4 31 297 387 3 7 2 Blue 7 Black
	menu Shape EUOShape8 154 288 146 5 3 7 1 Blue 7 Black
	menu Shape EUOShape5 4 4 97 33 4 7 2 Blue 7 Black
	menu Shape EUOShape4 5 32 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape6 5 412 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape7 151 36 4 361 3 7 1 Blue 7 Black
	menu Shape EUOShape2 5 136 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape3 5 232 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape9 5 392 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape10 154 292 146 101 3 7 1 Blue 7 Navy
	menu Font Name Tahoma
	menu Font Size 10
	menu Font Style b
	menu Font Color Aqua
	menu Font Align Left
	menu Font BGColor Black
	menu Text EUOLabel21 23 9 Generale
	menu Font Name MS Sans Serif
	menu Font Style
	menu Font Color Lime
	menu Text EUOLabel7 12 44 Casa
	menu Text EUOLabel11 160 44 Runebooks
	menu Text EUOLabel24 12 148 Contenitori
	menu Text EUOLabel28 160 148 BOD-Books
	menu Text EUOLabel32 12 244 Strumenti
	menu Font Size 8
	menu Font Color White
	menu Text EUOLabel4 12 116 Dying Tub
	menu Text EUOLabel3 12 104 Trash Barrel
	menu Text EUOLabel2 12 92 Incudine
	menu Text EUOLabel1 12 80 Forgia
	menu Text EUOLabel14 12 68 Coordinate
	menu Text LblHomeTub 92 116 ?
	menu Text LblHomeTrash 92 104 ?
	menu Text LblHomeAnvil 92 92 ?
	menu Text LblHomeForge 92 80 ?
	menu Text LblHomePosition 92 68 ?
	menu Text EUOLabel12 160 68 Casa
	menu Text EUOLabel13 160 80 Banca
	menu Text EUOLabel15 160 92 Sarto
	menu Text EUOLabel16 160 104 Fabbro
	menu Text EUOLabel17 160 116 Skill
	menu Text LblRunebookSkill 240 116 ?
	menu Text LblRunebookSmith 240 104 ?
	menu Text LblRunebookTailor 240 92 ?
	menu Text LblRunebookHome 240 68 ?
	menu Text LblRunebookBank 240 80 ?
	menu Text EUOLabel25 12 172 Risorse (casa)
	menu Text EUOLabel26 12 192 Risorse (banca)
	menu Text EUOLabel27 12 212 Premi
	menu Text EUOLabel29 160 172 Da riempire
	menu Text EUOLabel30 160 184 Da consegnare
	menu Text EUOLabel31 160 196 Da conservare
	menu Text LblStatus 12 398 Pronto
	menu Font Name Times New Roman
	menu Font Size 16
	menu Font Style bi
	menu Font Color Aqua
	menu Font BGColor White
	menu Text EUOLabel35 190 296 Boscags7
	menu Font Size 8
	menu Font Style i
	menu Font Color Lime
	menu Text EUOLabel36 165 321 The Ultimate Bodding Tool
	menu Font Style
	menu Font Color White
	menu Text EUOLabel37 190 336 - by kusanagi97 -
	menu Font Color Gray
	menu Text EUOLabel38 168 372 Boydon, Scorna, Snicker7
	menu Text EUOLabel39 168 360 many thanks to:
	menu Font Name MS Sans Serif
	menu Font Color White
	menu Font BGColor Black
	menu Text EUOLabel5 160 208 Da ritentare
	menu Text LblBodbookFill 240 172 ?
	menu Text LblBodbookDeliver 240 184 ?
	menu Text LblBodbookKeep 240 196 ?
	menu Text LblBodbookFailed 240 208 ?
	menu Font Size 10
	menu Font Color Lime
	menu Text EUOLabel6 160 244 Opzioni Avanzate
	menu Font Name Tahoma
	menu Font Style b
	menu Font Color Teal
	menu Button BtnRewardFilter 104 4 98 25 Filtro Premi
	menu Button BtnBodFilter 204 4 98 25 Filtro BOD
	menu Font Color Lime
	menu Button BtnStart 204 424 98 25 Avvia
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color White
	menu Check ChkToolCycle 12 368 53 17 #false cicla
	menu Font Name Tahoma
	menu Font Size 7
	menu Font Color Lime
	menu Button BtnSetHome 92 44 26 17 SET
	menu Button BtnSetRunebooks 240 44 26 17 SET
	menu Button BtnSetWorkChests 92 168 26 17 SET
	menu Button BtnSetBankChests 92 188 26 17 SET
	menu Button BtnSetRewardChests 92 208 26 17 SET
	menu Button BtnShowHome 120 44 26 17 GO
	menu Button BtnShowWorkChests 120 168 26 17 USE
	menu Button BtnShowBankChests 120 188 26 17 USE
	menu Button BtnShowRewardChests 120 208 26 17 USE
	menu Button BtnExecuteTool 92 368 54 17 ESEGUI
	menu Button BtnBodbooksHelp 268 148 26 17 ?
	menu Button BtnSetBodbooks 240 148 26 17 SET
	menu Font Color Gray
	menu Button BtnAdvancedOptions 160 264 134 17 VISUALIZZA
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Color Blue
	menu Font BGColor White
	menu List Create LstTools 12 264 133 101
	menu Font BGColor Black

	; dynamic code begin
	gosub safecall AG_Tokenize %Constants_Tools | View_GeneralMenu_Tools_
	set !count #result
	if !count > 0
	{
      for !i 1 !count
      {
          set !tool %View_GeneralMenu_Tools_ . !i
          gosub safecall Model_GetHumanName !tool
          set !name #result
          menu List Add LstTools !name
      }
	}
	; dynamic code end
	
	menu Show
return |LstTools|ChkToolCycle|LblStatus|

sub View_GeneralMenu_Idle
    set !no ?
    set !yes OK

    if %Config_Home_DyingTub = !null
  	    menu set LblHomeTub !no
    else
  	    menu set LblHomeTub !yes

    if %Config_Home_Trash = !null
  	    menu set LblHomeTrash !no
    else
  	    menu set LblHomeTrash !yes

    if %Config_Home_Anvil = !null
  	    menu set LblHomeAnvil !no
    else
  	    menu set LblHomeAnvil !yes

    if %Config_Home_Forge = !null
  	    menu set LblHomeForge !no
    else
  	    menu set LblHomeForge !yes

    if %Config_Home_PosX = !null || %Config_Home_PosY = !null || %Config_Home_PosZ = !null
  	    menu set LblHomePosition !no
    else
  	    menu set LblHomePosition !yes
  	    
    if %Config_Bodbooks_Fill = !null
  	    menu set LblBodbookFill !no
    else
  	    menu set LblBodbookFill !yes

    if %Config_Bodbooks_Deliver = !null
  	    menu set LblBodbookDeliver !no
    else
  	    menu set LblBodbookDeliver !yes

    if %Config_Bodbooks_Keep = !null
  	    menu set LblBodbookKeep !no
    else
  	    menu set LblBodbookKeep !yes

    if %Config_Bodbooks_Failed = !null
  	    menu set LblBodbookFailed !no
    else
  	    menu set LblBodbookFailed !yes

    set !recallMode !no
    if %Config_RecallMode = recall
       set !recallMode Magery
    if %Config_RecallMode = journey
       set !recallMode Chivalry
    if %Config_RecallAsWraith
       set !recallMode Necromancy
  	menu set LblRunebookSkill !recallMode

  	gosub safecall AG_Tokenize %Config_Runebooks_Home _ %Temp_Array_
  	if #result = 1
        menu set LblRunebookHome #result , #spc , runa
    else
        menu set LblRunebookHome #result , #spc , rune

  	gosub safecall AG_Tokenize %Config_Runebooks_Bank _ %Temp_Array_
  	if #result = 1
        menu set LblRunebookBank #result , #spc , runa
    else
        menu set LblRunebookBank #result , #spc , rune

  	gosub safecall AG_Tokenize %Config_Runebooks_Tailor _ %Temp_Array_
  	if #result = 1
        menu set LblRunebookTailor #result , #spc , runa
    else
        menu set LblRunebookTailor #result , #spc , rune

  	gosub safecall AG_Tokenize %Config_Runebooks_Smith _ %Temp_Array_
  	if #result = 1
        menu set LblRunebookSmith #result , #spc , runa
    else
        menu set LblRunebookSmith #result , #spc , rune

    gosub View_SetStatusMessage Pronto.
    gosub safecall Model_SaveConfig
return

sub View_GeneralMenu_BtnGeneral
    gosub safecall Std_CloseMenu %Menu_Name View_GeneralMenu
return

sub View_GeneralMenu_BtnRewardFilter
    gosub safecall Std_CloseMenu %Menu_Name View_RewardFilterMenu
return

sub View_GeneralMenu_BtnBodFilter
    gosub safecall Std_CloseMenu %Menu_Name View_BodFilterMenu
return

sub View_GeneralMenu_BtnStart
    menu hide
    gosub safecall Model_FullCycle
return

sub View_GeneralMenu_Closed
    gosub safecall Std_CloseMenu %Menu_Name Quit
return

sub View_GeneralMenu_BtnSetHome
    gosub View_SetStatusMessage Analisi della posizione corrente...
    gosub safecall Ctrl_SetHomePosition
return
sub View_GeneralMenu_BtnShowHome
    gosub View_SetStatusMessage Movimento verso la posizione a casa...
    gosub safecall Model_ChangeLocation home
return

sub View_GeneralMenu_BtnSetRunebooks
    gosub View_SetStatusMessage Impostazione dei runebooks...
    gosub safecall Ctrl_AnalyzeRunebooks
return
sub View_GeneralMenu_BtnShowRunebooks
    gosub View_SetStatusMessage Non ancora implementato. ; @todo
    ; @todo
return

sub View_GeneralMenu_BtnSetWorkChests
    gosub View_SetStatusMessage Impostazione contenitori di risorse in casa...
    gosub safecall Ctrl_SelectChests work
return
sub View_GeneralMenu_BtnSetBankChests
    gosub View_SetStatusMessage Impostazione contenitori di risorse in banca...
    gosub safecall Ctrl_SelectChests bank
return
sub View_GeneralMenu_BtnSetRewardChests
    gosub View_SetStatusMessage Impostazione contenitori per i premi...
    gosub safecall Ctrl_SelectChests rewards
return
sub View_GeneralMenu_BtnShowWorkChests
    gosub View_SetStatusMessage Apertura contenitori di risorse in casa...
    gosub safecall Model_OpenChests work
return
sub View_GeneralMenu_BtnShowBankChests
    gosub View_SetStatusMessage Apertura contenitori di risorse in banca...
    gosub safecall Model_OpenChests bank
return
sub View_GeneralMenu_BtnShowRewardChests
    gosub View_SetStatusMessage Apertura contenitori di risorse per i premi...
    gosub safecall Model_OpenChests rewards
return

;--- deprecated ---;
sub View_GeneralMenu_BtnSetBodbookFill
    gosub View_SetStatusMessage Impostazione BodBook per i BOD da riempire...
    gosub safecall Ctrl_SelectBodBook fill
return
sub View_GeneralMenu_BtnSetBodbookDeliver
    gosub View_SetStatusMessage Impostazione BodBook per i BOD da consegnare...
    gosub safecall Ctrl_SelectBodBook deliver
return
sub View_GeneralMenu_BtnSetBodbookKeep
    gosub View_SetStatusMessage Impostazione BodBook per i BOD da conservare...
    gosub safecall Ctrl_SelectBodBook keep
return
sub View_GeneralMenu_BtnShowBodbookFill
    gosub View_SetStatusMessage Apertura BodBook per i BOD da riempire...
    gosub safecall Std_UseObject %Config_Bodbooks_Fill
return
sub View_GeneralMenu_BtnShowBodbookDeliver
    gosub View_SetStatusMessage Apertura BodBook per i BOD da consegnare...
    gosub safecall Std_UseObject %Config_Bodbooks_Deliver
return
sub View_GeneralMenu_BtnShowBodbookKeep
    gosub View_SetStatusMessage Apertura BodBook per i BOD da conservare...
    gosub safecall Std_UseObject %Config_Bodbooks_Keep
return
;--- end of deprecated ---;

sub View_GeneralMenu_BtnSetBodbooks
    gosub View_SetStatusMessage Scansione dei Bodbook nel backpack...
    gosub safecall Model_FindBodbooks
return
sub View_GeneralMenu_BtnBodbooksHelp
    gosub View_SetStatusMessage Visualizzazione aiuto per "Set Bodbooks"...
    display ok Per essere riconosciuto, un Bodbook deve contenere nel nome una delle seguenti diciture:$
               +- Da riempire: riempi / vuoti / fill / empty$
               +- Da consegnare: consegna / deliver$
               +- Da conservare: conserva / keep$
               +- Da riprovare: riprova / falliti / retry / failed$
               +- Da scartare (debug): scarta / trash$
return

sub View_GeneralMenu_BtnAdvancedOptions
    gosub View_SetStatusMessage Non ancora implementato. ; @todo
return

sub View_GeneralMenu_BtnExecuteTool
    gosub safecall View_GeneralMenu_BtnExecuteTool_Inner
    if #result = #true ; Restore menu
    {
        set #menubutton !null
        set #menures !null
        gosub safecall Std_CloseMenu %Menu_Name
        gosub safecall Std_RunMenu %Menu_Name
    }
return

sub View_GeneralMenu_BtnExecuteTool_Inner
    set !cycle %View_GeneralMenu_ChkToolCycle
    set !index %View_GeneralMenu_LstTools
    set !tool %View_GeneralMenu_Tools_ . !index
    set !label View_GeneralMenu_Tool_ , !tool
    if !cycle
       set !label !label , _Cycle
       
    goto !label
       gosub View_SetStatusMessage Strumento non riconosciuto!
       wait 1s
       return

    View_GeneralMenu_Tool_FillSmallBod:
        gosub View_SetStatusMessage Riempimento di un singolo BOD small...
        gosub safecall Ctrl_FillSmallBod
        return
    View_GeneralMenu_Tool_FillSmallBod_Cycle:
        gosub View_SetStatusMessage Riempimento di tutti i BOD small...
        gosub safecall Model_FillSmallBodCycle
        return
    View_GeneralMenu_Tool_FillLargeBod:
        gosub View_SetStatusMessage Versione senza "ciclo" non ancora implementata.
        wait 1s
        return
    View_GeneralMenu_Tool_FillLargeBod_Cycle:
        gosub View_SetStatusMessage Riempimento di tutti i BOD large...
        gosub safecall Model_FillLargeBodCycle
        return
    View_GeneralMenu_Tool_DeliverBod:
        gosub View_SetStatusMessage Consegna di un singolo BOD...
        gosub safecall Ctrl_DeliverBod
        return
    View_GeneralMenu_Tool_DeliverBod_Cycle:
        gosub View_SetStatusMessage Consegna di tutti i BOD...
        gosub safecall Ctrl_DeliverBodCycle
        return
    View_GeneralMenu_Tool_PlaceObject:
        gosub View_SetStatusMessage Posizionamento automatico di un oggetto...
        gosub safecall Ctrl_PlaceReward
        return
    View_GeneralMenu_Tool_PlaceObject_Cycle:
        gosub View_SetStatusMessage Posizionamento automatico degli oggetti nel backpack...
        gosub safecall Ctrl_PlaceRewardCycle
        return
    View_GeneralMenu_Tool_BankRestock:
        gosub View_SetStatusMessage Restock da banca di un singolo materiale...
        gosub safecall Ctrl_BankRestock
        return
    View_GeneralMenu_Tool_BankRestock_Cycle:
        gosub View_SetStatusMessage Restock da banca di tutti i materiali...
        gosub safecall Ctrl_BankRestockCycle
        return
    View_GeneralMenu_Tool_AnalyzeObject:
        gosub View_SetStatusMessage Analisi di un singolo oggetto...
        gosub safecall Ctrl_AnalyzeObject #false
        return #true
    View_GeneralMenu_Tool_AnalyzeObject_Cycle:
        gosub View_SetStatusMessage Analisi di oggetti multipli...
        gosub safecall Ctrl_AnalyzeObject #true
        return #true
    View_GeneralMenu_Tool_MoveObject:
        gosub View_SetStatusMessage Spostamento di oggetti simili (stesso colore)...
        gosub safecall Ctrl_MoveObject #true
        return
    View_GeneralMenu_Tool_MoveObject_Cycle:
        gosub View_SetStatusMessage Spostamento di oggetti simili (colori diversi)...
        gosub safecall Ctrl_MoveObject #false
        return
return

;=======================================
;* @name    View_RewardFilterMenu_Init
;* @author  AG (using EasyUO Menu Designer)
;* @purpose Crea il menu di filtraggio premi.
;* @example gosub safecall View_RewardFilterMenu_Init

sub View_RewardFilterMenu_Init
	menu Clear
	menu Window Title Boscags7
	menu Window Color Black
	menu Window Size 305 455
	menu Font Transparent #true
	menu Font Align Right
	menu Shape EUOShape1 4 31 297 387 3 7 2 Blue 7 Black
	menu Shape EUOShape5 104 4 97 33 4 7 2 Blue 7 Black
	menu Shape EUOShape6 5 412 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape3 5 308 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape2 5 392 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape7 5 32 295 5 3 7 1 Blue 7 Black
	menu Font Name Tahoma
	menu Font Size 10
	menu Font Style b
	menu Font Color Aqua
	menu Font Align Left
	menu Font BGColor Black
	menu Text EUOLabel21 117 9 Filtro Premi
	menu Font Name MS Sans Serif
	menu Font Style
	menu Font Color Lime
	menu Text EUOLabel7 12 44 Filtro Premi
	menu Text EUOLabel3 12 320 Disposizione Premi
	menu Font Size 8
	menu Font Color Red
	menu Text EUOLabel1 12 72 Da scartare / riciclare
	menu Font Color Blue
	menu Text EUOLabel2 168 72 Da conservare
	menu Font Color Silver
	menu Text EUOLabel8 12 280 Seleziona i premi da conservare e quelli da scartare.
	menu Text EUOLabel4 12 340 Ogni volta che lo script dovrà posizionare un certo premio,
	menu Text EUOLabel5 12 352 tenterà di collocarlo assieme ai premi ad esso più simili.
	menu Text EUOLabel6 12 364 Se non riuscisse a trovarne, lo collocherà nel primo
	menu Text EUOLabel9 12 376 contenitore premi disponibile.
	menu Font Color White
	menu Text LblStatus 12 398 Pronto
	menu Font Name Tahoma
	menu Font Size 10
	menu Font Style b
	menu Font Color Teal
	menu Button BtnGeneral 4 4 98 25 Generale
	menu Button BtnBodFilter 204 4 98 25 Filtro BOD
	menu Font Color Lime
	menu Button BtnStart 204 424 98 25 Avvia
	menu Font Size 7
	menu Font Style
	menu Font Color Blue
	menu Button BtnKeep 144 164 18 17 >
	menu Button BtnKeepAll 144 144 18 17 >>
	menu Font Color Red
	menu Button BtnTrash 144 184 18 17 <
	menu Button BtnTrashAll 144 204 18 17 <<
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color Red
	menu Font BGColor White
	menu List Create LstTrash 12 88 125 189
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color Blue
	menu List Create LstKeep 168 88 125 189
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color WindowText
	menu Font BGColor Window
	menu Combo Create CmbRewardType 168 44 125
	menu Combo Add CmbRewardType Stoffe (sarto)
	menu Combo Add CmbRewardType Sandali (sarto)
	menu Combo Add CmbRewardType Altro (sarto)
	menu Combo Add CmbRewardType Incudini (fabbro)
	menu Combo Add CmbRewardType Martelli (fabbro)
	menu Combo Add CmbRewardType Altro (fabbro)
	menu Combo Select CmbRewardType 1
	menu Show
return |CmbRewardType|LstTrash|LstKeep|

sub View_RewardFilterMenu_Over
    set %View_RewardFilterMenu_Initialized !null
return

sub View_RewardFilterMenu_Idle
    if %View_RewardFilterMenu_Initialized = !null
    {
       set %View_RewardFilterMenu_Initialized #true
       gosub safecall View_RewardFilterMenu_RefreshLists
    }

    gosub safecall Model_SaveConfig
return

sub View_RewardFilterMenu_BtnGeneral
    gosub safecall View_GeneralMenu_BtnGeneral
return

sub View_RewardFilterMenu_BtnRewardFilter
    gosub safecall View_GeneralMenu_BtnRewardFilter
return

sub View_RewardFilterMenu_BtnBodFilter
    gosub safecall View_GeneralMenu_BtnBodFilter
return

sub View_RewardFilterMenu_Closed
    gosub safecall View_GeneralMenu_Closed
return

sub View_RewardFilterMenu_BtnStart
    gosub safecall View_GeneralMenu_BtnStart
return

sub View_RewardFilterMenu_CmbRewardType
    if %View_RewardFilterMenu_Initialized = #true
       gosub safecall View_RewardFilterMenu_RefreshLists
return

sub View_RewardFilterMenu_GetCurrentMask
    set !suffix1 Cloth
    set !suffix2 Sandals
    set !suffix3 Tailor
    set !suffix4 Anvils
    set !suffix5 Hammers
    set !suffix6 Smith
    set !suffix !suffix . %View_RewardFilterMenu_CmbRewardType
return %Constants_Rewards_ . !suffix

sub View_RewardFilterMenu_RefreshLists
    gosub safecall View_RewardFilterMenu_GetCurrentMask
    set !mask #result
    set !trues  %Config_RewardFilter_Rewards
    gosub safecall View_RefreshOppositeLists !mask !trues
return

sub View_RewardFilterMenu_BtnKeep
    set !index %View_RewardFilterMenu_LstTrash
    set !item %Menu_OppositeLists_Sx_ . !index

    gosub safecall AG_AddToken %Config_RewardFilter_Rewards !item _
    set %Config_RewardFilter_Rewards #result

    gosub safecall View_RewardFilterMenu_RefreshLists
    menu List Select LstTrash !index
return

sub View_RewardFilterMenu_BtnTrash
    set !index %View_RewardFilterMenu_LstKeep
    set !item %Menu_OppositeLists_Dx_ . !index

    gosub safecall AG_RemoveToken %Config_RewardFilter_Rewards !item _
    set %Config_RewardFilter_Rewards #result

    gosub safecall View_RewardFilterMenu_RefreshLists
    menu List Select LstKeep !index
return

sub View_RewardFilterMenu_BtnKeepAll
    gosub safecall View_RewardFilterMenu_GetCurrentMask
    set !mask #result

    gosub safecall AG_AddTokens %Config_RewardFilter_Rewards !mask _
    set %Config_RewardFilter_Rewards #result

    gosub safecall View_RewardFilterMenu_RefreshLists
return

sub View_RewardFilterMenu_BtnTrashAll
    gosub safecall View_RewardFilterMenu_GetCurrentMask
    set !mask #result

    gosub safecall AG_RemoveTokens %Config_RewardFilter_Rewards !mask _
    set %Config_RewardFilter_Rewards #result

    gosub safecall View_RewardFilterMenu_RefreshLists
return

;=======================================
;* @name    View_BodFilterMenu_Init
;* @author  AG (using EasyUO Menu Designer)
;* @purpose Crea il menu di filtraggio bod.
;* @example gosub safecall View_BodFilterMenu_Init

sub View_BodFilterMenu_Init
	menu Clear
	menu Window Title Boscags7
	menu Window Color Black
	menu Window Size 305 455
	menu Font Transparent #true
	menu Font Align Right
	menu Shape EUOShape1 4 31 297 387 3 7 2 Blue 7 Black
	menu Shape EUOShape5 204 4 97 33 4 7 2 Blue 7 Black
	menu Shape EUOShape6 5 412 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape2 5 392 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape7 5 32 295 5 3 7 1 Blue 7 Black
	menu Shape EUOShape3 5 308 295 5 3 7 1 Blue 7 Black
	menu Font Name Tahoma
	menu Font Size 10
	menu Font Style b
	menu Font Color Aqua
	menu Font Align Left
	menu Font BGColor Black
	menu Text EUOLabel21 224 9 Filtro BOD
	menu Font Name MS Sans Serif
	menu Font Style
	menu Font Color Lime
	menu Text EUOLabel7 12 44 Filtro BOD basato sui premi
	menu Text EUOLabel3 12 320 Filtri BOD basati su altri criteri
	menu Font Size 8
	menu Font Color Red
	menu Text EUOLabel1 12 72 Da scartare / riciclare
	menu Font Color Blue
	menu Text EUOLabel2 168 72 Da conservare
	menu Font Color White
	menu Text EUOLabel29 12 344 BOD che richiedono ossa:
	menu Text LblStatus 12 398 Pronto
	menu Font Color Silver
	menu Text EUOLabel8 12 280 Seleziona i premi per i quali vale la pena conservare dei
	menu Text EUOLabel9 12 292 large bods. Saranno conservati anche i relativi small bods.
	menu Font Name Tahoma
	menu Font Size 10
	menu Font Style b
	menu Font Color Teal
	menu Button BtnGeneral 4 4 98 25 Generale
	menu Button BtnRewardFilter 104 4 98 25 Filtro Premi
	menu Font Color Lime
	menu Button BtnStart 204 424 98 25 Avvia
	menu Font Size 7
	menu Font Style
	menu Font Color Blue
	menu Button BtnKeep 144 164 18 17 >
	menu Button BtnKeepAll 144 144 18 17 >>
	menu Font Color Red
	menu Button BtnTrash 144 184 18 17 <
	menu Button BtnTrashAll 144 204 18 17 <<
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color Silver
	menu Font BGColor White
	menu List Create LstTrash 12 88 125 189
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color Silver
	menu List Create LstKeep 168 88 125 189
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color WindowText
	menu Combo Create CmbBoneFilter 168 340 125
	menu Combo Add CmbBoneFilter Riempi / Ignora
	menu Combo Add CmbBoneFilter Scarta
	menu Font Name MS Sans Serif
	menu Font Size 8
	menu Font Style
	menu Font Color WindowText
	menu Font BGColor Window
	menu Combo Create CmbBodRewardType 192 44 101
	menu Combo Add CmbBodRewardType Premi sarto
	menu Combo Add CmbBodRewardType Premi fabbro
	menu Combo Select CmbBodRewardType 1
	menu Show
return |CmbBodRewardType|LstTrash|LstKeep|CmbBoneFilter|

sub View_BodFilterMenu_Over
    set %View_BodFilterMenu_Initialized !null
return

sub View_BodFilterMenu_Idle
    if %View_BodFilterMenu_Initialized = !null
    {
       set %View_BodFilterMenu_Initialized #true
       gosub safecall View_BodFilterMenu_RefreshLists
    }
    
    if %Config_BodFilter_TrashBoneBods
        set %View_BodFilterMenu_CmbBoneFilter 2
    else
        set %View_BodFilterMenu_CmbBoneFilter 1

    gosub safecall Model_SaveConfig
return

sub View_BodFilterMenu_CmbBoneFilter
    if %View_BodFilterMenu_Initialized = #true
       set %Config_BodFilter_TrashBoneBods ( %View_BodFilterMenu_CmbBoneFilter = 2 )
return

sub View_BodFilterMenu_CmbBodRewardType
    if %View_BodFilterMenu_Initialized = #true
       gosub safecall View_BodFilterMenu_RefreshLists
return

sub View_BodFilterMenu_RefreshLists
    gosub safecall View_BodFilterMenu_GetCurrentMask
    set !mask #result
    set !trues %Config_BodFilter_Rewards
    gosub safecall View_RefreshOppositeLists !mask !trues
return

sub View_BodFilterMenu_BtnGeneral
    gosub safecall View_GeneralMenu_BtnGeneral
return

sub View_BodFilterMenu_BtnRewardFilter
    gosub safecall View_GeneralMenu_BtnRewardFilter
return

sub View_BodFilterMenu_BtnBodFilter
    gosub safecall View_GeneralMenu_BtnBodFilter
return

sub View_BodFilterMenu_Closed
    gosub safecall View_GeneralMenu_Closed
return

sub View_BodFilterMenu_BtnStart
    gosub safecall View_GeneralMenu_BtnStart
return

sub View_BodFilterMenu_GetCurrentMask
    set !suffix1 Tailor
    set !suffix2 Smith
    set !suffix !suffix . %View_BodFilterMenu_CmbBodRewardType
return %Constants_LargeRewards_ . !suffix

sub View_BodFilterMenu_BtnKeep
    set !index %View_BodFilterMenu_LstTrash
    set !item %Menu_OppositeLists_Sx_ . !index

    gosub safecall AG_AddToken %Config_BodFilter_Rewards !item _
    set %Config_BodFilter_Rewards #result

    gosub safecall View_BodFilterMenu_RefreshLists
    menu List Select LstTrash !index
return

sub View_BodFilterMenu_BtnTrash
    set !index %View_BodFilterMenu_LstKeep
    set !item %Menu_OppositeLists_Dx_ . !index

    gosub safecall AG_RemoveToken %Config_BodFilter_Rewards !item _
    set %Config_BodFilter_Rewards #result

    gosub safecall View_BodFilterMenu_RefreshLists
    menu List Select LstKeep !index
return

sub View_BodFilterMenu_BtnKeepAll
    gosub safecall View_BodFilterMenu_GetCurrentMask
    set !mask #result

    gosub safecall AG_AddTokens %Config_BodFilter_Rewards !mask _
    set %Config_BodFilter_Rewards #result

    gosub safecall View_BodFilterMenu_RefreshLists
return

sub View_BodFilterMenu_BtnTrashAll
    gosub safecall View_BodFilterMenu_GetCurrentMask
    set !mask #result

    gosub safecall AG_RemoveTokens %Config_BodFilter_Rewards !mask _
    set %Config_BodFilter_Rewards #result

    gosub safecall View_BodFilterMenu_RefreshLists
return

;=======================================
;* @name    View_RefreshOppositeLists
;* @author  AG
;* @purpose Aggiorna le due liste di "elementi contrapposti" (LstTrash e LstKeep), in base ad una selezione
;*          di elementi e ad una "maschera".
;*          - Aggiorna le liste all'interno della GUI
;*          - Aggiorna gli array %Menu_OppositeLists_Sx_* e %Menu_OppositeLists_Dx_*
;* @params  %1 req  "Maschera":  Elenco di tutti gli elementi da inserire in una lista o nell'altra.
;*          %2 req  "Selection": Elenco degli elementi da inserire nella lista di destra.
;*                               La lista di sinistra viene determinata di conseguenza.
;* @example gosub safecall View_RefreshOppositeLists

sub View_RefreshOppositeLists ; %mask %trues
    set !mask %1
    set !trues %2
    
    set %Menu_OppositeLists_Dx_Count 0
    set %Menu_OppositeLists_Sx_Count 0

    gosub safecall AG_Tokenize !mask _ Temp_Array_
    set !count #result
    for !i 1 !count
    {
        set !item %Temp_Array_ . !i
        if !item in !trues
        {
           set %Menu_OppositeLists_Dx_Count %Menu_OppositeLists_Dx_Count + 1
           set %Menu_OppositeLists_Dx_ . %Menu_OppositeLists_Dx_Count !item
        }
        else
        {
           set %Menu_OppositeLists_Sx_Count %Menu_OppositeLists_Sx_Count + 1
           set %Menu_OppositeLists_Sx_ . %Menu_OppositeLists_Sx_Count !item
        }
    }

  	menu Font Name MS Sans Serif
  	menu Font Transparent #true
  	menu Font Size 8
  	menu Font Style
  	menu Font Align Left
  	menu Font BGColor White
  	
  	menu Font Color Red
    menu Delete LstTrash
	  menu List Create LstTrash 12 88 125 189
	  if %Menu_OppositeLists_Sx_Count > 0
	  {
        for !i 1 %Menu_OppositeLists_Sx_Count
        {
            set !item %Menu_OppositeLists_Sx_ . !i
            gosub safecall Model_GetHumanName !item
            menu List Add LstTrash #result
        }
    }

  	menu Font Color Blue
    menu Delete LstKeep
	  menu List Create LstKeep 168 88 125 189
	  if %Menu_OppositeLists_Dx_Count > 0
	  {
        for !i 1 %Menu_OppositeLists_Dx_Count
        {
            set !item %Menu_OppositeLists_Dx_ . !i
            gosub safecall Model_GetHumanName !item
            menu List Add LstKeep #result
        }
    }
return



;==========================================================
;=
;=
;=    FUNZIONI ESECUTIVE (prefisso "Ctrl")
;=
;=
;==========================================================

sub Main
    linespercycle 500
    gosub safecall Model_Init
    gosub safecall View_MenuLoop View_GeneralMenu
return

sub Ctrl_FillSmallBod
    event exmsg #charid 3 0 Seleziona il BOD da riempire.
    gosub safecall Std_AskForTarget
    if #result = #false
    {
       event exmsg #charid 3 0 Operazione annullata.
       return
    }
    gosub safecall Model_FillSmallBod #ltargetid
    if #result = #true
        event exmsg #charid 3 0 Operazione completata con successo.
    else
        event exmsg #charid 3 0 Operazione fallita: #result , #dot
return

sub Ctrl_DeliverBod
    event exmsg #charid 3 0 Seleziona il BOD da consegnare.
    gosub safecall Std_AskForTarget
    if #result = #false
    {
       event exmsg #charid 3 0 Operazione annullata.
       return
    }
    ;gosub safecall Model_DeliverBod #ltargetid ; @todo
    event exmsg #charid 3 0 Operazione completata.
return

sub Ctrl_DeliverBodCycle
    gosub safecall Model_DeliverBodCycle tailor
    gosub safecall Model_PlaceObjects
    gosub safecall Model_DeliverBodCycle smith
    gosub safecall Model_PlaceObjects
    event exmsg #charid 3 0 Operazione completata.
return

sub Ctrl_PlaceReward
    event exmsg #charid 3 0 Seleziona l'oggetto da posizionare.
    gosub safecall Std_AskForTarget
    if #result = #false
    {
       event exmsg #charid 3 0 Operazione annullata.
       return
    }
    ;gosub safecall Model_DeliverBod #ltargetid ; @todo
    event exmsg #charid 3 0 Operazione completata.
return

sub Ctrl_PlaceRewardCycle
    gosub safecall Model_PlaceObjects
    event exmsg #charid 3 0 Operazione completata.
return

sub Ctrl_BankRestock
    event exmsg #charid 3 0 Seleziona il materiale da restockare.
    gosub safecall Std_AskForTarget
    if #result = #false
    {
       event exmsg #charid 3 0 Operazione annullata.
       return
    }
    set !target #ltargetid
    finditem !target C
    if #findkind = -1
    {
       event exmsg #charid 3 0 Impossibile trovare la risorsa specificata. Operazione annullata.
       return
    }
    set !list _ , #findtype , : , #findcol , _
    gosub safecall Model_BankRestock !list
    event exmsg #charid 3 0 Operazione completata.
return

sub Ctrl_BankRestockCycle
    gosub safecall Model_BankRestock %Constants_Resources_All
    event exmsg #charid 3 0 Operazione completata.
return

sub Ctrl_AnalyzeObject ; %cycle
    if %0 < 1 || %1 <> #true
    {
       set !cycle #false
       set !limit 1
    }
    else
    {
       set !cycle #true
       set !limit 10000
    }

    for !i 1 !limit
    {
        gosub safecall Std_AskForTarget
        if #result = #false
        {
           if !cycle = #false
              event exmsg #charid 3 0 Operazione annullata.
           return
        }
        set !target #result
        
        finditem !target C
        if #findkind = -1
        {
            finditem !target G
            if #findkind = -1
            {
               event exmsg #charid 3 0 Impossibile trovare l'oggetto specificato.
               continue
            }
        }
        set !object #findid
        set !type #findtype
        set !color #findcol
        
        if !type = %Constants_Bod
        {
            gosub safecall Model_AnalyzeBod !target
            event exmsg #charid 3 0 action = %CurrentBod_Action
            gosub libcall BodFunctions.euo ShowBodPanel !target
            while #menubutton <> closed
            {
            }
            continue
        }
        
        gosub safecall Std_IdentifyObject !object
        if #result <> #false && #result in %Constants_Rewards_All
        {
            set !rewardCode #result
            gosub safecall Model_GetHumanName !rewardCode
            set !humanName #result
            event exmsg #charid 3 0 Riconosciuto un premio: !humanName
            continue
        }
        
        event exmsg #charid 3 0 id = !object
        event exmsg #charid 3 0 type = !type
        event exmsg #charid 3 0 color = !color

        if !cycle = #false
           break
    }
return

sub Ctrl_SetHomePosition
    set !x #charposx
    set !y #charposy
    set !z #charposz
    set !oldx %Config_Home_PosX
    set !oldy %Config_Home_PosY
    set !oldz %Config_Home_PosZ
    set %Config_Home_PosX !x
    set %Config_Home_PosY !y
    set %Config_Home_PosZ !z
    
    set !locationChanged abs ( !oldx - !x ) > 10 && abs ( !oldy - !y ) > 10 && abs ( !oldz - !z ) > 10
    if !locationChanged
    {
       set %Config_Runebooks_Home _
    }
    
    finditem %Constants_Forges G_2
    if #findkind <> -1
       set %Config_Home_Forge #findid
    else
       set %Config_Home_Forge !null
       
    finditem %Constants_Anvils G_2
    if #findkind <> -1
       set %Config_Home_Anvil #findid
    else
       set %Config_Home_Anvil !null
       
    finditem %Constants_TrashBarrel G_2
    if #findkind <> -1
       set %Config_Home_Trash #findid
    else
       set %Config_Home_Trash !null
       
    finditem %Constants_DyingTub G_1 ; deve essere a distanza 1!!!
    if #findkind <> -1 && #findcol = 0
       set %Config_Home_DyingTub #findid
    else
       set %Config_Home_DyingTub !null
return

sub Ctrl_AnalyzeRunebooks
    if %Config_Home_PosX = !null || %Config_Home_PosY = !null || %Config_Home_PosZ = !null
    {
        event exmsg #charid 3 0 Devi prima impostare la posizione a casa!
        return
    }
    
    set %Config_Runebooks_Tailor _
    set %Config_Runebooks_Smith _
    set %Config_Runebooks_Home _
    set %Config_Runebooks_Bank _
    while #true
    {
        event exmsg #charid 3 0 Seleziona un runebook da analizzare, oppure premi ESC per terminare.
        gosub safecall Std_AskForTarget
        if #result = #false
           break
        set !runebook #result
        finditem !runebook C_ , #backpackid
        if #findkind = -1
        {
           event exmsg #charid 3 0 Il runebook deve trovarsi nel backpack!
           continue
        }
        if #findtype <> %Constants_Runebook ; @todo add
        {
           event exmsg #charid 3 0 L'oggetto selezionato non e' un runebook!
           continue
        }
        gosub safecall Model_AnalyzeRunebook !runebook
        set !info #result
        for !i 1 16
        {
            str mid !info !i 1
            set !char #strres
            set !recallCode !runebook , : , !i
            if !char = t
               set %Config_Runebooks_Tailor %Config_Runebooks_Tailor , !recallCode , _
            if !char = s
               set %Config_Runebooks_Smith %Config_Runebooks_Smith , !recallCode , _
            if !char = h
               set %Config_Runebooks_Home %Config_Runebooks_Home , !recallCode , _
            if !char = b
               set %Config_Runebooks_Bank %Config_Runebooks_Bank , !recallCode , _
        }
    }
return

sub Ctrl_SelectChests ; %type (work|rewards|bank)
    set !type %1
    if !type = work || !type = rewards
    {
        if %Config_Home_PosX = !null || %Config_Home_PosY = !null || %Config_Home_PosZ = !null
        {
            event exmsg #charid 3 0 Devi prima impostare la posizione a casa!
            return
        }
        gosub safecall Model_ChangeLocation home
    }
    if !type = bank
    {
        gosub safecall Model_DetectLocation
        if %Location_Name <> bank
        {
            if %Config_Runebooks_Bank = !null || %Config_Runebooks_Bank = _
            {
                event exmsg #charid 3 0 Devi trovarti in banca!
                return
            }
            gosub safecall Model_ChangeLocation bank
        }
        gosub safecall Std_OpenBankBox %Location_Vendor
    }
    
    event exmsg #charid 3 0 Seleziona tutti i contenitori desiderati. Premi ESC per terminare.
    set !result _
    set !count 0
    while #true
    {
        gosub safecall Std_AskForTarget
        if #result = #false && #targcurs = 0
           break
        set !chest #result
        
        finditem !chest C
        if #findkind = -1
        {
            finditem !chest G_2
            if #findkind = -1
            {
                event exmsg #charid 3 0 Non riesco a trovare il contenitore selezionato.
                continue
            }
        }
        
        ; @todo aggiungere check su root container

        set !timeout #systime + 1000 ; minimum timeout for paperdoll
        gosub safecall Std_OpenPaperdoll
        while #systime < !timeout
        {
        }
        
        gosub safecall Std_UseObject !chest
        set !timeout #systime + 5000
        while #systime < !timeout && #contsize = 262_324
        {
        }
        if #contsize = 262_324
        {
            event exmsg #charid 3 0 Non riesco ad aprire il contenitore selezionato.
            continue
        }
        set !count !count + 1
        set !result !result , #findid , _
    }
    event exmsg #charid 3 0 Selezionati !count contenitori.
    
    if !type = work
        set %Config_Chests_Work !result
    if !type = bank
        set %Config_Chests_Bank !result
    if !type = rewards
        set %Config_Chests_Rewards !result
return

sub Ctrl_SelectBodbook ; %type
    set !type %1
    
    if !type = fill
        set %Config_Bodbooks_Fill !null
    if !type = keep
        set %Config_Bodbooks_Keep !null
    if !type = deliver
        set %Config_Bodbooks_Deliver !null
        
    set !allBodbooks %Config_Bodbooks_Fill , _ , %Config_Bodbooks_Keep , _ , %Config_Bodbooks_Deliver , _ , %Config_Bodbooks_Trash

    event exmsg #charid 3 0 Seleziona un bodbook.
    gosub safecall Std_AskForTarget
    if #result = #false || #result = !null
    {
        event exmsg #charid 3 0 Nessun bodbook selezionato!
        return
    }
    set !bodbook #result
    finditem !bodbook C_ , #backpackid
    if #findkind = -1
    {
       event exmsg #charid 3 0 Il bodbook deve trovarsi nel backpack!
       return
    }
    if #findtype <> %Constants_Bodbook
    {
       event exmsg #charid 3 0 L'oggetto selezionato non e' un bodbook!
       return
    }
    if !bodbook in !allBodbooks
    {
       event exmsg #charid 3 0 Questo bodbook e' gia' utilizzato per altri scopi!
       return
    }
    
    if !type = fill
        set %Config_Bodbooks_Fill !bodbook
    if !type = keep
        set %Config_Bodbooks_Keep !bodbook
    if !type = deliver
        set %Config_Bodbooks_Deliver !bodbook

    event exmsg #charid 3 0 Bodbook selezionato correttamente.
return

sub Ctrl_MoveObject ; %colorMatters
    set !colorMatters ( %0 >= 1 && %1 = #true )
    if !colorMatters
       event exmsg #charid 3 0 Seleziona il tipo di oggetto da muovere (tieni conto anche del colore).
    else
       event exmsg #charid 3 0 Seleziona il tipo di oggetto da muovere (il colore non è importante).

    gosub safecall Std_AskForTarget
    if #result = #false
    {
       event exmsg #charid 3 0 Operazione annullata.
       return
    }
    set !object #ltargetid

    finditem !object C
    if #findkind = -1
    {
       event exmsg #charid 3 0 Impossibile trovare l'oggetto selezionato.
       return
    }
    set !type #findtype
    set !color #findcol

    event exmsg #charid 3 0 Seleziona il contenitore di destinazione.
    gosub safecall Std_AskForTarget
    if #result = #false
    {
       event exmsg #charid 3 0 Operazione annullata.
       return
    }
    set !dest #ltargetid

    ignoreitem reset
    finditem !type C_ , !dest
    for #findindex 1 #findcnt
    {
        ignoreitem #findid
    }

    while #true
    {
        finditem !type C
        if #findkind = -1
           break
        set !object #findid
        set !quantity #findstack
        if !colorMatters = #false || #findcol = !color
        {
           gosub safecall Std_MoveObject !object !dest !quantity
        }
        ignoreitem !object
    }
    ignoreitem reset
    event exmsg #charid 3 0 Operazione completata.
return



;==========================================================
;=
;=
;=    FUNZIONI IMPORTATE (prefissi variabili)
;=
;=
;==========================================================

;=======================================================
; CEO Filesystem
;=======================================================
Sub CEO_getGlobalVar
    nameSpace push
    nameSpace local #systime , _ , %2 , GET
    set !lpc #lpc
    set #lpc 1000
    set !global * . %1
    set !varName v , %2 , |
    str pos !global !varName
    set #result #strres <> 0
    if #result
    {
       set !varNamePos #strres
       str len !varName
       set !delString !varNamePos + #strres - 1
       str del !global 1 !delString
       set !global #strres
       str pos !global |
       set !varNamePos #strres - 1
       str left !global !varNamePos
       set % . %2 #strres
    }
    else
    {
       set % . %2 N/A
    }
    set #lpc !lpc
    nameSpace Clear
    nameSpace Pop
return #result
;=======================================================
Sub CEO_putGlobalVar
    nameSpace push
    nameSpace local #systime , _ , %2 , PUT
    set !lpc #lpc
    set #lpc 1000
    set !global * . %1
    set !varName v , %2 , |
    str pos !global !varName
    if #strres = 0
    {
       if  |CEO*FILESYSTEM_MODIFIED| notin !global
          set !global |CEO*FILESYSTEM_MODIFIED|
       set * . %1 !global , !varName , % . %2 , |
       set #lpc !lpc
       nameSpace clear
       nameSpace pop
       return #true
    }
    set !varNamePos #strres
    str len !varName
    set !splitString !varNamePos + #strres - 1
    str left !global !splitstring
    set !globalPart1 #strres
    str del !global 1 !splitString
    set !global #strres
    str len !global
    set !globalLen #strres
    str pos !global |
    set !splitString !globalLen - #strres + 1
    str right !global !splitstring
    set !global #strres
    set * . %1 !globalPart1 , % . %2 , !global
    set #lpc !lpc
    nameSpace clear
    nameSpace pop
return #true

;=============================================================
; Boydon utilities
;=============================================================

;==================
;**
;* @name OpenStatusBar
;* @ver 1.0 14Oct05
;* @author  Boydon
;* @purpose Open the StatusBar to a givent location an optionaly minimize it
;* @params %1 opt #contposx where you want to open the statusbar (default will be 0)
;*				 %2 opt #contposy where you want to open the statusbar (default will be 0)
;*				 %3 opt #true to minimize status bar (default is #false: status bar won't be minimized)
;* @returns
;* @dependencies
;* @example gosub openStatusBar
;*						this is the standard call and will open your statusbar to pos 0 0
;*					gosub OpenStatusBar 205 25
;*						this will open statusbar at positions 205 25
;*					gosub OpenPaperdoll 205 25 #true
;*						this will open your status at positions 205 25 and minimize it
;* @status Tested and working

sub Boydon_OpenStatusBar

	if %1 = N/A || %0 = 0
		set %1 0
	if %2 = N/A || %0 <= 1
		set %2 0
	if %3 = N/A || %0 <= 2
		set %3 #false

	nameSpace Push
	nameSpace Local OpenStatusBar , #time , #random , #scnt2

	set !OpenX %1
	set !OpenY %2
	set !Minimize %3

	__boy_osb1:
	;gosub CheckForWorldSave
	set #nextCPosX !OpenX
	set #nextCPosY !OpenY
	Event Macro 8 2 ;Open StatusBar
	wait 20

	if #contname <> status_gump
		goto __boy_osb1

	if ! !Minimize
	{
		if #contposx <> !OpenX || #contposy <> !OpenY
		{
			contpos !OpenX !OpenY
			wait 20
		}
	}

	if !Minimize
	{
		set !MinimizeX #contposx + 395
		set !MinimizeY #contposy + 155

		click !MinimizeX !MinimizeY f
	}

	nameSpace CLear
	nameSpace Pop

return

;==================
;**
;* @name GetProperty
;* @ver 1.0 15May05
;* @author  Boydon
;* @purpose Get the #property of a given item tring to avoid errors, null values and
;*					unexpected values.
;* @params %1 req Id of the item you want to EP
;* @returns #property of %1
;* @dependencies
;* @example gosub GetProperty #findid
;*						tis is the standard call and will EP #findid
;* @status Fully tested and working

sub Boydon_GetProperty

	if %0 < 1 || %1 = N/A
  {
		event exmsg #charid 3 0 Wrong use of Sub GetProperty: some required arguments are missing!
  set %fine_fillabod #true
            return
	}

	nameSpace Push
	nameSpace Local GetProperty , #time , #random , #scnt2

	__boy_gp_loop1:
	event property %1
	set !Property1 #property
	event property %1
	set !Property2 #property
	event property %1
	set !Property3 #property

	if ! ( !Property1 = !Property2 && !Property2 = !Property3 )
		goto __boy_gp_loop1

	nameSpace Clear
	nameSpace Pop

return #property

;==================
;**
;* @name CheckForWorldSave
;* @ver 1.0 20May05
;* @author  Boydon
;* @purpose To detect world saves and resources cleaning of RunUO Shards
;* @params
;* @returns
;* @notes the sub keep track of the last scanned journal line using
;*					the variable %Saveindex: every time the sub is called the script will
;*					start to scan from that line.
;* @dependencies sub WaitForSaveEnd
;* @example gosub CheckForWorldSave
;* @status Tested and working fine

sub Boydon_CheckForWorldSave
	nameSpace Push
	nameSpace Local CheckForWorldSave , #time , #random , #scnt2

	if %SaveIndex = N/A
		set %SaveIndex #jindex

	set !Save #false
	set !Jstart %SaveIndex
	for !i !Jstart #jindex
	{
		scanjournal !i
		if #jcolor = 53
		{
			if THE_WORLD_WILL_SAVE_IN in #journal || WORLD_IS_SAVING in #journal
			{
				set !Save #true
				 set #sysmsgcol  33
				event sysmessage >>>>SAVE DETECTED<<<<<<
				;Event ExMsg #charid 3 33 SAVE Detected
				gosub Boydon_WaitForSaveEnd WORLD_SAVE_COMPLETE 100 !i SAVE
				set %SaveIndex #jindex
				set !i #jindex
			}
			if CLEANING in #journal
			{
				set !Save #true
				set #sysmsgcol 33
        event sysmessage >>>>>CLEANING DETECTED<<<<<<
				;Event ExMsg #charid 3 33 CLEANING Detected
				gosub Boydon_WaitForSaveEnd CLEANED 30 !i CLEANING
				set %SaveIndex #jindex
				set !i #jindex
			}
		}
		set %SaveIndex !i
	}

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name WaitForSaveEnd
;* @ver 1.0 20May05
;* @author  Boydon
;* @purpose To detect when world save/resource cleaning has ended
;* @params %1 req End of save message
;*				 %2 req Time to wait before the sub goes in time out
;*				 %3 req #jindex of world save start message
;*				 %4 req Tells what are we waiting for, can be SAVE|CLEANING
;* @returns
;* @notes This sub _MUST_ be called _ONLY_FROM_ sub CheckForWorldSave.
;*				This sub uses the same namespace as sub CheckForSave.
;* @dependencies sub CheckForWorldSave
;* @example
;* @status Tested and working fine

sub Boydon_WaitForSaveEnd

	if %0 < 4 || %1 = N/A || %2 = N/A || %3 = N/A || %4 = N/A
	{
		display ok Wrong use of Sub WaitForSaveEnd: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	set !EndOfSave %1
	set !SaveTimeOut #scnt + %2
	set !Jstart %3
	set !Message %4

	waitforsaveend:

	for !j !jstart #jindex
	{
		scanjournal !j
		if #jcolor = 53
		{
			if !EndOfSave in #journal
			{
				set !Save #false
				set %SaveIndex #jindex
				set !j #jindex
			}
		}
	}
	if !Save = #true && #scnt <= !SaveTimeOut
	{
		wait 1
		goto waitforsaveend
	}
	if #scnt > !SaveTimeOut
	{
		set !Save #false
		set %SaveIndex #jindex
		event ExMsg #charid 3 33 !Message detection timed out...
	}
	event ExMsg #charid 3 33 End of !Message Detected
return

;=============================================================
; AG EasyUO Library
;=============================================================

sub AG_Tokenize
    namespace push
    namespace local agTokenize , #systime , #random
    set !string %1
    set !sep %2
    set !array %3

    if ( !string = !null ) || ( !string = !sep )
    {
        set !count 0
    }
    else
    {
        ; Must end with a separator!
        str right !string 1
        if #strres <> !sep
        {
           set !string !string , !sep
        }

        str count !string !sep
        set !count #strres
        set !start 1

        set !j 0 ; !j is the array index. !j is different from !i if empty tokens are present (example: _a_b__c_)
        for !i 1 !count
        {
            str pos !string !sep !i
            set !length #strres - !start
            str mid !string !start !length
            set !token #strres
            set !start !start + !length + 1

            if !length > 0
            {
                set !j !j + 1
                set !varname !array , !j
                set % . !varname !token
            }
        }
        set !count !j ; override !count with actual count
    }
    set !varname !array , count
    set % . !varname !count
    set #result !count
    namespace clear
    namespace pop
return #result

sub AG_AddToken ; %string %token %sep
    namespace push
    namespace local AG_AddToken , #systime , #random
    set !string %1
    set !item %2
    set !sep %3

    ; Must start with a separator!
    str left !string 1
    if #strres <> !sep
       set !string !sep , !string

    ; Must end with a separator!
    str right !string 1
    if #strres <> !sep
       set !string !string , !sep

    if !sep , !item , !sep notin !string
    {
       set !string !string , !item , !sep
    }

    set #result !string
    namespace clear
    namespace pop
return #result

sub AG_RemoveToken ; %string %token %sep
    namespace push
    namespace local AG_AddToken , #systime , #random
    set !string %1
    set !item %2
    set !sep %3

    ; Must start with a separator!
    str left !string 1
    if #strres <> !sep
       set !string !sep , !string

    ; Must end with a separator!
    str right !string 1
    if #strres <> !sep
       set !string !string , !sep

    set !sepItem !sep , !item , !sep
    if !sepItem in !string
    {
        str pos !string !sepItem
        set !pos #strres
        str len !sepItem
        set !len #strres - 1
        str del !string !pos !len
        set !string #strres
    }

    set #result !string
    namespace clear
    namespace pop
return #result

sub AG_AddTokens ; %source %tokens %separator
    namespace push
    namespace local AG_AddTokens , #systime , #random
    set !source %1
    set !tokens %2
    set !sep %3

    gosub AG_Tokenize !tokens !sep AG_AddTokens_Array_
    set !count #result
    for !i 1 !count
    {
        set !token %AG_AddTokens_Array_ . !i
        gosub AG_AddToken !source !token !sep
        set !source #result
    }

    set #result !source
    namespace clear
    namespace pop
return #result

sub AG_RemoveTokens ; %source %tokens %separator
    namespace push
    namespace local AG_RemoveTokens , #systime , #random
    set !source %1
    set !tokens %2
    set !sep %3

    gosub AG_Tokenize !tokens !sep AG_RemoveTokens_Array_
    set !count #result
    for !i 1 !count
    {
        set !token %AG_RemoveTokens_Array_ . !i
        gosub AG_RemoveToken !source !token !sep
        set !source #result
    }

    set #result !source
    namespace clear
    namespace pop
return #result



;==========================================================
;=
;=
;=    LIBRERIE LINKATE STATICAMENTE
;=
;=
;==========================================================

;==================================
; Script Name: Boydon's RunUO Craftmenus' Handling Functions
; Author: Boydon
; Version: 1.4
; Client Tested with: 5.0.0b
; EUO version tested with: 1.5 TV 57
; Shard OSI / FS: FS, RunUO 1.0
; Revision Date: 07Oct05
; Public Release: 14May05
; Global Variables Used: None
; Purpose: A callable library to handle crafting menues in RunUO Emulator.
;==================================

set %_0 %0
goto %_0
0:
    exit
1:
    gosub %1
    exit
2:
    gosub %1 %2
    exit
3:
    gosub %1 %2 %3
    exit
4:
    gosub %1 %2 %3 %4
    exit
5:
    gosub %1 %2 %3 %4 %5
    exit
6:
    gosub %1 %2 %3 %4 %5 %6
    exit
7:
    gosub %1 %2 %3 %4 %5 %6 %7
    exit
8:
    gosub %1 %2 %3 %4 %5 %6 %7 %8
    exit
9:
    gosub %1 %2 %3 %4 %5 %6 %7 %8 %9
    exit
10:
    gosub %1 %2 %3 %4 %5 %6 %7 %8 %9 %10
    exit

;==================
;* To do list
;*
;* Nothing ATM
;==================

;==================================
;* Special Thanks to:
;*
;* Allanon Wallace for his support, his help and his suggestions in testing phase
;* Quintok / Raziel for their very nice and usefull waitForSysVars sub
;* Anom that found a nasty bug
;==================================

;==================
;**
;* @name BringUpCraftMenu
;* @ver 1.1 15May05
;* @author  Boydon
;* @purpose bring up desidered craft menu
;*
;* @params %1 req The type/id of the tools you want to use.
;*								If you prefer you can specify the name of the skill to use.
;*								This can be tinker|tailor|smith|carpentry|bowcraft|alchemy|inscription|masonry|glassblow|cooking
;*
;*				 %2 opt This allow you to decide weather the script halts or not if a toolkit isn't found
;*								inside your #backpack. This can have two values #true or #false. Default value
;*								of this parameter is #true
;*
;* @returns This sub will return the id of the tools currently used (last #findid value): if you
;*					called the sub using the skill name (look above) this is very usefull cause you can
;*					know the exact id of the tool you are currently using and use it in various ways, as
;*					example you can calculate how many uses it has left... If you called the sub with halt
;*					option turned off returned value will be "X" (without the "" around) if a tool can't be found
;*
;* @example call CraftMenuFunctions.euo BringUpCraftMenu KTL
;*					call CraftMenuFunctions.euo BringUpCraftMenu tinker
;*							both this examples will bring up tinker Menu
;*					call CraftMenuFunctions.euo BringUpCraftMenu tinker #false
;*							this example will try to bring up tinker Menu and won't halt the script if a tool is not found
;* @status tested and working properly

sub BringUpCraftMenu ; fixed by NeuZZo (@todo: controllare il codice. Per il momento ci si fida)
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BringUpCraftMenu: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	if %2 = N/A || %0 <= 1
		set %2 #true

	if %2 <> #true && %2 <> #false
	{
		display ok Unexpected value for argument 2 in Sub BringUpCraftMenu!
			+$Please check!$
			+$Script will be halted.
  halt
	}

	nameSpace Push
	nameSpace Local BringUpCraftMenu , #time , #random , #scnt2

	set !ToolsType %1
	set !Halt %2

	if !ToolsType = tinker
		set !ToolsType JTL_GTL_KTL
	if !ToolsType = tailor
		set !ToolsType HAG
	if !ToolsType = smith
		set !ToolsType TLH_FBG_GBG_OLH_OBG_TBG
	if !ToolsType = carpentry
		set !ToolsType YFG_ZHG_CIG_BIG_AGG_EGG_AIG_WFG_IGG_KGG_ZFG
	if !ToolsType = bowcraft
		set !ToolsType UFG
	if !ToolsType = alchemy
		set !ToolsType RQF
	if !ToolsType = inscription
		set !ToolsType PBG
	if !ToolsType = masonry
		set !ToolsType ZEH
	if !ToolsType = glassblow
		set !ToolsType CQF
	if !ToolsType = Cooking
		set !ToolsType BCG_DND_OGG

	UseTools:
	set !StartContKind #contkind
	set !StartContName #contname
	set !StartContSize #contsize

	FindTools:
	finditem !ToolsType C_ , #backpackid
	if #findkind = -1 && !Halt
	{
		display ok Impossible to find any craft tool in your backpack!
			+$Script will be halted.
		halt
	}
	if #findcol <> 0
	{
		;display ok You seem to have some runik kits in your back pack! $Script will ignore them!
		ignoreitem #findid runikkits
		goto FindTools
	}
	if #findkind <> -1
		set #lobjectid #findid

	Event Macro 17 0 ;Last Object
	wait 12

	gosub waitForSysVars contkind <> !StartContKind contname <> !StartContName contsize <> !StartContSize 5

	if ! #result ;Craft Gump was already opened?
	{
		set !CloseGumpX #contposx + 50
		set !CloseGumpY #contposy + 50
		click !CloseGumpX !CloseGumpY r
		wait 5
		if ( #contkind = !StartContKind || contname <> !StartContName  || contsize <> !StartContSize  )
		{
          set !CloseGumpX #contposx + 50
		      set !CloseGumpY #contposy + 50
		      click !CloseGumpX !CloseGumpY r
		      wait 5
    }
		goto UseTools
	}

	ignoreitem reset runikkits
	nameSpace Clear
	nameSpace Pop
return #findid

sub BringUpCraftMenu_old ; Before Neuzzo's fix

	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BringUpCraftMenu: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	if %2 = N/A || %0 <= 1
		set %2 #true

	if %2 <> #true && %2 <> #false
	{
		display ok Unexpected value for argument 2 in Sub BringUpCraftMenu!
			+$Please check!$
			+$Script will be halted.
  halt
	}

	nameSpace Push
	nameSpace Local BringUpCraftMenu , #time , #random , #scnt2

	set !ToolsType %1
	set !Halt %2

	if !ToolsType = tinker
		set !ToolsType JTL_GTL_KTL
	if !ToolsType = tailor
		set !ToolsType HAG
	if !ToolsType = smith
		set !ToolsType TLH_FBG_GBG_OLH_OBG_TBG
	if !ToolsType = carpentry
		set !ToolsType YFG_ZHG_CIG_BIG_AGG_EGG_AIG_WFG_IGG_KGG_ZFG
	if !ToolsType = bowcraft
		set !ToolsType UFG
	if !ToolsType = alchemy
		set !ToolsType RQF
	if !ToolsType = inscription
		set !ToolsType PBG
	if !ToolsType = masonry
		set !ToolsType ZEH
	if !ToolsType = glassblow
		set !ToolsType CQF
	if !ToolsType = Cooking
		set !ToolsType BCG_DND_OGG

	UseTools:
	set !StartContKind #contkind
	set !StartContName #contname
	set !StartContSize #contsize

	FindTools:
	finditem !ToolsType C_ , #backpackid
	if #findkind = -1 && !Halt
	{
		display ok Impossible to find any craft tool in your backpack!
			+$Script will be halted.
		halt
	}
	if #findcol <> 0
	{
		;display ok You seem to have some runik kits in your back pack! $Script will ignore them!
		ignoreitem #findid runikkits
		goto FindTools
	}
	if #findkind <> -1
		set #lobjectid #findid

	Event Macro 17 0 ;Last Object
	wait 12

	gosub waitForSysVars contkind <> !StartContKind contname <> !StartContName contsize <> !StartContSize 5

	if ! #result ;Craft Gump was already opened?
	{
		set !CloseGumpX #contposx + 50
		set !CloseGumpY #contposy + 50
		click !CloseGumpX !CloseGumpY r
		wait 5
		goto UseTools
	}

	ignoreitem reset runikkits
	nameSpace Clear
	nameSpace Pop
return #findid

;==================
;**
;* @name CraftAnything
;* @ver 1.1 16May05
;* @author  Boydon
;* @purpose craft the desiderd item from the menu
;*
;* @params %1 req the category number Where "LAST TEN" is category numer 0 and so on
;*							I decided to give "LAST TEN"	 number 0 cause it is pretty useless as category
;*   	%2 req number of the piece to craft. This must be an absolute number.
;*					Because of menues having more than one page you have to count item numer from 1,
;*					so on page 1 there will be items from 1 to 10, on page 2 from 11 to 20 and so on..
;*
;* @returns
;* @example call CraftMenuFunctions.euo CraftAnyThing 2 22
;* @status tested and working fine

sub CraftAnything

	if %0 < 2 || %1 = N/A || %2 = N/A
	{
		display ok Wrong use of Sub CraftAnything: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	nameSpace Push
	nameSpace Local CraftAnything , #time , #random , #scnt2

	set !category %1
	set !piece %2

	set !CraftContKind #contkind
	set !CraftContName #contname
	set !CraftContSize #contsize

	; category
	set !categoryX #contposx + 30
	set !categoryY #contposy + 70 + !category * 20   ; +70 catergory *20
	click !categoryX !categoryY f
	gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize 5

	; page
	set !page ( !piece - 1 ) / 10

	if !page > 0
	{
		for !i 1 !page
		{
			gosub ClickNextPage
		}

		if !piece % 10 <> 0
			set !piece !piece % 10

		if !piece % 10 = 0
			set !piece 10
	}

	;piece
	set !pieceX #contposx + 235
	set !pieceY #contposy + 50 + !piece * 20
	click !pieceX !pieceY f
	gosub waitForSysVars contkind <> !CraftContKind contname <> !CraftContName contsize <> !CraftContSize 5
	gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize 5

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name ChooseMaterial
;* @ver 1.4 06Oct05
;* @author  Boydon
;* @purpose Choose the material you to use to craft
;*
;* @params %1 req material name: it can be:
;*							iron|dull|shadow|copper|bronze|gold|agapite|verite|valorite|nocolor for Blacksmithy materials
;*							leather|spined|horned|barbed|nocolor for Tailoring materials
;*
;*							As of version 1.4 of the library you can use ingots #findcol as argument, so values can be:
;*							0|2419|2406|2413|2418|2213|2425|2207|2219 for Blacksmithy
;*							0|2220|2117|2129 for Tailoring
;*							nocolor will be -1
;*
;* @returns
;* @example call CraftMenuFunctions.euo ChooseMaterial iron
;* @status tested and working properly

sub ChooseMaterial

	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub ChooseMaterial: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	nameSpace Push
	nameSpace Local ChooseMaterial , #time , #random , #scnt2

	set !Material #false

	if %1 = iron || %1 = leather || %1 = 0
		set !Material 1
	if %1 = dull || %1 = spined || %1 = 2220 || %1 = 2419
		set !Material 2
	if %1 = shadow || %1 = horned || %1 = 2117 || %1 = 2406
		set !Material 3
	if %1 = copper || %1 = barbed || %1 = 2129 || %1 = 2413
		set !Material 4
	if %1 = bronze || %1 = 2418
		set !Material 5
	if %1 = gold || %1 = 2213
		set !Material 6
	if %1 = agapite || %1 = 2425
		set !Material 7
	if %1 = verite || %1 = 2207
		set !Material 8
	if %1 = valorite || %1 = 2219
		set !Material 9
	if %1 = nocolor || %1 = -1
		set !Material 11

	if ! !Material
	{
		display ok Unknown material %1 ! $Script will be halted.
		halt
	}

	set !CraftContKind #contkind
	set !CraftContName #contname
	set !CraftContSize #contsize

	clickMaterialCategory:
	set !MaterialX #contposx + 30
	set !MaterialY #contposy + 370
	click !MaterialX !MaterialY f

	gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize 5
	if ! #result
		goto clickMaterialCategory

	clickMaterialColor:
	set !ColorX #contposx + 235
	set !ColorY #contposy + ( 50 + ( 20 * !Material ) )
	click !ColorX !ColorY f

	gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize 5
	if ! #result
		goto clickMaterialColor

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name ClickNextPage
;* @ver 1.0 24Apr05
;* @author  Boydon
;* @purpose Once the craft menu is focused use this to click the next page button
;*
;* @params
;*
;* @returns
;* @example call CraftMenuFunctions.euo ClickNextPage
;* @status tested and working properly

sub ClickNextPage
	nameSpace Push
	nameSpace Local ClickNextPage , #time , #random , #scnt2

	set !NextPageX #contposx + 385
	set !NextPageY #contposy + 270
	click !NextPageX !NextPageY f
	wait 10

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name ClickMakeLast
;* @ver 1.0 24Apr05
;* @author  Boydon
;* @purpose Once the craft menu is focused use this to click the make last button
;*
;* @params
;*
;* @returns
;* @example call CraftMenuFunctions.euo ClickMakeLast
;* @status tested and working properly

sub ClickMakeLast
	nameSpace Push
	nameSpace Local ClickMakeLast , #time , #random , #scnt2

	set !CraftContKind #contkind
	set !CraftContName #contname
	set !CraftContSize #contsize

	set !MakeLastX #contposx + 280
	set !MakeLastY #contposy + 410
	click !MakeLastX !MakeLastY f
	gosub waitForSysVars contkind <> !CraftContKind contname <> !CraftContName contsize <> !CraftContSize 5
	gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize 5

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name ClickExit
;* @ver 1.0.1 14May05
;* @author  Boydon
;* @purpose Once the craft menu is focused use this to click the exit button
;*
;* @params
;*
;* @returns
;* @example call CraftMenuFunctions.euo ClickExit
;* @status tested and working properly

sub ClickExit
	nameSpace Push
	nameSpace Local ClickExit , #time , #random , #scnt2

	set !CraftContKind #contkind
	set !CraftContName #contname
	set !CraftContSize #contsize

	set !ExitX #contposx + 30
	set !ExitY #contposy + 410

	ClickExit:
	click !ExitX !ExitY f
	gosub waitForSysVars contkind <> !CraftContKind contname <> !CraftContName contsize <> !CraftContSize 5

	if ! #result && #contsize = 530_437   ; 530_437
		goto ClickExit

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name ClickSmelt
;* @ver 1.2 20Aug05
;* @author  Boydon
;* @purpose Once the blacksmithy craft menu is focused use this to click the smelt button
;*
;* @params %1 opt The id of the item you want to smelt
;*
;* @returns
;* @example call CraftMenuFunctions.euo ClickSmelt
;* @status tested and working properly

sub ClickSmelt
	nameSpace Push
	nameSpace Local ClickSmelt , #time , #random , #scnt2

	set !CraftContKind #contkind
	set !CraftContName #contname
	set !CraftContSize #contsize

	set !TargetItem #false
	if %0 = 1
	{
		set !TargetItem #true
		set !Item %1
	}

	set !SmeltX #contposx + 30
	set !SmeltY #contposy + 355
	click !SmeltX !SmeltY f
	gosub waitForSysVars contkind <> !CraftContKind contname <> !CraftContName contsize <> !CraftContSize targcurs = 1 5

	if !TargetItem
	{
		set #ltargetkind 1
		set #ltargetid !Item
		Event Macro 22 0
		gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize targcurs = 0 5
	}

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name ClickRepair
;* @ver 1.2 20Aug05
;* @author  Boydon
;* @purpose Once the craft menu is focused use this to click the repair button
;*
;* @params  %1 opt The id of the item you want to repair
;*
;* @returns
;* @example call CraftMenuFunctions.euo ClickRepair
;* @status tested and working properly

sub ClickRepair
	nameSpace Push
	nameSpace Local ClickRepair , #time , #random , #scnt2

	set !CraftContKind #contkind
	set !CraftContName #contname
	set !CraftContSize #contsize

	set !TargetItem #false
	if %0 = 1
	{
		set !TargetItem #true
		set !Item %1
	}

	set !RepairX #contposx + 280
	set !RepairY #contposy + 355

	click !RepairX !RepairY f
	gosub waitForSysVars contkind <> !CraftContKind contname <> !CraftContName contsize <> !CraftContSize targcurs = 1 5

	if !TargetItem
	{
		set #ltargetkind 1
		set #ltargetid !Item
		Event Macro 22 0
		gosub waitForSysVars contkind = !CraftContKind contname = !CraftContName contsize = !CraftContSize targcurs = 0 5
	}

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name Initialize
;* @ver 1.1 12Sep05
;* @author  Boydon
;* @purpose This function is for internal purpose only. If you plan to use this
;*						library inside one of your script, running this will ensure you,
;*						returning the version number of the library, that you are calling
;*						the library in the right way.
;*
;* @params
;*
;* @returns Version of the library with no float
;* @example call GetBodParameters.euo Initialize
;* @status tested and working properly

Sub Initialize
return 140

Sub Inizialize ; misspelled, but required for backward compatibility
    gosub Initialize
return #result


;------------------------ IMPORTED SUBS ------------------------

;==================================
; Script Name: sub waitForSysVars
; Author: Quintok / Raziel
; Version: 1.04
; Client Tested with: 4.0.2b
; EUO version tested with: 0078
; Shard OSI / FS: OSI / FS
; Revision Date: 21st March 2004
; Public Release: 20th March 2004
; Global Variables Used: none
; Purpose: same as waitForSysVar but for multiple inputs.
;==================================
sub waitForSysVars
  set !cnt %0 / 3
  if ( %0 % 3 = 1 )
    set !timeOut #scnt + % . %0
  else
    set !timeOut #scnt + 5
  for !i 1 !cnt
  {
    set !offset 3 * !i - 2
    set !evaluation !offset + 1
    set !value !offset + 2
    if ! ( # . % . !offset % . !evaluation % . !value )
      set !i 0
    if #scnt > !timeout
      return #false
  }
return #true






;==================================
; Script Name: BodFunctions.euo
; Author: Boydon & AG
; Version: 2.0
; Purpose: A callable library to handle BOD-related functions.
;==================================

set %_0 %0
goto %_0
0:
    exit
1:
    gosub %1
    exit
2:
    gosub %1 %2
    exit
3:
    gosub %1 %2 %3
    exit
4:
    gosub %1 %2 %3 %4
    exit
5:
    gosub %1 %2 %3 %4 %5
    exit
6:
    gosub %1 %2 %3 %4 %5 %6
    exit
7:
    gosub %1 %2 %3 %4 %5 %6 %7
    exit
8:
    gosub %1 %2 %3 %4 %5 %6 %7 %8
    exit
9:
    gosub %1 %2 %3 %4 %5 %6 %7 %8 %9
    exit
10:
    gosub %1 %2 %3 %4 %5 %6 %7 %8 %9 %10
    exit

;==================
;* To do list
;*
;* Add support for Blacksmithing:
;* 		Add blacksmity support implementing sub GetSmithyBodParameters (48 bods to be implemented!!)
;*			This has been partialy done (36 bod added)

;==================
;**
;* @name GetTailorBodParameters
;* @ver 1.0 11May05
;* @author  Boydon
;* @purpose Get info about the piece that is needed to fill the BOD
;*
;* @params %1 req #property of the bod
;* 				 %2 opt name of the variable containing the category without the "%" symbol (default is "category")
;* 				 %3 opt name of the variable containing the piece without the "%" symbol (default is "piece")
;* 				 %4 opt name of the variable containing the required cloth without the "%" symbol (default is "cloth")
;* 				 %5 opt name of the variable containing the required hides without the "%" symbol (default is "hides")
;*				 %6 opt name of the variable containing the required bones without the "%" symbol (default is "bones")
;*				 %7 opt name of the variable containing the item type without the "%" symbol (default is "type")
;*
;* @returns
;* @example call GetBodParameters.euo GetTailorBodParameters #property
;*							this is the standar call
;*					call GetBodParameters.euo GetTailorBodParameters #property selection piece_number cloth leather bone item_type
;*							this is a call wich will return infos in %selection, %piece_number,
;*						  %cloth, %leather and %bone item_type variables
;* @status deeply tested

sub GetTailorBodParameters        ; TUTTO OK

	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub GetTailorBodParameters: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	if %2 = N/A || %0 = 1
		set %2 category
	if %3 = N/A || %0 <= 2
		set %3 piece
	if %4 = N/A || %0 <= 3
		set %4 cloth
	if %5 = N/A || %0 <= 4
		set %5 hides
	if %6 = N/A || %0 <= 5
		set %6 bones
	if %7 = N/A || %0 <= 6
		set %7 type

	nameSpace Push
	nameSpace Local GetTailorBodParameters , #time , #random , #scnt2

	set !Property %1
	set !Category %2
	set !Piece %3
	set !Cloth %4
	set !Hides %5
	set !Bones %6
	set !Type %7

	set !lpc #lpc
	set #lpc 500

	set % . !Category N/A
	set % . !Cloth 0
	set % . !Hides 0
	set % . !Bones 0

	if cap in !Property && skull in !Property && leather notin !Property
	{
		set % . !Category 2
		set % . !Piece 1
		set % . !Cloth 2
		set % . !Type CZH
		goto gbp_out
	}

	if cap in !Property && skull notin !Property && leather notin !Property
	{
		set % . !Category 2
		set % . !Piece 4
		set % . !Cloth 11
		set % . !Type VVI
		goto gbp_out
	}

	if bandana in !Property
	{
		set % . !Category 2
		set % . !Piece 2
		set % . !Cloth 2
		set % . !Type GZH
		goto gbp_out
	}

	if hat in !Property
	{

		if floppy in !Property
		{
			set % . !Category 2
			set % . !Piece 3
			set % . !Cloth 11
			set % . !Type BWI
			goto gbp_out
		}

		if wide in !Property
		{
			set % . !Category 2
			set % . !Piece 5
			set % . !Cloth 12
			set % . !Type WVI
			goto gbp_out
		}

		if straw in !Property && tall notin !Property
		{
			set % . !Category 2
			set % . !Piece 6
			set % . !Cloth 10
			set % . !Type XVI
			goto gbp_out
		}

		if straw in !Property && tall in !Property
		{
			set % . !Category 2
			set % . !Piece 7
			set % . !Cloth 13
			set % . !Type YVI
			goto gbp_out
		}

		if wizard in !Property
		{
			set % . !Category 2
			set % . !Piece 8
			set % . !Cloth 15
			set % . !Type IWI
			goto gbp_out
		}

		if feathered in !Property
		{
			set % . !Category 2
			set % . !Piece 10
			set % . !Cloth 12
			set % . !Type KWI
			goto gbp_out
		}

		if tricorne in !Property
		{
			set % . !Category 2
			set % . !Piece 11
			set % . !Cloth 12
			set % . !Type JWI
			goto gbp_out
		}

		if jester in !Property
		{
			set % . !Category 2
			set % . !Piece 12
			set % . !Cloth 15
			set % . !Type EWI
			goto gbp_out
		}
	}

	if bonnet in !Property
	{
		set % . !Category 2
		set % . !Piece 9
		set % . !Cloth 11
		set % . !Type HWI
		goto gbp_out
	}

	if doublet in !Property
	{
		set % . !Category 3
		set % . !Piece 1
		set % . !Cloth 8
		set % . !Type XVL
		goto gbp_out
	}

	if shirt in !Property && fancy notin !Property
	{
		set % . !Category 3
		set % . !Piece 2
		set % . !Cloth 8
		set % . !Type FCI
		goto gbp_out
	}

	if shirt in !Property && fancy in !Property
	{
		set % . !Category 3
		set % . !Piece 3
		set % . !Cloth 8
		set % . !Type TQL
		goto gbp_out
	}

	if tunic in !Property && leather notin !Property && studded notin !Property
	{
		set % . !Category 3
		set % . !Piece 4
		set % . !Cloth 12
		set % . !Type HCM
		goto gbp_out
	}

	if surcoat in !Property
	{
		set % . !Category 3
		set % . !Piece 5
		set % . !Cloth 14
		set % . !Type PAM
		goto gbp_out
	}

	if dress in !Property
	{
		if plain in !Property
		{
			set % . !Category 3
			set % . !Piece 6
			set % . !Cloth 10
			set % . !Type DWL
			goto gbp_out
		}

		if fancy in !Property
		{
			set % . !Category 3
			set % . !Piece 7
			set % . !Cloth 12
			set % . !Type VQL_EWL
			goto gbp_out
		}
	}

	if cloak in !Property
	{
		set % . !Category 3
		set % . !Piece 8
		set % . !Cloth 14
		set % . !Type DCI
		goto gbp_out
	}

	if robe in !Property
	{
		set % . !Category 3
		set % . !Piece 9
		set % . !Cloth 16
		set % . !Type FWL
		goto gbp_out
	}

	if suit in !Property
	{
		set % . !Category 3
		set % . !Piece 10
		set % . !Cloth 24
		set % . !Type XBM
		goto gbp_out
	}

	if pants in !Property
	{
		if  short in !Property
		{
			set % . !Category 4
			set % . !Piece 1
			set % . !Cloth 6
			set % . !Type EDI
			goto gbp_out
		}

		if long in !Property
		{
			set % . !Category 4
			set % . !Piece 2
			set % . !Cloth 8
			set % . !Type VDI
			goto gbp_out
		}
	}

	if kilt in !Property
	{
		set % . !Category 4
		set % . !Piece 3
		set % . !Cloth 8
		set % . !Type LDI
		goto gbp_out
	}

	if skirt in !Property && leather notin !Property
	{
		set % . !Category 4
		set % . !Piece 4
		set % . !Cloth 10
		set % . !Type GCI
		goto gbp_out
	}

	if body in !Property
	{
		set % . !Category 5
		set % . !Piece 1
		set % . !Cloth 4
		set % . !Type FZH
		goto gbp_out
	}

	if apron in !Property
	{
		if half in !Property
		{
			set % . !Category 5
			set % . !Piece 2
			set % . !Cloth 6
			set % . !Type XDI
			goto gbp_out
		}

		if full in !Property
		{
			set % . !Category 5
			set % . !Piece 3
			set % . !Cloth 10
			set % . !Type RDI
			goto gbp_out
		}
	}

	if leather in !Property && studded notin !Property && bone notin !Property
	{
		if gorget in !Property
		{
			set % . !Category 7
			set % . !Piece 4
			set % . !Hides 4
			set % . !Type JKH
			goto gbp_out
		}

		if cap in !Property
		{
			set % . !Category 7
			set % . !Piece 5
			set % . !Hides 2
			set % . !Type NJL
			goto gbp_out
		}

		if gloves in !Property
		{
			set % . !Category 7
			set % . !Piece 6
			set % . !Hides 3
			set % . !Type KKH
			goto gbp_out
		}

		if sleeves in !Property
		{
			set % . !Category 7
			set % . !Piece 7
			set % . !Hides 4
			set % . !Type HKH
			goto gbp_out
		}

		if leggings in !Property
		{
			set % . !Category 7
			set % . !Piece 8
			set % . !Hides 10
			set % . !Type VKH
			goto gbp_out
		}

		if tunic in !Property
		{
			set % . !Category 7
			set % . !Piece 9
			set % . !Hides 12
			set % . !Type QKH
			goto gbp_out
		}

		if shorts in !Property
		{
			set % . !Category 9
			set % . !Piece 1
			set % . !Hides 8
			set % . !Type QSK
			goto gbp_out
		}

		if skirt in !Property
		{
			set % . !Category 9
			set % . !Piece 2
			set % . !Hides 6
			set % . !Type YSK
			goto gbp_out
		}

		if bustier in !Property
		{
			set % . !Category 9
			set % . !Piece 3
			set % . !Hides 6
			set % . !Type ATK
			goto gbp_out
		}

		if female in !Property
		{
			set % . !Category 9
			set % . !Piece 5
			set % . !Hides 8
			set % . !Type OSK
			goto gbp_out
		}
	}

	if studded in !Property
	{
		if gorget in !Property
		{
			set % . !Category 8
			set % . !Piece 1
			set % . !Hides 6
			set % . !Type ALH
			goto gbp_out
		}

		if gloves in !Property
		{
			set % . !Category 8
			set % . !Piece 2
			set % . !Hides 8
			set % . !Type XKH
			goto gbp_out
		}

		if sleeves in !Property
		{
			set % . !Category 8
			set % . !Piece 3
			set % . !Hides 10
			set % . !Type YKH
			goto gbp_out
		}

		if leggings in !Property
		{
			set % . !Category 8
			set % . !Piece 4
			set % . !Hides 12
			set % . !Type MLH
			goto gbp_out
		}

		if tunic in !Property
		{
			set % . !Category 8
			set % . !Piece 5
			set % . !Hides 14
			set % . !Type LLH
			goto gbp_out
		}

		if bustier in !Property
		{
			set % . !Category 9
			set % . !Piece 4
			set % . !Hides 8
			set % . !Type USK
			goto gbp_out
		}

		if armor in !Property
		{
			set % . !Category 9
			set % . !Piece 6
			set % . !Hides 10
			set % . !Type SSK
			goto gbp_out
		}
	}

	if bone in !Property
	{
		if helmet in !Property
		{
			set % . !Category 10
			set % . !Piece 1
			set % . !Hides 4
			set % . !Bones 2
			set % . !Type ZPH
			goto gbp_out
		}

		if gloves in !Property
		{
			set % . !Category 10
			set % . !Piece 2
			set % . !Hides 6
			set % . !Bones 2
			set % . !Type VPH
			goto gbp_out
		}

		if arms in !Property
		{
			set % . !Category 10
			set % . !Piece 3
			set % . !Hides 8
			set % . !Bones 4
			set % . !Type BQH
			goto gbp_out
		}

		if leggings in !Property
		{
			set % . !Category 10
			set % . !Piece 4
			set % . !Hides 10
			set % . !Bones 6
			set % . !Type CQH
			goto gbp_out
		}

		if armor in !Property
		{
			set % . !Category 10
			set % . !Piece 5
			set % . !Hides 12
			set % . !Bones 10
			set % . !Type PPH
			goto gbp_out
		}
	}

	if boots in !Property && thigh notin !Property
	{
		set % . !Category 6
		set % . !Piece 7
		set % . !Hides 8
		set % . !Type TVI
		goto gbp_out
	}

	if boots in !Property && thigh in !Property
	{
		set % . !Category 6
		set % . !Piece 8
		set % . !Hides 10
		set % . !Type ZVI
		goto gbp_out
	}

	if shoes in !Property
	{
		set % . !Category 6
		set % . !Piece 6
		set % . !Hides 6
		set % . !Type PVI
		goto gbp_out
	}

	if sandals in !Property
	{
		set % . !Category 6
		set % . !Piece 5
		set % . !Hides 4
		set % . !Type NVI
		goto gbp_out
	}

	gbp_out:
	set #lpc !lpc

	if % . !Category = N/A
	{
		display ok Impossible to recognize the bod. Please report the problem to Boydon! $Script will be halted!
		halt
	}

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name GetSmithyBodParameters
;* @ver 1.0 beta 07Oct05
;***** REVISION DATE 27/03/2011 by Aeron **********
;* @author  Boydon
;* @purpose Get info about the piece that is needed to fill the BOD
;*
;* @params %1 req #property of the bod
;* 				 %2 opt name of the variable containing the category without the "%" symbol (default is "category")
;* 				 %3 opt name of the variable containing the piece without the "%" symbol (default is "piece")
;* 				 %4 opt name of the variable containing the required ingots without the "%" symbol (default is "ingots")
;*				 %5 opt name of the variable containing the item type without the "%" symbol (default is "type")
;*
;* @returns
;* @example call GetBodParameters.euo GetSmithyBodParameters #property
;*							this is the standar call
;*					call GetBodParameters.euo GetSmithyBodParameters #property selection piece_number ing item_type
;*							this is a call wich will return infos in %selection, %piece_number, %ing and %item_type variables
;* @status need to be tested

sub GetSmithyBodParameters            ; MANCANO I CRAFT PER STAGYON ABBYS

	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub GetTailorBodParameters: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	if %2 = N/A || %0 = 1
		set %2 category
	if %3 = N/A || %0 <= 2
		set %3 piece
	if %4 = N/A || %0 <= 3
		set %4 ingots
	if %5 = N/A || %0 <= 4
		set %5 Type


	nameSpace Push
	nameSpace Local GetTailorBodParameters , #time , #random , #scnt2

	set !Property %1
	set !Category %2
	set !Piece %3
	set !Ingots %4
	set !Type %5

	set !lpc #lpc
	set #lpc 500

	set % . !Category N/A
	set % . !Ingots 0

	if plate in #property     ;  PLATEMAIL
	{
		if Arms in #property
		{
			set % . !Category 1
			set % . !Piece 8
			set % . !Ingots 18
			set % . !Type MSH
			goto gbbp_out
		}

		if female in #property
		{
			set % . !Category 1
			set % . !Piece 13
			set % . !Ingots 20
			set % . !Type MSK
			goto gbbp_out
		}

		if legs in #property
		{
			set % . !Category 1
			set % . !Piece 11
			set % . !Ingots 20
			set % . !Type LSH
			goto gbbp_out
		}

		if gorget in #property
		{
			set % . !Category 1
			set % . !Piece 10
			set % . !Ingots 10
			set % . !Type NSH
			goto gbbp_out
		}

		if tunic in #property
		{
			set % . !Category 1
			set % . !Piece 12
			set % . !Ingots 25
			set % . !Type HSH
			goto gbbp_out
		}

		if gloves in #property
		{
			set % . !Category 1
			set % . !Piece 9
			set % . !Ingots 12
			set % . !Type ISH
			goto gbbp_out
		}

		if helm in #property
		{
			set % . !Category 2
			set % . !Piece 5
			set % . !Ingots 15
			set % . !Type OSH
			goto gbbp_out
		}
	}

	if ringmail in #property
	{
		if Leggings in #property
		{
			set % . !Category 1
			set % . !Piece 2
			set % . !Ingots 16
			set % . !Type IMH
			goto gbbp_out
		}

		if Gloves in #property
		{
			set % . !Category 1
			set % . !Piece 1
			set % . !Ingots 10
			set % . !Type BMH
			goto gbbp_out
		}

		if Tunic in #property
		{
			set % . !Category 1
			set % . !Piece 4
			set % . !Ingots 18
			set % . !Type WLH
			goto gbbp_out
		}

		if Sleeves in #property
		{
			set % . !Category 1
			set % . !Piece 3
			set % . !Ingots 14
			set % . !Type XLH
			goto gbbp_out
		}
	}

	if chainmail in #property     ; CHAIMAIL
	{
		if Leggings in #property
		{
			set % . !Category 1
			set % . !Piece 6
			set % . !Ingots 18
			set % . !Type APH
			goto gbbp_out
		}

		if coif in #property
		{
			set % . !Category 1
			set % . !Piece 5
			set % . !Ingots 10
			set % . !Type DPH
			goto gbbp_out
		}

		if Tunic in #property
		{
			set % . !Category 1
			set % . !Piece 7
			set % . !Ingots 20
			set % . !Type ZOH
			goto gbbp_out
		}

	}

	if axe in #property && war notin #property   ;AXE
	{
		if two in #property
		{
			set % . !Category 5
			set % . !Piece 6
			set % . !Ingots 16
			set % . !Type LPH
			goto gbbp_out
		}

		if Executioner in #property
		{
			set % . !Category 5
			set % . !Piece 4
			set % . !Ingots 14
			set % . !Type ZRF
			goto gbbp_out
		}

		if Large in #property
		{
			set % . !Category 5
			set % . !Piece 5
			set % . !Ingots 12
			set % . !Type RMH
			goto gbbp_out
		}

		if Double in #property
		{
			set % . !Category 5
			set % . !Piece 3
			set % . !Ingots 12
			set % . !Type NSF
			goto gbbp_out
		}

		if Battle in #property
		{
			set % . !Category 5
			set % . !Piece 2
			set % . !Ingots 14
			set % . !Type BSF
			goto gbbp_out
		}

		if two notin #property && Executioner notin #property && Large notin #property && Double notin #property && Battle notin #property && war notin #property
		{
			set % . !Category 5
			set % . !Piece 1
			set % . !Ingots 14
			set % . !Type LSF
			goto gbbp_out
		}
	}

	if Spear in #property && short notin #property    ;DA CONTROLLARE
	{
		set % . !Category 6
		set % . !Piece 9
		set % . !Ingots 12
		set % . !Type MTF
		goto gbbp_out
	}

	if Spear in #property && short in #property   ;DA CONTROLLARE
	{
		set % . !Category 6
		set % . !Piece 7
		set % . !Ingots 6
		set % . !Type XRH
		goto gbbp_out
	}

	if war in #property
	{
		if mace in #property
		{
			set % . !Category 7
			set % . !Piece 5
			set % . !Ingots 14
			set % . !Type TRH
			goto gbbp_out
		}

		if axe in #property
		{
			set % . !Category 5
			set % . !Piece 7
			set % . !Ingots 16
			set % . !Type UOH
			goto gbbp_out
		}
		if fork in #property
		{
			set % . !Category 6
			set % . !Piece 10
			set % . !Ingots 12
			set % . !Type RRH
			goto gbbp_out
		}

		if Hammer in #property
		{
			set % . !Category 7
			set % . !Piece 6
			set % . !Ingots 16
			set % . !Type ZTH
			goto gbbp_out
		}
	}

	if helmet in #property     ;HELMET
	{
		if close in #property
		{
			set % . !Category 2
			set % . !Piece 2
			set % . !Ingots 15
			set % . !Type ESH
			goto gbbp_out
		}

		if ! ( close in #property )
		{
			set % . !Category 2
			set % . !Piece 3
			set % . !Ingots 15
			set % . !Type GSH
			goto gbbp_out
		}
	}

	if Shield in #property
	{
		if Bronze , #SPC , Shield in #property
		{
			set % . !Category 3
			set % . !Piece 2
			set % . !Ingots 12
			set % . !Type GIK
			goto gbbp_out
		}

		if Tear in #property && Kite in #property
		{
			set % . !Category 3
			set % . !Piece 6
			set % . !Ingots 16
			set % . !Type MIK_LIK
			goto gbbp_out
		}

		if Metal in #property && Kite in #property
		{
			set % . !Category 3
			set % . !Piece 5
			set % . !Ingots 16
			set % . !Type AIK
			goto gbbp_out
		}

		if Metal in #property && Kite notin #property
		{
			set % . !Category 3
			set % . !Piece 4
			set % . !Ingots 14
			set % . !Type NIK
			goto gbbp_out
		}

		if Heater in #property
		{
			set % . !Category 3
			set % . !Piece 3
			set % . !Ingots 18
			set % . !Type CIK
			goto gbbp_out
		}
	}

	if Bascinet in #property
	{
		set % . !Category 2
		set % . !Piece 1
		set % . !Ingots 15
		set % . !Type ASH
		goto gbbp_out
	}

	if Norse in #property
	{
		set % . !Category 2
		set % . !Piece 4
		set % . !Ingots 15
		set % . !Type CSH
		goto gbbp_out
	}

	if Buckler in #property
	{
		set % . !Category 3
		set % . !Piece 1
		set % . !Ingots 10
		set % . !Type FIK
		goto gbbp_out
	}

	if sword in #property      ;BLADE
	{
		if Viking in #property
		{
			set % . !Category 4
			set % . !Piece 10
			set % . !Ingots 14
			set % . !Type BPH
			goto gbbp_out
		}

		if Long in #property
		{
			set % . !Category 4
			set % . !Piece 8
			set % . !Ingots 12
			set % . !Type JTF
			goto gbbp_out
		}

		if Broad in #property
		{
			set % . !Category 4
			set % . !Piece 2
			set % . !Ingots 10
			set % . !Type ATF
			goto gbbp_out
		}
	}

	if Scimitar in #property
	{
		set % . !Category 4
		set % . !Piece 9
		set % . !Ingots 10
		set % . !Type SOH
		goto gbbp_out
	}

	if Katana in #property
	{
		set % . !Category 4
		set % . !Piece 6
		set % . !Ingots 8
		set % . !Type NMH
		goto gbbp_out
	}

	if Cutlass in #property
	{
		set % . !Category 4
		set % . !Piece 4
		set % . !Ingots 8
		set % . !Type JPH
		goto gbbp_out
	}

	if Kryss in #property
	{
		set % . !Category 4
		set % . !Piece 7
		set % . !Ingots 8
		set % . !Type VRH
		goto gbbp_out
	}

	if Bardiche in #property
	{
		set % . !Category 6
		set % . !Piece 1
		set % . !Ingots 18
		set % . !Type HSF
		goto gbbp_out
	}

	if Halberd in #property
	{
		set % . !Category 6
		set % . !Piece 4
		set % . !Ingots 20
		set % . !Type XTH
		goto gbbp_out
	}

	if Hammer , #SPC , Pick in #property
	{
		set % . !Category 7
		set % . !Piece 1
		set % . !Ingots 16
		set % . !Type VTH
		goto gbbp_out
	}

	if Mace in #property && war notin #property
	{
		set % . !Category 7
		set % . !Piece 2
		set % . !Ingots 6
		set % . !Type YSF
		goto gbbp_out
	}

	if Maul in #property
	{
		set % . !Category 7
		set % . !Piece 3
		set % . !Ingots 10
		set % . !Type BUH
		goto gbbp_out
	}

	if dagger in #property
	{
		set % . !Category 4
		set % . !Piece 5
		set % . !Ingots 3
		set % . !Type TSF
		goto gbbp_out
	}

	gbbp_out:
	set #lpc !lpc

	if % . !Category = N/A
	{
		display ok Impossible to recognize the bod. Please report the problem to Boydon! $Script will be halted!
		halt
	}

	nameSpace Clear
	nameSpace Pop
return

;==================
;**
;* @name GetBodMaterial
;* @ver 1.2 07Oct05
;* @author  Boydon
;* @purpose This sub will tell you wich material is required by the BOD
;*					The material will be returned in a var defined by the user without the "%" symbol.
;*					Default variable name is "material"
;*
;* @params %1 req bod type (tailor|smithy) or the #findcol of the bod (1155|1102)
;*				 %2 req bod #property
;*				 %3 opt name of the var containing the material without the "%" symbol (default is "material")
;*
;* @returns
;*
;* @example call GetBodParameters.euo GetBodMaterial tailor #property
;*							this is the standar call
;*					call GetBodParameters.euo GetBodMaterial tailor #property material_needed
;*							this is a call with the material being returned to %material_needed
;* @status BlackSmithy support needs to be tested

sub GetBodMaterial

	if %0 < 2 || %1 = N/A || %2 = N/A
	{
		display ok Wrong use of Sub GetBodParameters: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	if %1 <> tailor && %1 <> smithy && %1 <> 1155 && %1 <> 1102
	{
		display ok Wrong value for parameter 1 in sub GetBodParameters!
			+$Script will be halted!
		halt
	}

	if %3 = N/A || %0 <= 2
		set %3 material

	nameSpace Push
	nameSpace Local GetBodMaterial , #time , #random , #scnt2

	set !lpc #lpc
	set #lpc 500

	set !BodType %1
	set !Property %2
	set !Material %3

	if !BodType = tailor || !BodType = 1155
	{
		if leather notin !Property && studded notin !Property && bone notin !Property && boots notin !Property && shoes notin !Property && sandals notin !Property
	    set % . !Material cloth

		if leather in !Property || studded in !Property || bone in !Property || boots in !Property || shoes in !Property || sandals in !Property
		{
       if Large , #spc , Bulk in !property && ( #spc , Hat in !property || Bandana in !property || Bonnet in !property || Skullcap in !property )
          set % . !Material cloth
       else
  		    set % . !Material 0
  	}

		if All , #SPC , Items , #SPC , Must , #SPC , Be , #SPC , Made , #SPC , With in #property
		{
			if spined , #SPC , Leather in !Property
				set % . !Material 2220
			if horned , #SPC , Leather in !Property
				set % . !Material 2117
			if barbed , #SPC , Leather in !Property
				set % . !Material 2129
		}
	}

	if !BodType = smithy || !BodType = 1102
	{
		set % . !Material 0

		if All , #SPC , Items , #SPC , Must , #SPC , Be , #SPC , Made , #SPC , With in #property
		{
			if Dull , #SPC , Copper , #SPC , Ingots in #property
				set % . !Material 2419
			if Shadow , #SPC , Iron , #SPC , Ingots in #property
				set % . !Material 2406
			if Copper , #SPC , Ingots in #property && Dull notin #property
				set % . !Material 2413
			if Bronze , #SPC , Ingots in #property
				set % . !Material 2418
			if Gold , #SPC , Ingots in #property
				set % . !Material 2213
			if Agapite , #SPC , Ingots in #property
				set % . !Material 2425
			if Verite , #SPC , Ingots in #property
				set % . !Material 2207
			if Valorite , #SPC , Ingots in #property
				set % . !Material 2219
		}

	}

	set #lpc !lpc

	namespace Clear
	namespace Pop

return

;==================
;**
;* @name GetBodQuantity
;* @ver 1.0 11May05
;* @author  Boydon
;* @purpose This sub will tell you how many items are totaly needed to
;*					fill a bod.
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will return the number of item needed to accomplish the Bod.
;* 					Result can be 10|15|20. Other value will return an error.
;* @example call GetBodParameters.euo GetBodQuantity #property
;* @status Tested and working fine.

sub GetBodQuantity

	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub GetBodQuantity: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	nameSpace Push
	nameSpace Local GetBodQuantity , #time , #random , #scnt2

	set !Property %1

	set !lpc #lpc
	set #lpc 500

	str pos !Property Make
	set !Quantity #strres + 5
	str del !Property 1 !Quantity
	set !quantity #strres
	str left !Quantity 2
	;set !Quantity #strres

	set #lpc !lpc

	nameSpace Clear
	nameSpace Pop

	if #strres <> 10 && #strres <> 15 && #strres <> 20
	{
		display ok Unexpected value returned from sub GetBodQuantity! Please check!
			+$Script will be halted!
		halt
	}

return #strres

;==================
;**
;* @name GetBodAlredyMadeQuantity
;* @ver 1.1 26May06
;* @author  Boydon
;* @purpose If a bod is partially filled this sub will let you how many
;*					items have been already added inside it.
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will return the number of item alredy added to the Bod
;* @example call GetBodParameters.euo GetBodAlredyMadeQuantity #property
;* @status Tested and working fine.

; @ag: spelling fix by AG
sub GetBodAlreadyMadeQuantity
    gosub GetBodAlredyMadeQuantity %1
return #result

sub GetBodAlredyMadeQuantity
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub GetBodAlreadyMadeQuantity: some required arguments are missing!
			+$Script will be halted.
		halt
	}

	nameSpace Push
	nameSpace Local GetBodAlredyMadeQuantity , #time , #random , #scnt2

	set !Property %1

	set !lpc #lpc
	set #lpc 500

	;Fix for UO ML
	if weight: in #property
	{
		str pos !Property weight:
		str del !Property #strres 7
		set !Property #strres
	}

	str pos !Property :
	str del !Property #strres 1
	set !MadeQuantity #strres
	str pos !MadeQuantity :
	set #strres ( #strres + 1 )
	str del !MadeQuantity 1 #strres
	set !MadeQuantity #strres
	str pos !MadeQuantity $
	str del !MadeQuantity #strres 1
	;set !MadeQuantity #strres

	set #lpc !lpc

	nameSpace Clear
	nameSpace Pop
return #strres

;==================
;**
;* @name BodIsLarge
;* @ver 1.0 11May05
;* @author  Boydon, AG
;* @purpose Identify Large bods
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will return #true if a bod IS a large bod or #false if it IS NOT a large bod
;* @example call GetBodParameters.euo BodIsLarge #property
;* @status working fine, no test needed
;*         by AG: A test was needed! What about "Large Battle Axes"? I fixed it.

sub BodIsLarge
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BodIsLarge: some required arguments are missing!
			+$Script will be halted.
		halt
	}
return large , #spc , bulk in %1

;==================
;**
;* @name BodIsSmall
;* @ver 2.0 14Oct05
;* @author  Boydon
;* @purpose Identify Small bods
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will return #true if a bod IS a small bod or #false if it IS NOT a small bod
;* @example call GetBodParameters.euo BodIsSmall #property
;* @status working fine, no test needed

sub BodIsSmall
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BodIsLarge: some required arguments are missing!
			+$Script will be halted.
		halt
	}
return large , #SPC , Bulk notin %1

;==================
;**
;* @name BodIsEceptional
;* @ver 1.0 11May05
;* @author  Boydon
;* @purpose Identify Exceptional bods
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will return #true if a bod IS an exceptional bod or #false if it IS NOT an exceptional bod
;* @example call GetBodParameters.euo BodIsExceptional #property
;* @status working fine, no test needed

sub BodIsExceptional
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BodIsExceptional: some required arguments are missing!
			+$Script will be halted.
		halt
	}
return exceptional in %1

;==================
;**
;* @name BodIsNormal
;* @ver 1.0 11May05
;* @author  Boydon
;* @purpose Identify Normal bods
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will return #true if a bod IS a normal bod or #false if it IS NOT a normal bod
;* @example call GetBodParameters.euo BodIsNormal #property
;* @status working fine, no test needed

sub BodIsNormal
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BodIsNormal: some required arguments are missing!
			+$Script will be halted.
		halt
	}
return exceptional notin %1

;==================
;**
;* @name BodIsTailor
;* @ver 1.0 11May05
;* @author  Boydon
;* @purpose Identify Tailoring bods
;*
;* @params %1 req #findcol of the bod
;*
;* @returns This sub will return #true if a bod IS a tailoring bod or #false if it IS NOT a tailoring bod
;* @example call GetBodParameters.euo BodIsTailor #findcol
;* @status working fine, no test needed

sub BodIsTailor
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BodIsTailor: some required arguments are missing!
			+$Script will be halted.
		halt
	}
return %1 = 1155

;==================
;**
;* @name BodIsSmithy
;* @ver 1.0 11May05
;* @author  Boydon
;* @purpose Identify Blacksmithy bods
;*
;* @params %1 req #findcol of the bod
;*
;* @returns This sub will return #true if a bod IS a blacksmithy bod or #false if it IS NOT a blacksmithy bod
;* @example call GetBodParameters.euo BodIsSmithy #findcol
;* @status working fine, no test needed

sub BodIsSmithy
	if %0 < 1 || %1 = N/A
	{
		display ok Wrong use of Sub BodIsSmithy: some required arguments are missing!
			+$Script will be halted.
		halt
	}
return %1 = 1102

;==================
;**
;* @name Initialize
;* @ver 1.2 03Apr09
;* @author  Boydon / AG
;* @purpose This function is for internal purpose only. If you plan to use this
;*						library inside one of your script, running this will ensure you,
;*						returning the version number of the library, that you are calling
;*						the library in the right way.
;*
;* @params
;*
;* @returns Version of the library with no float
;* @example call GetBodParameters.euo Initialize
;* @status tested and working properly

Sub Initialize
return 300 ; version by Boydon: 200; version by AG: 300.

Sub Inizialize ; misspelled, but required for backward compatibility
    gosub Initialize
return #result

;=========================
;=========================
; Version 3.0 (by AG)
;=========================
;=========================

;==================
;**
;* @name GetMaterialName
;* @ver 1.0 06Apr09
;* @author  ag
;* @purpose Returns the name of a material from its #findcol
;* @params %1 req #findcol of the material
;*         %2 req #true if the given material is a tailoring material
;* @returns The human name of the given material
;* @example call BodFunctions.euo GetMaterialName #findcol
;* @status beta

sub GetMaterialName ; %colorCode %tailor
    if %1 = cloth
       return Cloth
    if %1 = 2220
       return Spined , #spc , Leather
    if %1 = 2117
       return Horned , #spc , Leather
    if %1 = 2129
       return Barbed , #spc , Leather

    if %1 = 2419
       return Dull , #spc , Copper
    if %1 = 2406
       return Shadow , #spc , Iron
    if %1 = 2413
       return Copper
    if %1 = 2418
       return Bronze
    if %1 = 2213
       return Gold
    if %1 = 2425
       return Agapite
    if %1 = 2207
       return Verite
    if %1 = 2219
       return Valorite

    if %1 = 0
    {
       if %2
          return Leather
       else
          return Iron
    }
return Unknown

;==================
;**
;* @name GetLargeBodQuantity
;* @ver 1.0 03Apr09
;* @author  ag
;* @purpose This sub will tell you how many small BODs are needed to fill a large BOD.
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will tell you how many small BODs are needed to fill a large BOD.
;* 					Result can be 4|5|6. Result on a small BOD is unpredictable.
;* @example call BodFunctions.euo GetLargeBodQuantity #property
;* @status tested and working

sub GetLargeBodQuantity
  	if %0 < 1 || %1 = N/A
  	{
  		display ok Wrong use of Sub GetBodCardinality: some required arguments are missing!
  			+$Script will be halted.
  		halt
  	}
  	nameSpace Push
  	nameSpace Local GetLargeBodQuantity , #time , #random , #scnt2
  	set !property %1
  	set !lpc #lpc
  	set #lpc 500

    str len !property
    set !propertyLength #strres

    set !search amount , #spc , to , #spc , make
    str pos !property !search
    set !interestingLength ( !propertyLength - #strres - 20 )

    str right !property !interestingLength
    set !interesting #strres

    str count !interesting $  ; quante linee nella stringa?
    set !quantity #strres

    set #result !quantity
  	set #lpc !lpc
    nameSpace Clear
 	  nameSpace Pop
return #result

;==================
;**
;* @name GetLargeBodAlreadyMadeQuantity
;* @ver 1.0 03Apr09
;* @author  ag
;* @purpose This sub will tell you how many small BODs are contained into a large BOD.
;*
;* @params %1 req #property of the bod
;*
;* @returns This sub will tell you how many small BODs are contained into the large BOD.
;*          Result on a small BOD is unpredictable.
;* @example call BodFunctions.euo GetLargeBodAlreadyMadeQuantity #property
;* @status Tested

sub GetLargeBodAlreadyMadeQuantity
  	if %0 < 1 || %1 = N/A
  	{
  		display ok Wrong use of Sub GetBodCardinality: some required arguments are missing!
  			+$Script will be halted.
  		halt
  	}
  	nameSpace Push
  	nameSpace Local GetLargeBodAlreadyMadeQuantity , #time , #random , #scnt2
  	set !property %1
  	set !lpc #lpc
  	set #lpc 500

    set !quantity -1  ; escludi il campo "amount to make"
    str count !property 10
    set !quantity ( !quantity + #strres )
    str count !property 15
    set !quantity ( !quantity + #strres )
    str count !property 20
    set !quantity ( !quantity + #strres )

    set #result !quantity
  	set #lpc !lpc
    nameSpace Clear
 	  nameSpace Pop
return #result

;=========================================================
;**
;* @name    GetLargeBodItemSet
;* @ver     2.0
;* @author  AG (converted from a script by snicker7)
;* @purpose Returns the identifier associated with the item set of a large BOD.
;*
;* @params %1 req  #property of the large bod
;* @returns The identifier of the item set needed to fill the large BOD.
;*          Result is unpredictable if the bod is small.
;*
;* @example call BodFunctions.euo GetLargeBodItemSet %bodProperty
;* @status Tested and debugged

sub GetLargeBodItemSet ; %property
    namespace push
    namespace local GetLargeBodItemSet , #systime , #random
    set !lpc #lpc
    set #lpc 500
    gosub GetLargeBodItemSet_Core %1
    set #lpc !lpc
    namespace clear
    namespace pop
return #result

sub GetLargeBodItemSet_core ; %property
    set !property %1
  	if large , #spc , bulk notin !property
       return error

    ; extract the name of the first item
  	str pos !property make:
  	set !pos #strRes + 8
  	str del !property 1 !pos
  	set !item1 #strRes
  	str pos !item1 :
  	set !len #strres - 1
  	str left !item1 !len
  	set !item1 #strres

		if cutlass in !item1 || katana in !item1 || scimitar in !item1 || broad in !item1 || longsword in !item1 || viking in !item1
			return Swords
		if kryss in !item1 || spear in !item1 || warfork in !item1 || dagger in !item1
			return Fencing
		if axe in !item1 && war notin !item1
			return Axes
		if mace in !item1 || maul in !item1 || hammer in !item1 || war , #spc , axe in !item1
			return Maces
		if bardiche in !item1 || halberd in !item1
			return Polearms
		if chainmail in !item1
			return Chainmail
		if ringmail in !item1
			return Ringmail
		if studded in !item1
			return Studded
		if plate in !item1
			return Platemail
		if sandals in !item1
			return Footwear
		if gorget in !item1 && studded notin !item1
			return Leather
		if skirt in !item1
			return LeatherFemale
		if bone in !item1
			return Bone
		if bandana in !item1
			return Gypsy
		if skullcap in !item1
			return Pirate
		if straw in !item1
			return Farmer
		if wizard in !item1
			return Wizard
		if floppy in !item1
			return Girl
		if feathered in !item1
			return TownCrier
		if bonnet in !item1
			return Lady
		if jester in !item1
			return Jester
		if tricorne in !item1
			return Hats
return unknown

;=========================================================
;* @name    GetSmallBodItemName
;* @ver     1.0 03Apr09
;* @author  ag (converted from a script by snicker7)
;* @purpose Returns the name of the item associated with a small BOD.
;*
;* @params %1 req #property of the small bod
;* @returns Name of the item needed to fill the small BOD.
;*          Result is unpredictable if the bod is large.
;*
;* @example call BodFunctions.euo GetSmallBodItemName %bodProperty
;* @status Tested
;*

sub GetSmallBodItemName ; %property
    namespace push
    namespace local GetSmallBodItemName , #systime , #random
    set !property %1
    set !lpc #lpc
    set #lpc 500

  	str pos !property make:
  	set !pos #strRes + 3
  	str del !property 1 !pos
  	set !s7BFItemString #strRes
  	str pos !s7BFItemString :
  	set !pos #strRes + 1
  	str pos !s7BFItemString $
  	set !len #strRes - !pos
  	str mid !s7BFItemString !pos !len
  	str del !s7BFItemString 1 5
  	set !s7BFItemString #strRes
  	str pos !s7BFItemString :
  	set #strres #strres - 1
  	str left !s7BFItemString #strRes
  	set !gbi_item1 #strRes
    set #result !gbi_item1

    set #lpc !lpc
    namespace clear
    namespace pop
return #result

;========================================================================
;* @name    GetLargeBodData
;* @ver     1.0 01Mag09
;* @author  ag
;* @purpose
;* @params  none
;* @returns Some important data bound to a certain Large BOD.
;* @status  Testing.

sub GetLargeBodData
    namespace push
    namespace local GetLargeBodData , #systime , #random
    gosub GetLargeBodData_Core %1
    namespace clear
    namespace pop
return #result

sub GetLargeBodData_Core ; %setId
    set !key %1
    if !key >= 1 && !key <= 22
       goto BodItemSetDb_ , !key
    set !index _Swords_Fencing_Axes_Maces_Polearms_Chainmail_Ringmail_Platemail_
               +Footwear_Bone_Studded_LeatherFemale_Leather_Farmer_Girl_Gypsy_Hats_Jester_Lady_Pirate_Wizard_TownCrier_
    set !key !key , _
    if !key notin !index
       return !null
    str pos !index !key
    str left !index #strres
    str count #strres _
    set !key #strres
       
    goto BodItemSetDb_ , !key
       return !null

    BodItemSetDb_1: ; cutlass, broadsword, katana, longsword, scimitar, viking sword
      return Swords__KPH_JPH__ATF_ZSF__OMH_NMH__KTF_JTF_TCO__POH_SOH__BPH_EPH_
    BodItemSetDb_2: ; dagger, kryss, short spear, war fork
      return Fencing__TSF_WSF__WRH_VRH__YRH_XRH__SRH_RRH_
    BodItemSetDb_3: ; axe, battle axe, double axe, executioner's axe, large battle axe, two-handed axe
      return Axes__LSF_OSF__BSF_MSF__NSF_ISF__ZRF_CSF__SMH_RMH__MPH_LPH_
    BodItemSetDb_4: ; hammer pick, mace, maul, war axe, war hammer, war mace
      return Maces__WTH_VTH__YSF_XSF__CUH_BUH__DUG_JOH__AUH_ZTH__URH_TRH_
    BodItemSetDb_5: ; bardiche, halberd
      return Polearms__HSF_KSF__YTH_XTH_
    BodItemSetDb_6: ; chainmail coif, chainmail leggings, chainmail tunic
      return Chainmail__DPH_MKH__YOH_APH_LKH_NKH__XOH_ZOH_OKH_IKH_
    BodItemSetDb_7: ; ringmail gloves, ringmail leggings, ringmail sleeves, ringmail tunic
      return Ringmail__BMH_KMH__IMH_HMH_NLH_QLH__ZLH_CMH_YLH_XLH__WLH_VLH_
    BodItemSetDb_8: ; platemail arms, platemail legs, plate helm, platemail gorget, platemail gloves, platemail tunic
      return Platemail__MSH_JSH__LSH_WSH__OSH_TSH__NSH__ISH_USH__HSH_KSH_
    BodItemSetDb_9: ; sandals, shoes, boots, thigh boots
      return Footwear__NVI_QVI__PVI_AWI__TVI_OVI__ZVI_CWI_
    BodItemSetDb_10: ; Bone Armor, Bone Arms, Bone Gloves, Bone Helmet, Bone Leggings
      return Bone__PPH_WPH__QPH_BQH__AQH_VPH__ZPH_YPH__CQH_
    BodItemSetDb_11: ; Studded Gloves, Studded Gorget, Studded Leggings, Studded Sleeves, Studded Tunic
      return Studded__XKH_FLH__ALH__KLH_MLH_HLH_RLH__YKH_ZKH_GLH_ILH__JLH_LLH_SLH_ULH_
    BodItemSetDb_12: ; Female Leather Armor, Leather Bustier, Leather Shorts, Leather Skirt, Studded Armor, Studded Bustier
      return LeatherFemale__OSK__ATK_ZSK__QSK_PSK__YSK_XSK__SSK_RSK__USK_TSK_
    BodItemSetDb_13: ; Leather Cap, Leather Gloves, Leather Gorget, Leather Leggings, Leather Sleeves, Leather Tunic
      return Leather__NJL_QJL_PSO_SSO__KKH_SKH__JKH__TKH_VKH_CLH_ELH__HKH_UKH_PKH_RKH__WKH_QKH_BLH_DLH_
    BodItemSetDb_14: ; Straw Hat, Tunic, Long Pants, Boots
      return Farmer__YVI_XVI__HCM_KCM__VDI_YDI__TVI_OVI_
    BodItemSetDb_15: ; Floppy Hat, Full Apron, Plain Dress, Sandals
      return Girl__BWI__RDI_UDI__DWL_GWL__NVI_QVI_
    BodItemSetDb_16: ; Bandana, Shirt, Skirt, Thigh Boots
      return Gypsy__TDI_GZH__FCI_QCI__GCI_NDI__ZVI_CWI_
    BodItemSetDb_17: ; Tricorne Hat, Cap, Wide-Brim Hat, Tall Straw Hat
      return Hats__JWI__VVI__WVI__YVI_
    BodItemSetDb_18: ; Jester Hat, Jester Suit, Cloack, Shoes (jester's?)
      return Jester__EWI__XBM_ICM__DCI_ODI__PVI_AWI_
    BodItemSetDb_19: ; Bonnet, Half Apron, Fancy Dress, Sandals
      return Lady__HWI__XDI_SDI__VQL_EWL_VMO_QMO_PMO_SMO__NVI_QVI_
    BodItemSetDb_20: ; Skullcap, Doublet, Kilt, Shoes
      return Pirate__HZH_CZH__XVL_SVL__LDI_WDI__PVI_AWI_
    BodItemSetDb_21: ; Wizard's Hat, Body Sash, Robe, Boots
      return Wizard__IWI__FZH_IZH__FWL_AWL_CHO_BHO_EHO_DHO__TVI_OVI_
    BodItemSetDb_22: ; Feathered Hat, Surcoat, Fancy Shirt, Short Pants, Thigh Boots
      return TownCrier__KWI__PAM_SAM__TQL_WQL__EDI_DDI__ZVI_CWI_
return

sub getLargeBodLinkedItems ; %setId
    namespace push
    namespace local getLargeBodLinkedItems , #systime , #random
    set !setId %1
    gosub getLargeBodData !setId
    set !data #result
    str pos !data _
    str del !data 1 #strres
    set #result #strres
    namespace clear
    namespace pop
return #result

sub getLargeBodSetName ; %setIndex
    namespace push
    namespace local getLargeBodLinkedItems , #systime , #random
    set !setId %1
    gosub getLargeBodData !setId
    set !data #result
    str pos !data _
    set !len #strres - 1
    str left !data !len
    set #result #strres
    namespace clear
    namespace pop
return #result

; @todo aggiungere commenti descrittivi
sub getSmallBodLinkedItems ; %bodItemId
    namespace push
    namespace local getSmallBodLinkedItems , #systime , #random
    set !lpc #lpc
    set #lpc 500
    set !itemId _ , %1 , _
    set !largeBods _

    for !i 1 22
    {
        gosub GetLargeBodLinkedItems !i
        if !itemId in #result
        {
            gosub GetLargeBodSetName !i
            set !largeBods !largeBods , #result , _
        }
    }

    set #result !largeBods
    set #lpc !lpc
    namespace clear
    namespace pop
return #result

; @todo aggiungere commenti descrittivi
sub getBodReward ; setId %materialName %quantity %quality
    namespace push
    namespace local getBodReward , #systime , #random
    set !set %1
    set !material %2
    set !quantity %3
    if %0 < 4 || %4 <> #true
       set !quality r
    else
       set !quality e
    if !set in _Swords_Fencing_Axes_Maces_Polearms_
    {
        set !material sm
    }
    else
    {
        str left !material 2
        set !material #strres
    }
    gosub getBodReward_NameToId !set
    gosub getBodReward_Core #result !material !quantity !quality

    namespace clear
    namespace pop
return #result

sub getBodReward_NameToId ; %setname
    goto BodRewardDatabase_ , %1
    return !null
    
    BodRewardDatabase_SmithSmall:
        return SS
    BodRewardDatabase_TailorSmall:
        return TS
    BodRewardDatabase_Polearms:
        return S2
    BodRewardDatabase_Fencing:
        return S5
    BodRewardDatabase_Swords:
    BodRewardDatabase_Maces:
    BodRewardDatabase_Axes:
        return S6
    BodRewardDatabase_Chainmail:
        return SC
    BodRewardDatabase_Ringmail:
        return SR
    BodRewardDatabase_Platemail:
        return SP
    BodRewardDatabase_Footwear:
    BodRewardDatabase_Farmer:
    BodRewardDatabase_Girl:
    BodRewardDatabase_Gypsy:
    BodRewardDatabase_Hats:
    BodRewardDatabase_Jester:
    BodRewardDatabase_Lady:
    BodRewardDatabase_Pirate:
    BodRewardDatabase_Wizard:
        return T4
    BodRewardDatabase_Bone:
    BodRewardDatabase_Studded:
    BodRewardDatabase_TownCrier:
        return T5
    BodRewardDatabase_LeatherFemale:
    BodRewardDatabase_Leather:
        return T6
return

sub getBodReward_Core ; setId %materialName %quantity %quality
    goto BodRewardDatabase_ , %1 , %4 , %3 , %2
    return !null

    BodRewardDatabase_SSr10ir:
        return _Sturdy:100_
    BodRewardDatabase_SSr15ir:
        return _Sturdy:100_
    BodRewardDatabase_SSr20ir:
        return _Sturdy:90_MiningGloves1:10_
    BodRewardDatabase_SSr10du:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr15du:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr20du:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr10sh:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr15sh:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr20sh:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr10co:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr15co:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr20co:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr10br:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr15br:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSr20br:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SSr10go:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SSr15go:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SSr20go:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SSr10ag:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SSr15ag:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SSr20ag:
        return _DullHammer:100_
    BodRewardDatabase_SSr10ve:
        return _DullHammer:100_
    BodRewardDatabase_SSr15ve:
        return _DullHammer:100_
    BodRewardDatabase_SSr20ve:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SSr10va:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SSr15va:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SSr20va:
        return _ShadowHammer:100_

    BodRewardDatabase_SSe10ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSe15ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSe20ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SSe10du:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SSe15du:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SSe20du:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SSe10sh:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SSe15sh:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SSe20sh:
        return _DullHammer:100_
    BodRewardDatabase_SSe10co:
        return _DullHammer:100_
    BodRewardDatabase_SSe15co:
        return _DullHammer:100_
    BodRewardDatabase_SSe20co:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SSe10br:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SSe15br:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SSe20br:
        return _ShadowHammer:100_
    BodRewardDatabase_SSe10go:
        return _ShadowHammer:100_
    BodRewardDatabase_SSe15go:
        return _ColoredAnvil:10_Blacksmithy5:60_ShadowHammer:30_
    BodRewardDatabase_SSe20go:
        return _CopperHammer:100_
    BodRewardDatabase_SSe10ag:
        return _CopperHammer:100_
    BodRewardDatabase_SSe15ag:
        return _ColoredAnvil:10_Blacksmithy10:60_CopperHammer:30_
    BodRewardDatabase_SSe20ag:
        return _BronzeHammer:100_
    BodRewardDatabase_SSe10ve:
        return _BronzeHammer:100_
    BodRewardDatabase_SSe15ve:
        return _BronzeHammer:100_
    BodRewardDatabase_SSe20ve:
        return _AncientHammer10:100_
    BodRewardDatabase_SSe10va:
        return _AncientHammer10:100_
    BodRewardDatabase_SSe15va:
        return _AncientHammer10:100_
    BodRewardDatabase_SSe20va:
        return _Blacksmithy15:100_

    BodRewardDatabase_SRr10ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SRr15ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SRr20ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SRr10du:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SRr15du:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SRr20du:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SRr10sh:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SRr15sh:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SRr20sh:
        return _DullHammer:100_
    BodRewardDatabase_SRr10co:
        return _DullHammer:100_
    BodRewardDatabase_SRr15co:
        return _DullHammer:100_
    BodRewardDatabase_SRr20co:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SRr10br:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SRr15br:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SRr20br:
        return _ShadowHammer:100_
    BodRewardDatabase_SRr10go:
        return _ShadowHammer:100_
    BodRewardDatabase_SRr15go:
        return _ColoredAnvil:10_Blacksmithy5:60_ShadowHammer:30_
    BodRewardDatabase_SRr20go:
        return _CopperHammer:100_
    BodRewardDatabase_SRr10ag:
        return _CopperHammer:100_
    BodRewardDatabase_SRr15ag:
        return _ColoredAnvil:10_Blacksmithy10:60_CopperHammer:30_
    BodRewardDatabase_SRr20ag:
        return _BronzeHammer:100_
    BodRewardDatabase_SRr10ve:
        return _BronzeHammer:100_
    BodRewardDatabase_SRr15ve:
        return _BronzeHammer:100_
    BodRewardDatabase_SRr20ve:
        return _AncientHammer10:100_
    BodRewardDatabase_SRr10va:
        return _AncientHammer10:100_
    BodRewardDatabase_SRr15va:
        return _AncientHammer10:100_
    BodRewardDatabase_SRr20va:
        return _Blacksmithy15:100_

    BodRewardDatabase_SRe10ir:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SRe15ir:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SRe20ir:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SRe10du:
        return _ShadowHammer:100_
    BodRewardDatabase_SRe15du:
        return _ColoredAnvil:10_Blacksmithy5:60_ShadowHammer:30_
    BodRewardDatabase_SRe20du:
        return _CopperHammer:100_
    BodRewardDatabase_SRe10sh:
        return _CopperHammer:100_
    BodRewardDatabase_SRe15sh:
        return _ColoredAnvil:10_Blacksmithy10:60_CopperHammer:30_
    BodRewardDatabase_SRe20sh:
        return _BronzeHammer:100_
    BodRewardDatabase_SRe10co:
        return _BronzeHammer:100_
    BodRewardDatabase_SRe15co:
        return _BronzeHammer:100_
    BodRewardDatabase_SRe20co:
        return _AncientHammer10:100_
    BodRewardDatabase_SRe10br:
        return _AncientHammer10:100_
    BodRewardDatabase_SRe15br:
        return _AncientHammer10:100_
    BodRewardDatabase_SRe20br:
        return _Blacksmithy15:100_
    BodRewardDatabase_SRe10go:
        return _Blacksmithy15:100_
    BodRewardDatabase_SRe15go:
        return _Blacksmithy15:100_
    BodRewardDatabase_SRe20go:
        return _AncientHammer15:100_
    BodRewardDatabase_SRe10ag:
        return _AncientHammer15:100_
    BodRewardDatabase_SRe15ag:
        return _AncientHammer15:100_
    BodRewardDatabase_SRe20ag:
        return _Blacksmithy20:100_
    BodRewardDatabase_SRe10ve:
        return _Blacksmithy20:100_
    BodRewardDatabase_SRe15ve:
        return _Blacksmithy20:100_
    BodRewardDatabase_SRe20ve:
        return _GoldHammer:100_
    BodRewardDatabase_SRe10va:
        return _GoldHammer:100_
    BodRewardDatabase_SRe15va:
        return _GoldHammer:100_
    BodRewardDatabase_SRe20va:
        return _AncientHammer30:100_

    BodRewardDatabase_SCr10ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SCr15ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SCr20ir:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_SCr10du:
        return _DullHammer:100_
    BodRewardDatabase_SCr15du:
        return _DullHammer:100_
    BodRewardDatabase_SCr20du:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SCr10sh:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SCr15sh:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SCr20sh:
        return _ShadowHammer:100_
    BodRewardDatabase_SCr10co:
        return _ShadowHammer:100_
    BodRewardDatabase_SCr15co:
        return _ColoredAnvil:10_Blacksmithy5:60_ShadowHammer:30_
    BodRewardDatabase_SCr20co:
        return _CopperHammer:100_
    BodRewardDatabase_SCr10br:
        return _CopperHammer:100_
    BodRewardDatabase_SCr15br:
        return _ColoredAnvil:10_Blacksmithy10:60_CopperHammer:30_
    BodRewardDatabase_SCr20br:
        return _BronzeHammer:100_
    BodRewardDatabase_SCr10go:
        return _BronzeHammer:100_
    BodRewardDatabase_SCr15go:
        return _BronzeHammer:100_
    BodRewardDatabase_SCr20go:
        return _AncientHammer10:100_
    BodRewardDatabase_SCr10ag:
        return _AncientHammer10:100_
    BodRewardDatabase_SCr15ag:
        return _AncientHammer10:100_
    BodRewardDatabase_SCr20ag:
        return _Blacksmithy15:100_
    BodRewardDatabase_SCr10ve:
        return _Blacksmithy15:100_
    BodRewardDatabase_SCr15ve:
        return _Blacksmithy15:100_
    BodRewardDatabase_SCr20ve:
        return _AncientHammer15:100_
    BodRewardDatabase_SCr10va:
        return _AncientHammer15:100_
    BodRewardDatabase_SCr15va:
        return _AncientHammer15:100_
    BodRewardDatabase_SCr20va:
        return _Blacksmithy20:100_

    BodRewardDatabase_SCe10ir:
        return _DullHammer:100_
    BodRewardDatabase_SCe15ir:
        return _DullHammer:100_
    BodRewardDatabase_SCe20ir:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_SCe10du:
        return _BronzeHammer:100_
    BodRewardDatabase_SCe15du:
        return _BronzeHammer:100_
    BodRewardDatabase_SCe20du:
        return _AncientHammer10:100_
    BodRewardDatabase_SCe10sh:
        return _AncientHammer10:100_
    BodRewardDatabase_SCe15sh:
        return _AncientHammer10:100_
    BodRewardDatabase_SCe20sh:
        return _Blacksmithy15:100_
    BodRewardDatabase_SCe10co:
        return _Blacksmithy15:100_
    BodRewardDatabase_SCe15co:
        return _Blacksmithy15:100_
    BodRewardDatabase_SCe20co:
        return _AncientHammer15:100_
    BodRewardDatabase_SCe10br:
        return _AncientHammer15:100_
    BodRewardDatabase_SCe15br:
        return _AncientHammer15:100_
    BodRewardDatabase_SCe20br:
        return _Blacksmithy20:100_
    BodRewardDatabase_SCe10go:
        return _Blacksmithy20:100_
    BodRewardDatabase_SCe15go:
        return _Blacksmithy20:100_
    BodRewardDatabase_SCe20go:
        return _GoldHammer:100_
    BodRewardDatabase_SCe10ag:
        return _GoldHammer:100_
    BodRewardDatabase_SCe15ag:
        return _GoldHammer:100_
    BodRewardDatabase_SCe20ag:
        return _AncientHammer30:100_
    BodRewardDatabase_SCe10ve:
        return _AncientHammer30:100_
    BodRewardDatabase_SCe15ve:
        return _AncientHammer30:100_
    BodRewardDatabase_SCe20ve:
        return _AgapiteHammer:100_
    BodRewardDatabase_SCe10va:
        return _AgapiteHammer:100_
    BodRewardDatabase_SCe15va:
        return _AgapiteHammer:100_
    BodRewardDatabase_SCe20va:
        return _AncientHammer60:100_

    BodRewardDatabase_SPr10ir:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SPr15ir:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_SPr20ir:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_SPr10du:
        return _ShadowHammer:100_
    BodRewardDatabase_SPr15du:
        return _ColoredAnvil:10_Blacksmithy5:60_ShadowHammer:30_
    BodRewardDatabase_SPr20du:
        return _CopperHammer:100_
    BodRewardDatabase_SPr10sh:
        return _CopperHammer:100_
    BodRewardDatabase_SPr15sh:
        return _ColoredAnvil:10_Blacksmithy10:60_CopperHammer:30_
    BodRewardDatabase_SPr20sh:
        return _BronzeHammer:100_
    BodRewardDatabase_SPr10co:
        return _BronzeHammer:100_
    BodRewardDatabase_SPr15co:
        return _BronzeHammer:100_
    BodRewardDatabase_SPr20co:
        return _AncientHammer10:100_
    BodRewardDatabase_SPr10br:
        return _AncientHammer10:100_
    BodRewardDatabase_SPr15br:
        return _AncientHammer10:100_
    BodRewardDatabase_SPr20br:
        return _Blacksmithy15:100_
    BodRewardDatabase_SPr10go:
        return _Blacksmithy15:100_
    BodRewardDatabase_SPr15go:
        return _Blacksmithy15:100_
    BodRewardDatabase_SPr20go:
        return _AncientHammer15:100_
    BodRewardDatabase_SPr10ag:
        return _AncientHammer15:100_
    BodRewardDatabase_SPr15ag:
        return _AncientHammer15:100_
    BodRewardDatabase_SPr20ag:
        return _Blacksmithy20:100_
    BodRewardDatabase_SPr10ve:
        return _Blacksmithy20:100_
    BodRewardDatabase_SPr15ve:
        return _Blacksmithy20:100_
    BodRewardDatabase_SPr20ve:
        return _GoldHammer:100_
    BodRewardDatabase_SPr10va:
        return _GoldHammer:100_
    BodRewardDatabase_SPr15va:
        return _GoldHammer:100_
    BodRewardDatabase_SPr20va:
        return _AncientHammer30:100_

    BodRewardDatabase_SPe10ir:
        return _ShadowHammer:100_
    BodRewardDatabase_SPe15ir:
        return _ColoredAnvil:10_Blacksmithy5:60_ShadowHammer:30_
    BodRewardDatabase_SPe20ir:
        return _CopperHammer:100_
    BodRewardDatabase_SPe10du:
        return _Blacksmithy15:100_
    BodRewardDatabase_SPe15du:
        return _Blacksmithy15:100_
    BodRewardDatabase_SPe20du:
        return _AncientHammer15:100_
    BodRewardDatabase_SPe10sh:
        return _AncientHammer15:100_
    BodRewardDatabase_SPe15sh:
        return _AncientHammer15:100_
    BodRewardDatabase_SPe20sh:
        return _Blacksmithy20:100_
    BodRewardDatabase_SPe10co:
        return _Blacksmithy20:100_
    BodRewardDatabase_SPe15co:
        return _Blacksmithy20:100_
    BodRewardDatabase_SPe20co:
        return _GoldHammer:100_
    BodRewardDatabase_SPe10br:
        return _GoldHammer:100_
    BodRewardDatabase_SPe15br:
        return _GoldHammer:100_
    BodRewardDatabase_SPe20br:
        return _AncientHammer30:100_
    BodRewardDatabase_SPe10go:
        return _AncientHammer30:100_
    BodRewardDatabase_SPe15go:
        return _AncientHammer30:100_
    BodRewardDatabase_SPe20go:
        return _AgapiteHammer:100_
    BodRewardDatabase_SPe10ag:
        return _AgapiteHammer:100_
    BodRewardDatabase_SPe15ag:
        return _AgapiteHammer:100_
    BodRewardDatabase_SPe20ag:
        return _AncientHammer60:100_
    BodRewardDatabase_SPe10ve:
        return _AncientHammer60:100_
    BodRewardDatabase_SPe15ve:
        return _AncientHammer60:100_
    BodRewardDatabase_SPe20ve:
        return _VeriteHammer:100_
    BodRewardDatabase_SPe10va:
        return _VeriteHammer:100_
    BodRewardDatabase_SPe15va:
        return _VeriteHammer:100_
    BodRewardDatabase_SPe20va:
        return _ValoriteHammer:100_

    BodRewardDatabase_S2r10sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S2r15sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S2r20sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S5r10sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S5r15sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S5r20sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S6r10sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S6r15sm:
        return _MiningGloves3:10_GargoylesPickaxe:45_ProspectorsTools:45_
    BodRewardDatabase_S6r20sm:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_S2e10sm:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_S2e15sm:
        return _GargoylesPickaxe:40_ProspectorsTools:40_POF:20_
    BodRewardDatabase_S2e20sm:
        return _MiningGloves5:10_POF:90_
    BodRewardDatabase_S5e10sm:
        return _DullHammer:100_
    BodRewardDatabase_S5e15sm:
        return _DullHammer:100_
    BodRewardDatabase_S5e20sm:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_S6e10sm:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_S6e15sm:
        return _DullHammer:60_ShadowHammer:40_
    BodRewardDatabase_S6e20sm:
        return _ShadowHammer:100_

    BodRewardDatabase_T4r10cl:
        return _MediumStretchedHide:50_LargeStretchedHide:50_
    BodRewardDatabase_T4r15cl:
        return _MediumStretchedHide:50_LargeStretchedHide:50_
    BodRewardDatabase_T4r20cl:
        return _SpinedKit:100_
    BodRewardDatabase_T4r10le:
        return _MediumStretchedHide:50_LargeStretchedHide:50_
    BodRewardDatabase_T4r15le:
        return _MediumStretchedHide:50_LargeStretchedHide:50_
    BodRewardDatabase_T4r20le:
        return _SpinedKit:100_
    BodRewardDatabase_T4r10sp:
        return _SpinedKit:100_
    BodRewardDatabase_T4r15sp:
        return _SpinedKit:100_
    BodRewardDatabase_T4r20sp:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4r10ho:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4r15ho:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4r20ho:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4r10ba:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4r15ba:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4r20ba:
        return _Tailoring10:100_
    BodRewardDatabase_T4e10cl:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4e15cl:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4e20cl:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4e10le:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4e15le:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T4e20le:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4e10sp:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4e15sp:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T4e20sp:
        return _Tailoring10:100_
    BodRewardDatabase_T4e10ho:
        return _Tailoring10:100_
    BodRewardDatabase_T4e15ho:
        return _Tailoring10:100_
    BodRewardDatabase_T4e20ho:
        return _BlessDeed:100_
    BodRewardDatabase_T4e10ba:
        return _BlessDeed:100_
    BodRewardDatabase_T4e15ba:
        return _Tailoring15:100_
    BodRewardDatabase_T4e20ba:
        return _HornedKit:100_

    BodRewardDatabase_T5r10cl:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T5r15cl:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T5r20cl:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T5r10le:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T5r15le:
        return _Tailoring5:40_LightTapestry:30_DarkTapestry:30_
    BodRewardDatabase_T5r20le:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T5r10sp:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T5r15sp:
        return _BrownBearRug:50_PolarBearRug:50_
    BodRewardDatabase_T5r20sp:
        return _Tailoring10:100_
    BodRewardDatabase_T5r10ho:
        return _Tailoring10:100_
    BodRewardDatabase_T5r15ho:
        return _Tailoring10:100_
    BodRewardDatabase_T5r20ho:
        return _BlessDeed:100_
    BodRewardDatabase_T5r10ba:
        return _BlessDeed:100_
    BodRewardDatabase_T5r15ba:
        return _Tailoring15:100_
    BodRewardDatabase_T5r20ba:
        return _HornedKit:100_
    BodRewardDatabase_T5e10cl:
        return _Tailoring10:100_
    BodRewardDatabase_T5e15cl:
        return _Tailoring10:100_
    BodRewardDatabase_T5e20cl:
        return _BlessDeed:100_
    BodRewardDatabase_T5e10le:
        return _Tailoring10:100_
    BodRewardDatabase_T5e15le:
        return _Tailoring10:100_
    BodRewardDatabase_T5e20le:
        return _BlessDeed:100_
    BodRewardDatabase_T5e10sp:
        return _BlessDeed:100_
    BodRewardDatabase_T5e15sp:
        return _Tailoring15:100_
    BodRewardDatabase_T5e20sp:
        return _HornedKit:100_
    BodRewardDatabase_T5e10ho:
        return _HornedKit:100_
    BodRewardDatabase_T5e15ho:
        return _HornedKit:100_
    BodRewardDatabase_T5e20ho:
        return _Tailoring20:100_
    BodRewardDatabase_T5e10ba:
        return _Tailoring20:100_
    BodRewardDatabase_T5e15ba:
        return _Tailoring20:100_
    BodRewardDatabase_T5e20ba:
        return _BarbedKit:100_

    BodRewardDatabase_T6r10le:
        return _Tailoring10:100_
    BodRewardDatabase_T6r15le:
        return _Tailoring10:100_
    BodRewardDatabase_T6r20le:
        return _BlessDeed:100_
    BodRewardDatabase_T6r10sp:
        return _BlessDeed:100_
    BodRewardDatabase_T6r15sp:
        return _Tailoring15:100_
    BodRewardDatabase_T6r20sp:
        return _HornedKit:100_
    BodRewardDatabase_T6r10ho:
        return _HornedKit:100_
    BodRewardDatabase_T6r15ho:
        return _HornedKit:100_
    BodRewardDatabase_T6r20ho:
        return _Tailoring20:100_
    BodRewardDatabase_T6r10ba:
        return _Tailoring20:100_
    BodRewardDatabase_T6r15ba:
        return _Tailoring20:100_
    BodRewardDatabase_T6r20ba:
        return _BarbedKit:100_
    BodRewardDatabase_T6e10le:
        return _HornedKit:100_
    BodRewardDatabase_T6e15le:
        return _HornedKit:100_
    BodRewardDatabase_T6e20le:
        return _Tailoring20:100_
    BodRewardDatabase_T6e10sp:
        return _Tailoring20:100_
    BodRewardDatabase_T6e15sp:
        return _Tailoring20:100_
    BodRewardDatabase_T6e20sp:
        return _BarbedKit:100_
    BodRewardDatabase_T6e10ho:
        return _BarbedKit:100_
    BodRewardDatabase_T6e15ho:
        return _BarbedKit:100_
    BodRewardDatabase_T6e20ho:
        return _BarbedKit:100_
    BodRewardDatabase_T6e10ba:
        return _BarbedKit:100_
    BodRewardDatabase_T6e15ba:
        return _BarbedKit:100_
    BodRewardDatabase_T6e20ba:
        return _BarbedKit:100_
return !null

;===========================================================================
;**
;* @name analyzeBod
;* @ver 1.0
;* @author AG
;* @purpose Analizza un BOD e riempie una serie di variabili con lo stesso prefisso.
;*            L'effetto è simile al riempimento di una STRUCT!
;*            Sistema molto primordiale per programmare AD OGGETTI!
;*            La struct è organizzata come segue:
;*
;* struct BOD_DATA
;* {
;*     ; Dati oggetto (flag 'o')
;*     Id              ; memorizza l'id del BOD analizzato
;*     Property        ; memorizza la #property del BOD analizzato
;*     Color           ; memorizza il #findcol del BOD analizzato
;*
;*     ; Informazioni di base (flag: 'b')
;*     Tailor          ; #true se il BOD è di tailoring, #false se è di blacksmith
;*     Large           ; #true se il BOD è large, #false se è small
;*     Exceptional     ; #true se il BOD è exceptional, #false se è normal
;*
;*     ; Materiale (flag: 'm')
;*     MaterialName    ; nome del materiale richiesto per il BOD (oppure "cloth" in caso di stoffa)
;*     MaterialId      ; id del tipo di materiale richiesto per il BOD
;*     MaterialColor   ; codice di colore del materiale richiesto per il BOD
;*
;*     ; Quantità (flag: 'q')
;*     Quantity        ; quantità TOTALE di items necessari per fillare il BOD
;*     Cardinality     ; 1 se il BOD è small; 4, 5 o 6 se il BOD è large, a seconda di quanti small BODs richiede
;*     FillCount       ; quantità di item (o di small BODs) GIA' INSERITI nel BOD
;*     Filled          ; indica se il BOD è completo
;*
;*     ; Crafting (flag: 'c')
;*     CraftButton1    ; indice del pulsante rappresentante la "categoria" del BOD nel menu di crafting
;*     CraftButton2    ; indice del pulsante rappresentante il pezzo da craftare all'interno della categoria
;*     Cloth           ; quantità di cloth necessaria per craftare UN SOLO pezzo
;*     Leather         ; quantità di leather necessaria per craftare UN SOLO pezzo
;*     Hides           ; sinonimo di "Leather" (backward compatibility)
;*     Bones           ; quantità di bones necessarie per craftare UN SOLO pezzo
;*     Ingots          ; quantità di ingots necessari per craftare UN SOLO pezzo
;*     ItemId          ; identificatore del tipo di oggetto da craftare per fillare il BOD (solo se small)
;*     ItemName        ; nome (human readable) del tipo di oggetto da craftare per fillare il BOD (solo se small)
;*
;*     ; BODset (flag 's')
;*     SetId           ; identificatore univoco del BODset cui appartiene questo BOD
;*     SetName         ; nome del BODset cui appartiene questo BOD
;*     LinkedSets      ; lista dei BODsets collegati a questo BOD (small->large o large->small)
;*
;*     ; Premi (flag 'r')
;*     SmallRewards    ; lista dei premi che si possono ottenere consegnando questo small bod
;*     LargeRewards    ; lista dei premi che si possono ottenere consegnando questo large bod (o i large bods a cui questo small bod è collegato)
;* }
;*
;* @params %1 req      Bod identifier
;*         %2 req      Name of the struct where to store results
;*         %3 opt      Analysis flags
;*
;* @returns #true if no error occurs, or an error code otherwise
;* @example call BodFunctions.euo analyzeBod %bod mybod e
;* @status under development

sub analyzeBod ; %bodId %structName %flags
    namespace push
    namespace local analyzeBod , #random , #systime
    set !lpc #lpc
    set #lpc 500
    set !bod %1
    set !structName %2
    if %0 < 3 || %3 = !null
       set !flags abcdefghijklmnopqrstuvwxyz
    else
       set !flags %3

    ; get bod color
    ignoreitem reset
    finditem !bod C ; search all opened containers
    if #findkind = -1
    {
       finditem !bod G ; search nearby on the ground
       if #findkind = -1
       {
          event exmsg #charid 3 0 analyzeBod: cannot find indicated BOD.
          set #result err_cannot_find_bod
          goto analyzeBod_return
       }
    }
    if #findtype <> EYM
    {
       event exmsg #charid 3 0 analyzeBod: this object is not a BOD!
       set #result err_invalid_type
       goto analyzeBod_return
    }
    set !color #findcol

    ; safe readProperty
    set !timeout ( #systime + 1000 )
    set #property 0
    event property !bod
    while #systime < !timeout && #property = 0
    {
    }
    if Bulk notin #property || Amount notin #property
    {
        event exmsg #charid 3 0 analyzeBod: cannot read property for indicated BOD.
        set #result err_cannot_read_property
        goto analyzeBod_return
    }
    set !property #property

    gosub analyzeBod_Explicit !bod !color !property !structName !flags

analyzeBod_return:
    set #lpc !lpc
    namespace clear
    namespace pop
return #result

sub analyzeBod_Explicit ; %bodId %bodColor %bodProperty %structName %flags
    namespace push
    namespace local analyzeBod_Explicit , #random , #systime
    set !lpc #lpc
    set #lpc 500
    set !bod %1
    set !color %2
    set !property %3
    set !struct %4
    if %0 < 5 || %5 = !null
       set !flags abcdefghijklmnopqrstuvwxyz
    else
       set !flags %5

    ; Dati indispensabili: calcolati in ogni caso (eventualmente non memorizzati in struttura)
    gosub BodIsTailor !color
    set !isTailor #result
    gosub BodIsLarge !property
    set !isLarge #result
    gosub BodIsExceptional !property
    set !isExceptional #result

    if o in !flags ; Dati oggetto
    {
        gosub setStructField !struct Id !bod
        gosub setStructField !struct Color !color
        gosub setStructField !struct Property !property
    }
    if b in !flags ; Dati di base
    {
        gosub setStructField !struct Tailor !isTailor
        gosub setStructField !struct Large !isLarge
        gosub setStructField !struct Exceptional !isExceptional
    }
    if q in !flags ; Dati sulle quantità
    {
        gosub GetBodQuantity !property
        set !quantity #result
        gosub setStructField !struct Quantity #result

        gosub GetLargeBodQuantity !property
        set !cardinality #result
        gosub setStructField !struct Cardinality #result

        if !isLarge
            gosub GetLargeBodAlreadyMadeQuantity !property
        else
            gosub GetBodAlreadyMadeQuantity !property
        set !fillCount #result
        gosub setStructField !struct FillCount !fillCount

        if !isLarge
           set !filled ( !fillCount = !cardinality )
        else
           set !filled ( !fillCount = !quantity )
        gosub setStructField !struct Filled !filled
    }
    if m in !flags ; Dati sul materiale
    {
        gosub GetBodMaterial !color !property analyzeBod_material
        set !materialColor %analyzeBod_material
        gosub GetMaterialName !materialColor !isTailor
        set !materialName #result

        if !isTailor
           set !materialId JJG
        else
           set !materialId ENK
           
        if !materialColor = cloth
        {
           set !materialColor 0
           set !materialId BUI
        }
        gosub setStructField !struct MaterialName !materialName
        gosub setStructField !struct MaterialId !materialId
        gosub setStructField !struct MaterialColor !materialColor
    }
    if c in !flags ; Crafting informations
    {
        if !isLarge
        {
            gosub setStructField !struct CraftButton1 0
            gosub setStructField !struct CraftButton2 0
            gosub setStructField !struct Cloth 0
            gosub setStructField !struct Leather 0
            gosub setStructField !struct Hides 0
            gosub setStructField !struct Bones 0
            gosub setStructField !struct Ingots 0
            gosub setStructField !struct ItemId !null
            gosub setStructField !struct ItemName !null
        }
        else
        {
            set %analyzeBod_ingots 0
            set %analyzeBod_cloth 0
            set %analyzeBod_hides 0
            set %analyzeBod_bones 0
            set %analyzeBod_category 0
            set %analyzeBod_piece 0
            if !isTailor
               gosub GetTailorBodParameters !property analyzeBod_category analyzeBod_piece analyzeBod_cloth analyzeBod_hides analyzeBod_bones analyzeBod_type
            else
               gosub GetSmithyBodParameters !property analyzeBod_category analyzeBod_piece analyzeBod_ingots analyzeBod_type

            gosub setStructField !struct CraftButton1 %analyzeBod_category
            gosub setStructField !struct CraftButton2 %analyzeBod_piece
            gosub setStructField !struct Cloth %analyzeBod_cloth
            gosub setStructField !struct Hides %analyzeBod_hides
            gosub setStructField !struct Leather %analyzeBod_hides
            gosub setStructField !struct Bones %analyzeBod_bones
            gosub setStructField !struct Ingots %analyzeBod_ingots
            gosub setStructField !struct ItemId %analyzeBod_type
            set !itemId %analyzeBod_type

            gosub GetSmallBodItemName !property
            gosub setStructField !struct ItemName #result
        }
    }
    if s in !flags || r in !flags ; BODset informations (compute also if r flag is present; write only if s flag is present)
    {
        if !isLarge
        {
            gosub GetLargeBodItemSet !property
            set !setId #result
            set !setName #result

            gosub GetLargeBodLinkedItems !setId
            set !linkedSets #result
        }
        else
        {
            if !itemId = !null
            {
                if !isTailor
                   gosub GetTailorBodParameters !property analyzeBod_null analyzeBod_null analyzeBod_null analyzeBod_null analyzeBod_null analyzeBod_type
                else
                   gosub GetSmithyBodParameters !property analyzeBod_null analyzeBod_null analyzeBod_null analyzeBod_type
                set !itemId %analyzeBod_type
            }
            set !setId !itemId
            
            gosub GetSmallBodItemName !property
            set !setName #result

            gosub GetSmallBodLinkedItems !itemId
            set !linkedSets #result
        }
        if s in !flags
        {
            gosub setStructField !struct SetId !setId
            gosub setStructField !struct SetName !setName
            gosub setStructField !struct LinkedSets !linkedSets
        }
    }
    if r in !flags ; Reward informations
    {
        if !materialName = !null
        {
            gosub GetBodMaterial !color !property analyzeBod_material
            gosub GetMaterialName %analyzeBod_material !isTailor
            set !materialName #result
        }
        if !quantity = !null
        {
            gosub GetBodQuantity !property
            set !quantity #result
        }
        if !isLarge
        {
            gosub GetBodReward !setName !materialName !quantity !isExceptional
            gosub setStructField !struct LargeRewards #result
        }
        else
        {
            if !isTailor
               gosub GetBodReward TailorSmall !materialName !quantity !isExceptional
            else
               gosub GetBodReward SmithSmall !materialName !quantity !isExceptional
            gosub setStructField !struct SmallRewards #result
            
            gosub AG_Tokenize !linkedSets _ AnalyzeBod_Temp_
            set !linkedRewards _
            if #result > 0
            {
                for !i 1 #result
                {
                    set !set %AnalyzeBod_Temp_ . !i
                    gosub GetBodReward !set !materialName !quantity !isExceptional
                    set !linkedRewards !linkedRewards , #result , _
                }
            }
            gosub setStructField !struct LargeRewards !linkedRewards
        }
    }

analyzeBod_skipExtended:
    set #result #true
analyzeBodEx_return:
    set #lpc !lpc
    namespace clear
    namespace pop
return #result

; INTERNAL USE ONLY!
sub setStructField ; %structName %structField %fieldValue
    set !structAndField %1 , %2
    set % . !structAndField %3
return

; INTERNAL USE ONLY!
sub getStructField ; %structName %structField %fieldValue
    set !structAndField %1 , %2
    set #result % . !structAndField
return #result

;===========================================================================
;* @name     showBodPanel
;* @author   AG
;* @purpose  Displays an informative dialog about the specified bod.
;*           Field names into the dialog box are the same as BOD structure field names.
;* @params   %1 req  Bod identifier
;*
;* @example call BodFunctions.euo showBodPanel
;* @status Tested

sub showBodPanel
    namespace push
    namespace local showBodPanel , #systime , #random
    set !bod %1

    gosub analyzeBod !bod showBodPanel_
    if #result <> #true
    {
       event exmsg #charid 3 0 Errore nel parsing del BOD!
       goto showBodPanel_return
    }

    ;---------------------
    ; Costruzione Menu
    ;---------------------

  	menu Clear
  	menu Window Title BOD Information Panel
  	menu Window Color Black
  	menu Window Size 547 420
  	menu Font Transparent #true
  	menu Font Align Right
  	menu Shape EUOShape5 376 16 165 145 3 7 2 Lime 7 Black
  	menu Shape EUOShape4 204 176 165 81 3 7 2 Lime 7 Black
  	menu Shape EUOShape3 204 96 165 65 3 7 2 Lime 7 Black
  	menu Shape EUOShape1 8 16 189 241 3 7 2 Lime 7 Black
  	menu Shape EUOShape6 8 52 189 1 3 7 1 Lime 7 White
  	menu Shape EUOShape2 204 16 165 65 3 7 2 Lime 7 Black
  	menu Font Name MS Sans Serif
  	menu Font Size 8
  	menu Font Style
  	menu Font Color Lime
  	menu Font Align Left
  	menu Font BGColor Black
  	menu Text EUOLabel1 16 28 ID:
  	menu Font Transparent #false
  	menu Text EUOLabel90 16 44 Property:
  	menu Font Transparent #true
  	menu Text EUOLabel3 100 28 Color:
  	menu Text EUOLabel4 212 28 Tailor
  	menu Text EUOLabel5 212 60 Exceptional
  	menu Text EUOLabel6 212 44 Large
  	menu Text EUOLabel7 212 108 MaterialID
  	menu Text EUOLabel8 212 188 Quantity
  	menu Text EUOLabel9 212 204 Cardinality
  	menu Text EUOLabel10 212 220 FillCount
  	menu Text EUOLabel11 212 236 Filled
  	menu Text EUOLabel12 384 28 CraftButton1
  	menu Text EUOLabel13 384 44 CraftButton2
  	menu Text EUOLabel14 384 60 Cloth
  	menu Text EUOLabel15 384 76 Leather
  	menu Text EUOLabel16 384 92 Bones
  	menu Text EUOLabel17 384 108 Ingots
  	menu Text EUOLabel18 384 124 ItemID
  	menu Text EUOLabel19 384 140 ItemName
  	menu Font Style b
  	menu Text ID 32 28 ID
  	menu Text Color 128 28 Color
  	menu Text Tailor 284 28 Tailor
  	menu Text Large 284 44 Large
  	menu Text Exceptional 284 60 Exceptional
  	menu Text MaterialID 284 108 MaterialID
  	menu Text Cardinality 284 204 Cardinality
  	menu Text FillCount 284 220 FillCount
  	menu Text Filled 284 236 Filled
  	menu Text CraftButton1 456 28 CraftButton1
  	menu Text CraftButton2 456 44 CraftButton2
  	menu Text Quantity 284 188 Quantity
  	menu Text Cloth 456 60 Cloth
  	menu Text Leather 456 76 Leather
  	menu Text Bones 456 92 Bones
  	menu Text Ingots 456 108 Ingots
  	menu Text ItemID 456 124 ItemID
  	menu Text ItemName 456 140 ItemName
  	menu Font Color White
  	menu Font Align Center
  	menu Text Property2 16 76 Property2
  	menu Text Property3 16 92 Property3
  	menu Text Property4 16 108 Property4
  	menu Text Property5 16 124 Property5
  	menu Text Property6 16 140 Property6
  	menu Text Property7 16 156 Property7
  	menu Text Property8 16 172 Property8
  	menu Text Property9 16 188 Property9
  	menu Text Property10 16 204 Property10
  	menu Text Property11 16 220 Property11
  	menu Font Style
  	menu Font Color Lime
  	menu Font Transparent #false
  	menu Font Align Left
  	menu Text EUOLabel2 12 9 Object (flag = O)
  	menu Font Style b
  	menu Font Color Yellow
  	menu Font Transparent #true
  	menu Font Align Center
  	menu Text Property1 16 60 Property1
  	menu Font Color White
  	menu Font Align Left
  	menu Text Property12 16 236 Property12
  	menu Font Style
  	menu Font Color Lime
  	menu Text EUOLabel21 212 124 MaterialColor
  	menu Font Style b
  	menu Text MaterialColor 284 124 MaterialColor
  	menu Font Style
  	menu Text EUOLabel25 212 140 MaterialName
  	menu Font Style b
  	menu Text MaterialName 284 140 MaterialName
  	menu Font Style
  	menu Font Transparent #false
  	menu Text EUOLabel27 208 9 Basic (flag = B)
  	menu Text EUOLabel28 208 89 Material (flag = M)
  	menu Text EUOLabel29 208 169 Quantity (flag = Q)
  	menu Text EUOLabel30 380 9 Crafting (flag = C)
  	menu Shape EUOShape7 8 352 533 65 3 7 2 Lime 7 Black
  	menu Font Transparent #true
  	menu Text EUOLabel20 16 364 RewardCodes
  	menu Font Style b
  	menu Text RewardCodes 92 364 RewardCodes
  	menu Font Style
  	menu Text EUOLabel23 16 380 SmallRewards
  	menu Font Style b
  	menu Text SmallRewards 92 380 SmallRewards
  	menu Font Style
  	menu Text EUOLabel26 16 396 LargeRewards
  	menu Font Style b
  	menu Text LargeRewards 92 396 LargeRewards
  	menu Font Style
  	menu Font Transparent #false
  	menu Text EUOLabel32 12 345 Rewards (flag = R)
  	menu Shape EUOShape8 8 272 533 65 3 7 2 Lime 7 Black
  	menu Font Transparent #true
  	menu Text EUOLabel22 16 284 SetID
  	menu Font Style b
  	menu Text SetID 92 284 SetID
  	menu Font Style
  	menu Text EUOLabel31 16 300 SetName
  	menu Font Style b
  	menu Text SetName 92 300 SetName
  	menu Font Style
  	menu Text EUOLabel34 16 316 LinkedSets
  	menu Font Style b
  	menu Text LinkedSets 92 316 LinkedSets
  	menu Font Style
  	menu Font Transparent #false
  	menu Text EUOLabel36 12 265 BOD Set (flag = S)

  	;------------------------
  	; Assegnazione variabili
  	;------------------------

  	menu set ID %showBodPanel_ID
  	menu set Color %showBodPanel_Color

  	if %showBodPanel_Tailor
  	   menu set Tailor true
    else
  	   menu set Tailor false

  	if %showBodPanel_Exceptional
  	   menu set Exceptional true
    else
  	   menu set Exceptional false

  	if %showBodPanel_Large
  	   menu set Large true
    else
  	   menu set Large false

  	if %showBodPanel_Filled
  	   menu set Filled true
    else
  	   menu set Filled false

  	menu set MaterialID %showBodPanel_MaterialID
  	menu set MaterialName %showBodPanel_MaterialName
  	menu set MaterialColor %showBodPanel_MaterialColor
  	menu set Quantity %showBodPanel_Quantity
  	menu set Cardinality %showBodPanel_Cardinality
  	menu set FillCount %showBodPanel_FillCount
  	menu set CraftButton1 %showBodPanel_CraftButton1
  	menu set CraftButton2 %showBodPanel_CraftButton2
  	menu set Cloth %showBodPanel_Cloth
  	menu set Leather %showBodPanel_Leather
  	menu set Bones %showBodPanel_Bones
  	menu set Ingots %showBodPanel_Ingots
  	menu set ItemID %showBodPanel_ItemID
  	menu set ItemName %showBodPanel_ItemName
  	menu set SetId %showBodPanel_SetID
  	menu set SetName %showBodPanel_SetName
  	menu set LinkedSets %showBodPanel_LinkedSets
  	menu set RewardCodes %showBodPanel_RewardCodes
  	menu set SmallRewards %showBodPanel_SmallRewards
  	menu set LargeRewards %showBodPanel_LargeRewards

  	set !property %showBodPanel_Property
  	for !i 1 12
  	{
        str pos !property $
        set !length #strres - 1
        str left !property !length
        set !line #strres
        if !line = !null
           set !line #spc
        menu set Property , !i !line
        set !length !length + 1
        str del !property 1 !length
        set !property #strres
  	}

  	menu Show

showBodPanel_return:
    namespace clear
    namespace pop
return

;===========================================================================
;* @name     setBodbookFilter
;* @version  2.0
;* @author   AG
;* @purpose  Imposta il filtro del bodbook specificato.
;*           La versione 2.0 è molto più veloce e anche molto più affidabile della versione 1.0.
;*           L'ordine dei parametri è stato cambiato, per rispecchiare la disposizione nel gump.
;*           E' stato inoltre aggiunto il parametro "bodbook" (%1), che apre il bodbook specificato.
;*
;* @params   %1 opt  Identificatore del bodbook per l quale settare il filtro.
;*                   Se questo campo è last oppure N/A, la sub assumerà che il gump del bodbook sia già aperto.
;*           %2 opt  Filtro per dimensione. Può essere: all, small, large, last, N/A.
;*                   Se questo campo è last oppure N/A, nessun pulsante di questa categoria sarà premuto.
;*           %3 opt  Filtro per qualità. Può essere: all, normal, exceptional, last, N/A.
;*                   Se questo campo è last oppure N/A, nessun pulsante di questa categoria sarà premuto.
;*           %4 opt  Filtro per materiale. Può essere:
;*                       all, clear, last, N/A,
;*                       smithy|blacksmithy, iron, dull, shadow, copper, bronze, gold|golden, agapite, verite, valorite,
;*                       tailor|tailoring, cloth, leather, spined, horned, barbed
;*                   Se questo campo è clear oppure all, il filtro sarà resettato (includendo, quindi, sia blacksmith che tailoring).
;*                   Se questo campo è last oppure N/A, nessun pulsante di questa categoria sarà premuto.
;*                   NB: "clear" e "all" possono influenzare gli altri parametri della sub, se questi hanno valore last oppure N/A.
;*           %5 opt  Filtro per ammontare. Può essere: all, 10, 15, 20.
;*                   Se questo campo è last oppure N/A, nessun pulsante di questa categoria sarà premuto.
;*
;* @returns  #true se l'operazione è andata completamente a buon fine. #false se si sono verificati errori.
;* @example  call safecall BodFunctions.euo setBodbookFilter %bodbook %size &quality %material %amount
;*           call safecall BodFunctions.euo setBodbookFilter %bodbook small exceptional iron 20
;* @status   Tested and working.
;* @note     Uses safecall convention!!!!

sub setBodbookFilter ; %bodbook %size &quality %material %amount
    set !bodbook %1
    set !size %2
    set !quality %3
    set !material %4
    set !quantity %5

    ; apertura del bodbook
    if !bodbook <> !null
    {
        ; assicurati che il gump sia chiuso!
        if #contsize = 615_454
        {
            set !timeout #systime + 2000
            while #systime < !timeout ; clicca con il destro a ripetizione ogni volta che il gump è aperto
            {
                if #contsize = 615_454
                {
                    set !x #contposx + 50
                    set !y #contposy + 50
                    click !x !y r
                }
            }
        }
        
        ; usa bodbook
    	  set #lobjectid !bodbook
        event macro 17 ; LastObject

        ; attendi comparsa del gump
        set !timeout #systime + 2000
        while #systime < !timeout && #contsize <> 615_454
        {
        }
        if #contsize <> 615_454 ; secondo tentativo
        {
            ; usa bodbook
        	  set #lobjectid !bodbook
            event macro 17 ; LastObject
            
            ; attendi comparsa del gump
            set !timeout #systime + 2000
            while #systime < !timeout && #contsize <> 615_454
            {
            }
        }
    }
    if #contsize <> 615_454
       return #false

    ; Premi "Set Filter"
    gosub setBodbookFilter_pushButton 45 40
    if #result = #false
       return #false

    ; filtro materiale
    gosub setBodbookFilter_getButtonPosition !material
    set !buttonPos #result
    str pos !buttonPos _
    set !sepIndex #strres
    str del !buttonPos 1 !sepIndex
    set !y #strres
    set !sepIndex !sepIndex - 1
    str left !buttonPos !sepIndex
    set !x #strres
    if !x <> 0 && !y <> 0
    {
       gosub setBodbookFilter_pushButton !x !y
       if #result = #false
           return #false
    }

    ; filtro dimensione
    set !y 105
    set !x 0
    if !size = all
       set !x 35
    if !size = small
       set !x 110
    if !size = large
       set !x 205
    if !size = all && !material in all_clear ; ottimizzazione in caso di clear
       set !x 0
    if !x <> 0
    {
       gosub setBodbookFilter_pushButton !x !y
       if #result = #false
           return #false
    }

    ; filtro qualità
    set !y 105
    set !x 0
    if !quality = all
       set !x 330
    if !quality = normal
       set !x 405
    if !quality = exceptional
       set !x 500
    if !quality = all && !material in all_clear ; ottimizzazione in caso di clear
       set !x 0
    if !x <> 0
    {
       gosub setBodbookFilter_pushButton !x !y
       if #result = #false
           return #false
    }

    ; filtro quantità
    set !y 360
    set !x 0
    if !quantity = all
       set !x 35
    if !quantity = 10
       set !x 110
    if !quantity = 15
       set !x 215
    if !quantity = 20
       set !x 310
    if !quantity = all && !material in all_clear ; ottimizzazione in caso di clear
       set !x 0
    if !x <> 0
    {
       gosub setBodbookFilter_pushButton !x !y
       if #result = #false
           return #false
    }

    ; Premi "Apply"
    gosub setBodbookFilter_pushButton 515 425
    if #result = #false
        return #false

    ; Premi "Exit" (oppure lascia il gump aperto se lo era già)
    if !bodbook <> !null
        gosub setBodbookFilter_pushButton 385 425
return #true

sub setBodbookFilter_pushButton ; %x %y
    ; attendi comparsa del gump
    set !timeout #systime + 2000
    while #systime < !timeout && #contsize <> 615_454
    {
    }
    if #contsize <> 615_454
       return #false

    set !x #contposx + %1
    set !y #contposy + %2
    click !x !y

    ; attendi scomparsa del gump
    set !timeout #systime + 2000
    while #systime < !timeout && #contsize = 615_454
    {
    }
    if #contsize = 615_454
       return #false
return #true

sub setBodbookFilter_getButtonPosition ; %material
    set !m %1
    if all in !m || clear in !m
        return 385_425
    if smith in !m
        return 35_200
    if dull in !m
        return 245_200
    if shadow in !m
        return 340_200
    if copper in !m
        return 425_200
    if bronze in !m
        return 520_200
    if gold in !m
        return 140_240
    if agapite in !m
        return 245_240
    if verite in !m
        return 340_240
    if valorite in !m
        return 425_240
    if iron in !m
        return 140_200
    if tailor in !m
        return 35_280
    if cloth in !m
        return 140_280
    if spined in !m
        return 340_280
    if horned in !m
        return 425_280
    if barbed in !m
        return 520_280
    if leather in !m
        return 245_280
return 0_0







;================================================
;=
;=     Funzioni BodGathering (sperimentali)
;=
;================================================

sub Std_Logout
	  event Macro 8 1 ; Open Paperdoll
	  set !timeout #systime + 5000
	  while #systime < !timeout && #contname <> paperdoll_gump
	  {
	  }
    if #contname <> paperdoll_gump
       return #false

    set !x #contposx + 215
    set !y #contposy + 105
    click !x !y

    while #systime < !timeout && #contname <> YesNo_gump
    {
    }
    if #contname <> YesNo_gump
       return #false

    set !x #contposx + 115
    set !y #contposy + 85
    click !x !y

    while #systime < !timeout && #contname <> MainMenu_gump
    {
    }
return #contname = MainMenu_gump

; @author: Original code by Kal In Ex; modified by AG.
sub Std_Login ; %account %password %charnum
    set !account %1
    set !password %2
    set !charnum %3
    set %1 !null ; Gli argomenti potrebbero essere letti dall'esterno! Meglio cancellarli subito!
    set %2 !null

    while #true ; @todo Introdurre timeout
    {
        wait 20
        if #contname = MainMenu_gump ; main login gump
        {
         	  if !account <> !null
            {
               set !x #contposx + 521
         	 	   set !y #contposy + 356
         		   click !x !y
        	 	   gosub Kal_sendstring !account
            }
        	  set !x #contposx + 521
        	  set !y #contposy + 396
        	  click !x !y
        	  gosub Kal_sendstring !password
            set !x #contposx + 618
            set !y #contposy + 444
            click !x !y ; click the green arrow
        	  gosub Kal_waitgump notfor MainMenu_gump 640_480 10
        	  gosub Kal_waitgump notfor waiting_gump 408_288 60 ; verifying can take a while
        	  continue
        }
        if #contname = normal_gump ; shard selection gump
        {
        		set !x #contposx + 260
        		set !y #contposy + 115
        		click !x !y g   ; click topmost shard not sure why need g
        		gosub Kal_waitgump notfor normal_gump 640_480 10
            continue
        }
        if #contname = Login_gump ; char login gump
     		{
        		set !x #contposx + 360
        		set !y #contposy + 100 + !charnum * 40
            click !x !y ; click char name (changed from d as sometimes seemed to fail)
            set !x #contposx + 618
            set !y #contposy + 444
            click !x !y ; click the green arrow
            gosub Kal_waitgump notfor Login_gump 640_480 1
            continue
     		}
        if  #contname = waiting_gump
        {
        	  if #contsize = 203_121 ; disconnection
        		{
            		set !x #contposx + 100
            		set !y #contposy + 90
            		click !x !y
        		}
        	  if #contsize = 408_288 ; no connection avail, or timeout
        		{
            		set !x #contposx + 206
            		set !y #contposy + 256
            		click !x !y  ; try again
        		}
        		continue
      	}
      	break
    }
return #result
;-------------------------------------------
sub Kal_sendstring
  str Len %1
  set !len #strRes
  for !i 1 16
  {
  	key back ; delete current if any
  }
  for !i 1 !len
  {
  	str Mid %1 !i 1
  	key #strRes
  }
return
 ;-------------------------------------------------
sub Kal_waitgump
  ;%1 = for or notfor %2 = kind of gump %3 = size %4= timeout
  set %timout #scnt + %4
  _wfgloop:
  if #scnt > %timout
  	return
  wait 10
  if %1 = for && ( #contname <> %2 || #contsize <> %3 )
   goto _wfgloop
  if %1 = notfor && #contname = %2 && #contsize = %3
   goto _wfgloop
return



;===========================================================================================================
;* FUNZIONI RAIL
;*
;* Un "oggetto rail" è una stringa formattata come segue: |x1_y1_z1|x2_y2_z2|...|xN_yN_zN|
;* "x1", "y1", "z1", eccetera rappresentano le coordinate di ogni punto della rail.
;* Notare che il separatore "|" viene posto anche all'inizio e alla fine della rail.
;* Ciascuna coordinata può essere dotata di segno "-", ma non di segno "+".
;* La coordinata z può essere omessa.
;* E' responsabilità del programmatore assicurarsi che la rail sia formattata correttamente; per motivi di
;* efficienza, infatti, si escludono tutta una serie di controlli che avrebbero reso le sub più tolleranti.
;*
;* Esempi di rail corrette:
;*    |7890_213_-50|7880_220_-30|7870_230_0|7870_230_41|
;*    |-7890_213|-7880_220|-7870_230|-7870_230|
;* Esempi di rail errate:
;*    7890_213_-50|7880_220_-30|7870_230_0|7870_230_41|   ; manca separatore iniziale
;*    |7890_213_-50|7880_220_-30|7870_230_0|7870_230_41   ; manca separatore finale
;*    |+7890_213_-50|7880_220_-30|7870_230_0|7870_230_41| ; presente un segno "+" per un numero positivo
;*    |7890__213_-50|7880|_7870_230_0_|%7870_$230_#41|    ; vari errori di formattazione
;*
;* Ciascun elemento della rail viene detto "punto".
;* Ogni punto è rappresentato da una stringa del tipo x_y_z, oppure x_y se z non è specificato.
;* Per i punti valgono le stesse regole di formattazione indicate sopra (ad esempio: niente segni "+").
;* La stringa che rappresenta un punto NON contiene il carattere separatore "|".
;*
;* Esempi di punti corretti:
;*    123_432_-40
;*    -123_-432_-40
;*    123_-432
;*
;* E' importante far notare che TUTTE le funzioni Rail operano sempre con singole variabili punto,
;* e NON con coppie di variabili x y oppure triplette di variabili x y z.
;*
;*
;* ELENCO DELLE FUNZIONI (non tutte sono implementate)
;*
;* Rail_GetPoint %rail %index : x_y_z
;* Rail_GetPointIndex %rail %point : int
;* Rail_GetLength %rail : int
;* Rail_SetPoint %rail %index : x_y_z
;* Rail_SubRail %in %start %end : RailObject
;* Rail_ReverseRail %rail : RailObject
;* Rail_Create %varname %startindex %endindex : RailObject
;* Rail_Create |x_y_z|x_y_z|
;* Rail_Contains %rail %point : boolean
;* Rail_Insert %rail %index
;*
;* Rail_GetNearestPoint %rail %x_y_z : x_y_z
;* Rail_GetNearestPointIndex %rail %x_y_z : int
;* Rail_Follow %rail %startindex %endindex
;*
;* Rail_GetPointX %point : int
;* Rail_GetPointY %point : int
;* Rail_GetPointZ %point : int

;===========================================================================
;* @name     Rail_GetPoint
;* @author   AG
;* @purpose  Restituisce un punto della rail, a partire dal suo indice nella rail stessa.
;* @params   %1 req  Oggetto rail.
;*           %2 req  Indice (1-based) del punto da restituire.
;* @returns  Punto della rail nella posizione indicata, oppure !null in caso di errore.
;* @example  gosub safecall Rail_GetPoint %rail 10

sub Rail_GetPoint ; %rail %index
    set !rail %1
    set !index %2

    str pos !rail | !index
    if #strres = 0
       return !null
    set !start #strres + 1
    
    set !index !index + 1
    str pos !rail | !index
    if #strres = 0
       return !null
    set !len #strres - !start
    
    str mid !rail !start !len
return #strres

; old version
    ; strip right
    str pos !temp |
    if #strres = 0
       return !null
    set !x #strres - 1
    str left !temp #strres

    ; strip left
    str pos !temp | !index
    if #strres = 0
       return !null
    str del !temp 1 #strres
    set !temp #strres

    ; strip right
    str pos !temp |
    if #strres = 0
       return !null
    set !x #strres - 1
    str left !temp #strres
return #strres

;===========================================================================
;* @name     Rail_GetPointIndex
;* @author   AG
;* @purpose  Restituisce l'indice di un punto della rail.
;* @params   %1 req  Oggetto rail.
;*           %2 req  Punto di cui restituire l'indice.
;* @returns  Indice del punto nella rail, oppure !null se la rail non contiene il punto.
;* @example  gosub safecall Rail_GetPointIndex %rail 1234_4567_78

sub Rail_GetPointIndex ; %rail %point
    set !rail %1
    set !point | , %2 , |

    str pos !rail | !point
    if #strres = 0
       return !null
    str left !rail #strres
    str count #strres |
return #strres

;===========================================================================
;* @name     Rail_GetLength
;* @author   AG
;* @purpose  Restituisce il numero di punti nella rail.
;* @params   %1 req  Oggetto rail.
;* @returns  Numero di punti nella rail.
;* @example  gosub safecall Rail_GetLength %rail

sub Rail_GetLength %1
    str count %1 |
return #strres - 1

;===========================================================================
;* @name     Rail_ReverseRail
;* @author   AG
;* @purpose  Restituisce una rail invertita rispetto a quella passata come argomento.
;*           Tale rail contiene gli stessi punti della rail sorgente, ma in ordine inverso.
;* @params   %1 req  Oggetto rail.
;* @returns  Rail invertita.
;* @example  gosub safecall Rail_ReverseRail %rail
;* @todo     Questa sub è molto lenta. Ottimizzare.

sub Rail_ReverseRail ; %1
    set !in %1
    set !out |
    gosub safecall Rail_GetLength !in
    set !count #result
    for !i !count 1
    {
        gosub safecall Rail_GetPoint !in !i
        set !out !out , #result , |
    }
return !out

;===========================================================================
;* @name     Rail_GetPointX
;* @author   AG
;* @purpose  Restituisce la coordinata X di un oggetto punto.
;* @params   %1 req  Oggetto punto.
;* @returns  Coordinata X del punto.
;* @example  gosub safecall Rail_GetPointX 0132_-2132_34

sub Rail_GetPointX ; %point
    str pos %1 _
    set !pos #strres - 1
    str left %1 !pos
return #strres

;===========================================================================
;* @name     Rail_GetPointY
;* @author   AG
;* @purpose  Restituisce la coordinata Y di un oggetto punto.
;* @params   %1 req  Oggetto punto.
;* @returns  Coordinata Y del punto.
;* @example  gosub safecall Rail_GetPointY 0132_-2132_34

sub Rail_GetPointY ; %point
    set !string %1 , _
    str pos !string _ 1
    set !start #strres + 1
    str pos !string _ 2
    set !len #strres - !start
    str mid !string !start !len
return #strres

;===========================================================================
;* @name     Rail_GetPointZ
;* @author   AG
;* @purpose  Restituisce la coordinata Z di un oggetto punto.
;* @params   %1 req  Oggetto punto.
;* @returns  Coordinata Z del punto.
;* @example  gosub safecall Rail_GetPointZ 0132_-2132_34

sub Rail_GetPointZ ; %point
    set !string %1 , _
    str pos !string _ 2
    set !start #strres + 1
    str pos !string _ 3
    if #strres = 0
       return !null
    set !len #strres - !start
    str mid !string !start !len
return #strres

; prende un Bod con il PG corrente.
sub Model_BodGather_Cycle
    set !smithBodGathered #false
    set !tailorBodGathered #false
    
    while #true
    {
        if %Location_Name = home
        {
        }

        if runa fabbro { recall, continue }
        if runa sarto { recall, continue }
        { recall home }
    }
return

sub Model_BodGather ; %type (smith|tailor)
    set !bodType %1

    gosub safecall Model_DetectLocation
    if %Location_Name = !bodType
    {
        ; @todo
        continue
    }
    if runa fabbro
    {
    }
    
    gosub safecall Model_GetNearestRail !bodType
    if #result <> !null
    {
    }
return

sub Model_GetNearestRail ; %railType (smith|tailor|inn)
    set !railType %1
    set !charPoint #charposx , _ , #charposy , _ , #charposz
    set !varname Rails_ , !railType , _Count
    set !count % . !varname
    set !nearestRail !null
    set !nearestDist 10
    
    for !i 1 !count
    {
        set !varname Rails_ , !railType , _ , !i
        set !rail % . !varname
        gosub safecall Rail_GetNearestPoint !rail !charPoint
        set !point #result
        gosub safecall Rail_GetPointX !point
        set !point_x #result
        gosub safecall Rail_GetPointY !point
        set !point_y #result
        gosub safecall Rail_GetPointZ !point
        set !point_z #result
        
        set !distX abs ( !point_x - #charposx )
        set !distY abs ( !point_y - #charposy )
        if !distX > !distY
            set !dist !distX
        else
            set !dist !distY
        
        if !dist < !nearestDist
        {
           set !nearestRail !rail
           set !nearestDist !dist
        }
    }
return !nearestRail

sub Model_ChangeChar ; %charNumber
    set !charNumber %1

    ; rail to inn
    ; - se fallisce: recall home
    ;   - se fallisce: return #false
    
    gosub safecall Std_Logout
    call AG_Routines.txt getPassword
    set !password #result
    gosub safecall Std_Login !null !password !charNumber
return

sub Model_BodGatherCycle
return

sub Model_InitRails
    ; Umbra rails
    set !Rail_1    |tailor|2080_1329_-78|2079_1336_-75|2077_1340_-85|2065_1329_-90|2057_1321_-90|2048_1313_-90|2044_1314_-85|inn|
    set !Rail_2    |smith|1982_1359_-80|1986_1365_-80|1992_1367_-75|1995_1367_-83|1996_1367_-87|2003_1367_-90|2008_1362_-90|
                   +2008_1356_-90|2008_1350_-90|2015_1346_-90|2022_1344_-90|2028_1344_-90|2033_1344_-85|2040_1337_-86|2048_1329_-85|
                   +2050_1326_-90|2050_1320_-90|2045_1315_-85|inn|
    set !Rail_3    |tailor|2080_1325_-80|2080_1330_-78|2080_1335_-75|2080_1338_-81|2079_1340_-86|2077_1342_-90|2070_1345_-90|
                   +2064_1345_-90|2061_1345_-85|2055_1345_-83|2047_1345_-85|2041_1345_-80|2038_1345_-85|2033_1345_-85|2029_1345_-90|
                   +2023_1345_-90|2015_1345_-90|2008_1350_-90|2008_1357_-90|2004_1363_-90|1997_1367_-88|1994_1367_-80|1988_1367_-80|
                   +1981_1363_-80|smith|

    event exmsg #charid 3 0 Preparing rails, please wait.
    set !i 0
    while #true
    {
        set !i !i + 1
        set !rail !Rail_ . !i
        if | notin !rail
           return

        for !j 1 2
        {
            if !j = 2
            {
                gosub safecall Rail_ReverseRail !rail
                set !rail #result
            }
            str right !rail 10
            if |smith| in !rail
               set !dest smith
            if |tailor| in !rail
               set !dest tailor
            if |inn| in !rail
               set !dest inn

            ; strip header
            str pos !rail | 2
            set !pos #strres - 1
            str del !rail 1 !pos
            set !rail #strres

            ; strip footer
            str count !rail |
            set !footerIndex #strres - 1
            str pos !rail | !footerIndex
            set !pos #strres + 1
            str left !rail !pos
            set !rail #strres

            set !varname Rails_ , !dest , _count
            set !count % . !varname
            set !count !count + 1
            set % . !varname !count

            set !varname Rails_ , !dest , _ , !count
            set % . !varname !rail
        }
    }
return

sub Std_CheckConnection
    while #contsize = 203_121 ; connection lost
    {
        set !x #contposx + 100
        set !y #contposy + 85
        click !x !y
    }
return #contname <> MainMenu_gump

